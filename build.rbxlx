<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX04EDD7A7F2B64E43B3D92F95BF17B112">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^-1</string>
			<Ref name="CurrentCamera">RBX395BD1AEEEF94E49B90D8E4BD8CE18D0</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsInertiaAndVolumeFix">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<token name="UnionsScaleNonuniformly">0</token>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001da8a</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX395BD1AEEEF94E49B90D8E4BD8CE18D0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>28.9490013</X>
					<Y>8.04837704</Y>
					<Z>-2.09784889</Z>
					<R00>0.998763323</R00>
					<R01>0.00521091046</R01>
					<R02>0.0494444519</R02>
					<R10>-0</R10>
					<R11>0.994492471</R11>
					<R12>-0.104808748</R12>
					<R20>-0.0497182794</R20>
					<R21>0.10467913</R21>
					<R22>0.993262529</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>28.850111</X>
					<Y>8.25799751</Y>
					<Z>-4.08440208</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4ca</UniqueId>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXB641B9BDB3984AD9A4C3A714041C6973">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f58c</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXAF94990F5CE6448298F37C8FA6BF1938">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f47d</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXBC37C523097546C993B903245F777E31">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f489</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXB16C0959BA2A4B1C9128A56269908354">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f48a</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX8E71006564B445E2B55A551E71AA734C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f48f</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX50C10D64C123402A8AF399DE28587948">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f490</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXD0FDB15B649B4E5B965A69881BACF0D7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f492</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f496</UniqueId>
		</Properties>
		<Item class="ModuleScript" referent="1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Cleaner</string>
				<string name="ScriptGuid">{46B9D1E9-6442-4077-BEB4-DC71A4E187C4}</string>
				<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["tpc9000_cleaner@0.1.1"]["cleaner"])
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f534</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TableUtil</string>
				<string name="ScriptGuid">{57532CA4-2D64-4FFF-B4DA-A5CE624DD529}</string>
				<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["tpc9000_tableutil@0.1.1"]["tableutil"])
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f535</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TypeGuard</string>
				<string name="ScriptGuid">{A6576C29-C3C1-442A-B428-B65D4BA388AB}</string>
				<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["tpc9000_typeguard@2.3.0"]["typeguard"])
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f536</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">XSignal</string>
				<string name="ScriptGuid">{2D929A6A-6DAA-489B-9D28-2ADB3262E667}</string>
				<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["tpc9000_xsignal@0.1.0"]["xsignal"])
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f537</UniqueId>
			</Properties>
		</Item>
		<Item class="Folder" referent="5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">_Index</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f538</UniqueId>
			</Properties>
			<Item class="Folder" referent="6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tpc9000_cleaner@0.1.1</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f539</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TypeGuard</string>
						<string name="ScriptGuid">{07EDB068-D8F8-4649-9271-0FBE16EDBFD5}</string>
						<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["tpc9000_typeguard@2.3.0"]["typeguard"])
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f53a</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">cleaner</string>
						<string name="ScriptGuid">{150FE777-E20C-4BF8-B821-9746E8DEF76A}</string>
						<ProtectedString name="Source"><![CDATA[local TypeGuard = require(script.Parent:WaitForChild("TypeGuard"))

local ValidClass = TypeGuard.Object():OfStructure({
    __index = TypeGuard.Object();
    Destroy = TypeGuard.Function();
    new = TypeGuard.Function();
})

local CleanerType = TypeGuard.Object():OfStructure({
    IsCleaner = TypeGuard.Boolean();
})

local DestroyableType = TypeGuard.Object():OfStructure({
    Destroy = TypeGuard.Function();
})

local CustomSignalType = TypeGuard.Object():OfStructure({
    Disconnect = TypeGuard.Function();
})

local CustomMethodType = TypeGuard.Object():OfStructure({
    IsCustomMethod = TypeGuard.Boolean();
})

local CleanableType = TypeGuard.Instance()
                        :Or(TypeGuard.Function())
                        :Or(TypeGuard.Thread())
                        :Or(TypeGuard.RBXScriptConnection())
                        :Or(CleanerType:Equals(function(self)
                            return self -- Cleaners should not be able to Add() themselves because that would just cause recursion overflow
                        end):Negate())
                        :Or(DestroyableType)
                        :Or(CustomSignalType)
                        :Or(CustomMethodType)

local VALIDATE_METHOD_PARAMS = true
local VALIDATE_CLEANABLES = true

local ERR_CLASS_ALREADY_WRAPPED = "Class already wrapped"
local ERR_OBJECT_FINISHED = "Object lifecycle ended, but key %s was indexed"

local TYPE_SCRIPT_CONNECTION = "RBXScriptConnection"
local TYPE_INSTANCE = "Instance"
local TYPE_FUNCTION = "function"
local TYPE_THREAD = "thread"
local TYPE_TABLE = "table"

local OBJECT_FINALIZED_MT = {
    __index = function(_, Key)
        error(ERR_OBJECT_FINISHED:format(tostring(Key)))
    end;
}

local SUPPORTED_OBJECT_METHODS = {"Disconnect", "Destroy", "Clean"}

--- New object & utility functions for handling the lifecycles of Lua objects, aims to help prevent memory leaks
local Cleaner = {}
Cleaner.__index = Cleaner

-- Any extra implementations go here
local SupportedCleanables = {}

SupportedCleanables[TYPE_TABLE] = function(Item)
    local IsLocked = Cleaner.IsLocked

    for _, MethodName in SUPPORTED_OBJECT_METHODS do
        if (IsLocked(Item)) then
            break
        end

        local Method = Item[MethodName]

        if (not Method) then
            continue
        end

        Method(Item)
    end

    -- There should be no last resort case because the type validator should filter in all supported object types
end

SupportedCleanables[TYPE_THREAD] = function(Item)
    coroutine.close(Item)
end

SupportedCleanables[TYPE_FUNCTION] = function(Item)
    Item()
end

SupportedCleanables[TYPE_SCRIPT_CONNECTION] = function(Item)
    Item:Disconnect()
end

SupportedCleanables[TYPE_INSTANCE] = function(Item)
    Item:Destroy()
end

function Cleaner.new()
    return setmetatable({
        IsCleaner = true;
        _DidClean = false;
        _CleanList = {};
        _Index = 1;
    }, Cleaner)
end

local AddParams = TypeGuard.VariadicParamsWithContext(CleanableType)
--- Adds an object to this Cleaner. Object must be one of the following:
--- - Cleaner
--- - Function
--- - Coroutine / Thread
--- - Roblox Instance
--- - Roblox Event Connection
--- - Custom Method (via Cleaner.CustomMethod)
--- - Table containing one of the following methods:
---   - Object:Clean()
---   - Object:Destroy()
---   - Object:Disconnect()
function Cleaner:Add(...): typeof(Cleaner)
    if (VALIDATE_CLEANABLES) then
        AddParams(self, ...)
    end

    local CleanList = self._CleanList

    -- Verify types & push onto array
    local Size = select("#", ...)
    local Index = self._Index

    for Arg = 1, Size do
        local Item = select(Arg, ...)
        CleanList[Index] = Item
        Index += 1
    end

    self._Index = Index

    -- Add after Clean called? Likely result of bad yielding, so clean up whatever is doing this.
    if (self._DidClean) then
        self:Clean()
    end

    return self
end
Cleaner.add = Cleaner.Add

--- Cleans and locks this Cleaner preventing it from being used again. If an object is added to the Cleaner after it has been locked, it will be cleaned immediately.
function Cleaner:Clean()
    local CleanList = self._CleanList

    for Index, Item in CleanList do
        SupportedCleanables[typeof(Item)](Item)
        CleanList[Index] = nil
    end

    self._Index = 1
    self._DidClean = true
end
Cleaner.clean = Cleaner.Clean

--- Adds whatever coroutine called this method to the Cleaner
function Cleaner:AddContext(): typeof(Cleaner)
    return self:Add(coroutine.running())
end
Cleaner.addContext = Cleaner.AddContext

local function CleanerSpawn(self, Call, ...)
    self:AddContext()
    Call(...)
end

local SpawnParams = TypeGuard.Params(TypeGuard.Function())
--- Spawns a coroutine & adds to the Cleaner
function Cleaner:Spawn(Callback, ...): typeof(Cleaner)
    if (VALIDATE_METHOD_PARAMS) then
        SpawnParams(Callback)
    end

    task.spawn(CleanerSpawn, self, Callback, ...)
    return self
end
Cleaner.spawn = Cleaner.Spawn

local function CleanerDelay(Duration, Call, ...)
    task.wait(Duration)
    Call()
end

local DelayParams = TypeGuard.Params(TypeGuard.Number(), TypeGuard.Function())
--- Delays a spawned coroutine & adds to cleaner
function Cleaner:Delay(Time, Callback, ...): typeof(Cleaner)
    if (VALIDATE_METHOD_PARAMS) then
        DelayParams(Time, Callback)
    end

    self:Spawn(CleanerDelay, Time, Callback, ...)
    return self
end
Cleaner.delay = Cleaner.Delay

-------------------- Standalone functions --------------------

local LockParams = TypeGuard.Params(TypeGuard.Object())
--- Permanently locks down an object once finished
function Cleaner.Lock(Object)
    if (VALIDATE_METHOD_PARAMS) then
        LockParams(Object)
    end

    -- Have to "nil" everything to ensure the __index error works
    for Key in Object do
        Object[Key] = nil
    end

    setmetatable(Object, OBJECT_FINALIZED_MT)
    table.freeze(Object)
end

local WrapParams = TypeGuard.Params(ValidClass)
--- Wraps the class to ensure more lifecycle safety, including auto-lock on Destroy
function Cleaner.Wrap(Class)
    if (VALIDATE_METHOD_PARAMS) then
        WrapParams(Class)
        assert(not Cleaner.IsWrapped(Class), ERR_CLASS_ALREADY_WRAPPED)
    end

    local OriginalDestroy = Class.Destroy

    Class.Destroy = function(self, ...)
        OriginalDestroy(self, ...)
        Cleaner.Lock(self)
    end

    Class._CLEANER_WRAPPED = true

    return Class
end
Cleaner.wrap = Cleaner.Wrap

local IsWrappedParams = TypeGuard.Params(ValidClass)
--- Determines if a class is already wrapped
function Cleaner.IsWrapped(Class)
    if (VALIDATE_METHOD_PARAMS) then
        IsWrappedParams(Class)
    end

    return Class._CLEANER_WRAPPED ~= nil
end
Cleaner.isWrapped = Cleaner.IsWrapped

local IsLockedParams = TypeGuard.Params(TypeGuard.Object())
-- Determines if an object is locked via the mechanism in Cleaner
function Cleaner.IsLocked(Object)
    if (VALIDATE_METHOD_PARAMS) then
        IsLockedParams(Object)
    end

    return getmetatable(Object) == OBJECT_FINALIZED_MT
end
Cleaner.isLocked = Cleaner.IsLocked

local CustomMethodParams = TypeGuard.Params(TypeGuard.Object(), TypeGuard.String())
-- Creates an object which signals for a Cleaner to call an arbitrary method name with a set of params
function Cleaner.CustomMethod(Object, Name, ...)
    if (VALIDATE_METHOD_PARAMS) then
        CustomMethodParams(Object, Name)
    end

    return {
        _Args = {...};
        IsCustomMethod = true;

        Destroy = function(self)
            Object[Name](Object, unpack(self._Args))
        end;
    };
end

return Cleaner]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f53b</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">init.spec</string>
							<string name="ScriptGuid">{D2610515-E483-4D52-A993-C180778595D6}</string>
							<ProtectedString name="Source"><![CDATA[return function()
    local Cleaner = require(script.Parent)

    local function GetTestClass()
        local TestClass = {}
        TestClass.__index = TestClass

        function TestClass.new()
            return setmetatable({}, TestClass)
        end

        function TestClass:Destroy() end

        return TestClass
    end

    describe("Cleaner.new", function()
        it("should create a new Cleaner", function()
            expect(Cleaner.new()).never.to.equal(nil)
            expect(Cleaner.new()).to.be.a("table")
        end)
    end)

    describe("Cleaner.Add", function()
        it("should reject invalid objects", function()
            expect(function() -- Number
                Cleaner.new():Add(1)
            end).to.throw()

            expect(function() -- String
                Cleaner.new():Add("test")
            end).to.throw()

            expect(function() -- Empty/unsupported object
                Cleaner.new():Add({})
            end).to.throw()
        end)

        it("should accept only valid CleanableObjects", function()
            expect(function() -- Instance
                Cleaner.new():Add(Instance.new("Part"))
            end).never.to.throw()

            expect(function() -- Inbuilt Signal connection
                local Connection = game.ChildAdded:Connect(function() end)
                Cleaner.new():Add(Connection)
                Connection:Disconnect()
            end).never.to.throw()

            expect(function() -- Cleaner
                Cleaner.new():Add(Cleaner.new())
            end).never.to.throw()

            expect(function() -- Coroutine
                Cleaner.new():Add(coroutine.running())
            end).never.to.throw()

            expect(function() -- Function
                Cleaner.new():Add(function() end)
            end).never.to.throw()

            expect(function() -- Custom object
                Cleaner.new():Add({
                    Destroy = function() end;
                })
            end).never.to.throw()

            expect(function() -- Custom Signal implementation
                Cleaner.new():Add({
                    Disconnect = function() end;
                })
            end).never.to.throw()
        end)

        it("should accept multiple CleanableObjects as args", function()
            expect(function()
                Cleaner.new():Add({
                    Destroy = function() end;
                }, {
                    Disconnect = function() end;
                })
            end).never.to.throw()
        end)

        it("should reject when Cleaner is passed itself", function()
            local Test = Cleaner.new()

            expect(function()
                Test:Add(Test)
            end).to.throw()

            expect(function()
                Test:Add({Test})
            end).to.throw()

            expect(function()
                Test:Add({game, Test})
            end).to.throw()
        end)
    end)

    describe("Cleaner.Clean", function()
        it("should destroy Instances", function()
            local Part = Instance.new("Part")
            Part.Parent = game:GetService("Workspace")

            local Test = Cleaner.new()
            Test:Add(Part)
            Test:Clean()

            expect(Part.Parent).to.equal(nil)
        end)

        it("should clean up script signal connections", function()
            local Part = Instance.new("Part")
            local Activated = 0

            local Test = Cleaner.new()
            Test:Add(Part.ChildAdded:Connect(function()
                Activated += 1
            end))
            Instance.new("Part", Part)
            Test:Clean()
            Instance.new("Part", Part)

            expect(Activated).to.equal(1)
        end)

        it("should clean up other cleaners", function()
            local Cleaned = false

            local Test1 = Cleaner.new()
                local Test2 = Cleaner.new()
                Test2:Add(function()
                    Cleaned = true
                end)
            Test1:Add(Test2)
            Test1:Clean()

            expect(Cleaned).to.equal(true)
        end)

        it("should close coroutines", function()
            local Closed = true
            local Running

            task.spawn(function()
                Running = coroutine.running()
                task.wait()
                Closed = false
            end)

            local Test = Cleaner.new()
            Test:Add(Running)
            Test:Clean()

            task.wait()
            expect(Closed).to.equal(true)
        end)

        --[[ it("should run functions async", function()
            local Count = 0

            local Test = Cleaner.new()

            for _ = 1, 5 do
                Test:Add(function()
                    Count += 1
                end)
            end

            for _ = 1, 5 do
                Test:Add(function()
                    task.wait(1)
                    Count += 1
                end)
            end

            local Time = os.clock()
            Test:Clean()
            expect(os.clock() - Time).to.be.near(0, 1/1000)
            expect(Count).to.equal(5)
        end) ]]

        it("should call Destroy on custom objects", function()
            local Test = Cleaner.new()
            local Destroyed = false

            Test:Add({
                Destroy = function()
                    Destroyed = true
                end;
            })

            expect(Destroyed).to.equal(false)
            Test:Clean()
            expect(Destroyed).to.equal(true)
        end)

        it("should call Disconnect on custom signals", function()
            local Test = Cleaner.new()
            local Disconnected = false

            Test:Add({
                Disconnect = function()
                    Disconnected = true
                end;
            })

            expect(Disconnected).to.equal(false)
            Test:Clean()
            expect(Disconnected).to.equal(true)
        end)

        it("should clean up with custom method support", function()
            local Test = Cleaner.new()
            local DidRun = false

            local Object = {
                Test = function(_, X, Y, Z)
                    expect(X).to.equal(1)
                    expect(Y).to.equal(2)
                    expect(Z).to.equal(3)

                    DidRun = true
                end
            }
            Test:Add(Test.CustomMethod(Object, "Test", 1, 2, 3))
            Test:Clean()

            expect(DidRun).to.equal(true)
        end)
    end)

    describe("Cleaner.Add, Cleaner.Clean", function()
        it("should automatically clean for items added after", function()
            local Test = Cleaner.new()
            local Count = 0

            Test:Add({
                Disconnect = function()
                    Count += 1
                end;
            })

            Test:Clean()

            Test:Add({
                Disconnect = function()
                    Count += 1
                end;
            })

            expect(Count).to.equal(2)
        end)
    end)

    describe("Cleaner.Spawn", function()
        it("should spawn a function async", function()
            local Complete = false

            Cleaner.new():Spawn(function()
                Complete = true
            end)

            expect(Complete).to.equal(true)
        end)

        it("should terminate the spawned coroutine when Clean is called", function()
            local Test = Cleaner.new()
            local Complete = false

            Test:Spawn(function()
                task.wait()
                Complete = true
            end)
            Test:Clean()

            task.wait()
            expect(Complete).to.equal(false)
        end)
    end)

    describe("Cleaner.Lock", function()
        it("should throw with no object given", function()
            expect(function()
                Cleaner.Lock()
            end).to.throw()
        end)

        it("should accept an object", function()
            expect(function()
                Cleaner.Lock({})
            end).never.to.throw()
        end)

        it("should disallow reads on an object", function()
            local Object = {
                X = 1;
            }

            Cleaner.Lock(Object)

            expect(function()
                local Temp1 = Object.X
            end).to.throw()

            expect(function()
                local Temp2 = Object.Y
            end).to.throw()
        end)

        it("should disallow writes on an object", function()
            local Object = {
                X = 1;
            }

            Cleaner.Lock(Object)

            expect(function()
                Object.X = 2
            end).to.throw()

            expect(function()
                Object.Y = 3
            end).to.throw()
        end)
    end)

    describe("Cleaner.Wrap", function()
        it("should throw with no class given", function()
            expect(function()
                Cleaner.Wrap()
            end).to.throw()
        end)

        it("should throw with an invalid class given", function()
            expect(function()
                Cleaner.Wrap({
                    new = function() end;
                })
            end).to.throw()

            expect(function()
                Cleaner.Wrap({
                    __index = {}
                })
            end).to.throw()
        end)

        it("should accept a valid class", function()
            local Test = GetTestClass()

            expect(function()
                Cleaner.Wrap(Test)
            end).never.to.throw()
        end)

        it("should lock a destroyed object down", function()
            local Test = GetTestClass()
            Cleaner.Wrap(Test)

            expect(function()
                local Temp = Test.X
            end).never.to.throw()

            expect(function()
                Test.Y = 1
            end).never.to.throw()

            Test:Destroy()

            expect(function()
                local Temp = Test.X
            end).to.throw()

            expect(function()
                Test.Y = 2
            end).to.throw()
        end)

        it("should prevent multiple wraps", function()
            local Test = GetTestClass()
            Cleaner.Wrap(Test)

            expect(function()
                Cleaner.Wrap(Test)
            end).to.throw()
        end)

        it("should work without Destroy being initially present", function()
            local Test1 = GetTestClass()
            Cleaner.Wrap(Test1)
            expect(Test1.Destroy).to.be.ok()

            local Test2 = GetTestClass()
            local Destroyed = false

            function Test2:Destroy()
                Destroyed = true
            end

            Cleaner.Wrap(Test2)
            Test2.new():Destroy()
            expect(Destroyed).to.equal(true)
        end)
    end)

    describe("Cleaner.Wrap, Cleaner.IsWrapped", function()
        it("should detect when a class is wrapped", function()
            local Test = GetTestClass()
            expect(Cleaner.IsWrapped(Test)).to.equal(false)
            Cleaner.Wrap(Test)
            expect(Cleaner.IsWrapped(Test)).to.equal(true)
        end)
    end)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f53c</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="10">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tpc9000_tableutil@0.1.1</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f53d</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="11">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tableutil</string>
						<string name="ScriptGuid">{1D0C5B7D-A102-4BC8-808E-C0D4B2817418}</string>
						<ProtectedString name="Source"><![CDATA[return {
    Array = require(script:WaitForChild("Array"));
    Dict = require(script:WaitForChild("Map"));
    Map = require(script:WaitForChild("Map"));
    Set = require(script:WaitForChild("Set"));
};]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f53e</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="12">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Array</string>
							<string name="ScriptGuid">{A2D4E974-5A38-4775-AA0F-91945CE5DCC8}</string>
							<ProtectedString name="Source"><![CDATA[return {
    SelectFirst1D = require(script:WaitForChild("SelectFirst1D"));
    SelectLast1D = require(script:WaitForChild("SelectLast1D"));
    FoldRight1D = require(script:WaitForChild("FoldRight1D"));
    FoldLeft1D = require(script:WaitForChild("FoldLeft1D"));
    Shuffle1D = require(script:WaitForChild("Shuffle1D"));
    Reverse1D = require(script:WaitForChild("Reverse1D"));
    Remove1D = require(script:WaitForChild("Remove1D"));
    Filter1D = require(script:WaitForChild("Filter1D"));
    Insert1D = require(script:WaitForChild("Insert1D"));
    Merge1D = require(script:WaitForChild("Merge1D"));
    Sort1D = require(script:WaitForChild("Sort1D"));
    Copy1D = require(script:WaitForChild("Copy1D"));
    Cut1D = require(script:WaitForChild("Cut1D"));
    Map1D = require(script:WaitForChild("Map1D"));
};]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f53f</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="13">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Copy1D</string>
								<string name="ScriptGuid">{1750DB0A-8958-456F-BC6E-431603D55F33}</string>
								<ProtectedString name="Source"><![CDATA[--- Copies an array
--- @deprecated Use table.clone instead
return table.clone]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f540</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="14">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Copy1D.spec</string>
								<string name="ScriptGuid">{84F1A995-F018-4CBA-BABD-9E7FC46DB84D}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Copy1D = require(script.Parent.Copy1D)

    describe("Array/Copy1D", function()
        it("should copy a blank table with no contents", function()
            local Original = {}
            local Copied = Copy1D(Original)

            expect(Copied).to.never.equal(Original)
            expect(next(Copied)).to.never.be.ok()
        end)

        it("should copy the first element of an array", function()
            local Original = {100}
            local Copied = Copy1D(Original)

            expect(Copied).never.to.equal(Original)
            expect(Copied[1]).to.equal(Original[1])
        end)

        it("should copy all elements of an array", function()
            local Original = {1, 2, 3, 4}
            local Copied = Copy1D(Original)

            expect(Copied).never.to.equal(Original)
            expect(Copied[1]).to.equal(Original[1])
            expect(Copied[2]).to.equal(Original[2])
            expect(Copied[3]).to.equal(Original[3])
            expect(Copied[4]).to.equal(Original[4])
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f541</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="15">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Cut1D</string>
								<string name="ScriptGuid">{B0199FEC-FB41-4B8B-9674-58FA00884CEB}</string>
								<ProtectedString name="Source"><![CDATA[--- Cuts a chunk from an array given a starting and ending index - the difference in these indexes can be negative - faster if positive e.g. Cut1D(X, 1, 4) over Cut1D(X, 4, 1)
local function Cut1D<T>(Array: {T}, From: number, To: number): {T}
    local Size = #Array

    assert(From >= 1, "Start index less than 1!")
    assert(To >= 1, "End index greater than 1!")

    assert(From <= Size, "Start index beyond array length!")
    assert(To <= Size, "End index beyond array length!")

    local Diff = To - From
    local Range = math.abs(Diff)

    if (Range == Size - 1) then
        return Array
    end

    if (Diff > 0) then
        -- Faster, but table.move doesn't support iterating backwards over a range
        return table.move(Array, From, To, 1, {})
    end

    local Result = table.create(Range)
    local ResultIndex = 1

    for Index = From, To, -1 do
        Result[ResultIndex] = Array[Index]
        ResultIndex += 1
    end

    return Result
end

return Cut1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f542</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="16">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Cut1D.spec</string>
								<string name="ScriptGuid">{3994B8A6-7547-4823-98AA-0C16BC308BEC}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Cut1D = require(script.Parent.Cut1D)

    describe("Array/Cut1D", function()
        it("should return the first element given range 1, 1", function()
            local Result = Cut1D({1234}, 1, 1)
            expect(Result[1]).to.equal(1234)
        end)

        it("should return the middle two elements of a 4-item array given range 2, 3", function()
            local Result = Cut1D({1, 2, 3, 4}, 2, 3)
            expect(Result[1]).to.equal(2)
            expect(Result[2]).to.equal(3)
            expect(Result[3]).never.to.be.ok()
        end)

        it("should throw an error if either index is less than 1", function()
            expect(function()
                Cut1D({}, 0, 1)
            end).to.throw()

            expect(function()
                Cut1D({}, 1, 0)
            end).to.throw()
        end)

        it("should throw an error if either index is greater than the array length", function()
            expect(function()
                Cut1D({1, 2}, 1, 3)
            end).to.throw()

            expect(function()
                Cut1D({1, 2}, 3, 1)
            end).to.throw()
        end)

        it("should return the original array if the range is equivalent to the array's length", function()
            local Test = {1, 2, 3, 4}
            local Result = Cut1D(Test, 1, 4)

            expect(Result).to.equal(Test)
        end)

        it("should cut backwards", function()
            local Result = Cut1D({1, 2, 3, 4}, 3, 1)
            expect(Result[1]).to.equal(3)
            expect(Result[2]).to.equal(2)
            expect(Result[3]).to.equal(1)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f543</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="17">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Filter1D</string>
								<string name="ScriptGuid">{9056468B-8CBC-4BF0-895D-612244288D53}</string>
								<ProtectedString name="Source"><![CDATA[--- Filters an array for all items which satisfy some condition
local function Filter1D<T>(Array: {T}, Condition: (T, number) -> boolean, Allocate: number?): {T}
    local Result = table.create(Allocate or 0)
    local Index = 1

    for ItemIndex, Value in Array do
        if (Condition(Value, ItemIndex)) then
            Result[Index] = Value
            Index += 1
        end
    end

    return Result
end

return Filter1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f544</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="18">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Filter1D.spec</string>
								<string name="ScriptGuid">{7DE725DF-24A4-4A4C-B892-F2D759C31476}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Filter1D = require(script.Parent.Filter1D)

    describe("Array/Filter1D", function()
        it("should return a blank table for no data", function()
            local Results = Filter1D({}, function()
                return true
            end)

            expect(next(Results)).never.to.be.ok()
        end)

        it("should return all items in order for true condition", function()
            local Results = Filter1D({3, 2, 1}, function()
                return true
            end)

            expect(Results[1]).to.equal(3)
            expect(Results[2]).to.equal(2)
            expect(Results[3]).to.equal(1)
        end)

        it("should return no items for false condition", function()
            local Results = Filter1D({3, 2, 1}, function()
                return false
            end)

            expect(next(Results)).never.to.be.ok()
        end)

        it("should filter all items larger than some value in order", function()
            local Results = Filter1D({8, 4, 2, 1}, function(Value)
                return Value >= 4
            end)

            expect(Results[1]).to.equal(8)
            expect(Results[2]).to.equal(4)
            expect(Results[3]).never.to.be.ok()
        end)

        it("should pass the index in order", function()
            Filter1D({1, 2, 3, 4}, function(Value, Index)
                expect(Index).to.equal(Value)
                return true
            end)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f545</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="19">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FoldLeft1D</string>
								<string name="ScriptGuid">{EC517E6C-209E-42BA-99BF-9E902EAE58B6}</string>
								<ProtectedString name="Source"><![CDATA[--- Reduces an array to a single value from its left-most value to its right-most value
local function FoldLeft1D<T>(Array: {T}, Processor: (T, T, number, number) -> T, Initial: T): T
    local Aggregate = Initial
    local Size = #Array

    for Index = 1, Size do
        Aggregate = Processor(Aggregate, Array[Index], Index, Size)
    end

    return Aggregate
end

return FoldLeft1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f546</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="20">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FoldLeft1D.spec</string>
								<string name="ScriptGuid">{4A07362F-49B5-4874-8384-4525AF56F2EB}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local FoldLeft1D = require(script.Parent.FoldLeft1D)

    describe("Array/FoldLeft1D", function()
        it("should not call on an empty table", function()
            local Called = false

            FoldLeft1D({}, function()
                Called = true
            end, 1)

            expect(Called).to.equal(false)
        end)

        it("should return an initial value with no operations", function()
            local Result = FoldLeft1D({}, function() end, 1)

            expect(Result).to.equal(1)
        end)

        it("should call in order", function()
            local Indexes = {}

            FoldLeft1D({1, 2, 3, 4}, function(_, _, Index)
                table.insert(Indexes, Index)
            end)

            for Index = 1, 4 do
                expect(Indexes[Index]).to.equal(Index)
            end
        end)

        it("should correctly give the size of the array", function()
            FoldLeft1D({1, 2, 3, 4}, function(_, _, _, Size)
                expect(Size).to.equal(4)
            end)
        end)

        it("should sum up some values with a sum function", function()
            local Result = FoldLeft1D({1, 2, 3, 4}, function(Aggr, Value)
                return Aggr + Value
            end, 0)

            expect(Result).to.equal(10)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f547</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="21">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FoldRight1D</string>
								<string name="ScriptGuid">{23FF6B5D-30E2-4B89-9646-466AE84E0930}</string>
								<ProtectedString name="Source"><![CDATA[--- Reduces an array to a single value from its right-most value to its left-most value
local function FoldRight1D<T>(Array: {T}, Processor: (T, T, number, number) -> T, Initial: T): T
    local Aggregate = Initial
    local Size = #Array

    for Index = Size, 1, -1 do
        Aggregate = Processor(Aggregate, Array[Index], Index, Size)
    end

    return Aggregate
end

return FoldRight1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f548</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="22">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FoldRight1D.spec</string>
								<string name="ScriptGuid">{96C4B854-EDF4-4A73-A659-305775BC3CAE}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local FoldRight1D = require(script.Parent.FoldRight1D)

    describe("Array/FoldRight1D", function()
        it("should not call on an empty table", function()
            local Called = false

            FoldRight1D({}, function()
                Called = true
            end, 1)

            expect(Called).to.equal(false)
        end)

        it("should return an initial value with no operations", function()
            local Result = FoldRight1D({}, function() end, 1)

            expect(Result).to.equal(1)
        end)

        it("should call in order", function()
            local Indexes = {}

            FoldRight1D({1, 2, 3, 4}, function(_, _, Index)
                table.insert(Indexes, Index)
            end)

            for Index = 1, 4 do
                expect(Indexes[Index]).to.equal(5 - Index)
            end
        end)

        it("should correctly give the size of the array", function()
            FoldRight1D({1, 2, 3, 4}, function(_, _, _, Size)
                expect(Size).to.equal(4)
            end)
        end)

        it("should sum up some values with a sum function", function()
            local Result = FoldRight1D({1, 2, 3, 4}, function(Aggr, Value)
                return Aggr + Value
            end, 0)

            expect(Result).to.equal(10)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f549</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="23">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Insert1D</string>
								<string name="ScriptGuid">{4F1D6E7F-FE2A-40FD-8648-8926495F33A9}</string>
								<ProtectedString name="Source"><![CDATA[--- Inserts a value into an array with an optional "insert at" index
local function Insert1D<T>(Array: {T}, Value: T, At: number?): {T}
    local NewSize = #Array + 1
    local Result = table.create(NewSize)
    At = At or NewSize

    assert(At >= 1 and At <= NewSize, "Insert index out of array range")

    table.move(Array, 1, At - 1, 1, Result)
    Result[At] = Value
    table.move(Array, At, NewSize - 1, At + 1, Result)

    return Result
end

return Insert1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f54a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="24">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Insert1D.spec</string>
								<string name="ScriptGuid">{E9253353-1400-4AE0-BEFB-795F4B540654}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Insert1D = require(script.Parent.Insert1D)

    describe("Array/Insert1D", function()
        it("should insert an item in the first position in an empty array", function()
            local Result = Insert1D({}, 1)

            expect(Result[1]).to.be.ok()
            expect(Result[1]).to.equal(1)
        end)

        it("should insert two items in order into an empty array", function()
            local Result = {}
            Result = Insert1D(Insert1D(Result, 1), 2)

            for Index = 1, 2 do
                expect(Result[Index]).to.be.ok()
                expect(Result[Index]).to.equal(Index)
            end
        end)

        it("should allow insertion at an inner index", function()
            local Result = {1, 2, 4, 5}
            Result = Insert1D(Result, 3, 3)

            for Index = 1, 5 do
                expect(Result[Index]).to.be.ok()
                expect(Result[Index]).to.equal(Index)
            end
        end)

        it("should allow insertion at index 1", function()
            local Result = {2, 3}
            Result = Insert1D(Result, 1, 1)

            for Index = 1, 3 do
                expect(Result[Index]).to.be.ok()
                expect(Result[Index]).to.equal(Index)
            end
        end)

        it("should disallow insertion at index length+2", function()
            expect(function()
                Insert1D({1, 2}, 1000, 4, true)
            end).to.throw()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f54b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="25">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Map1D</string>
								<string name="ScriptGuid">{8E1AE379-5560-4CF8-9853-5AB222F06F32}</string>
								<ProtectedString name="Source"><![CDATA[--- Puts an array's values through a transformation function, mapping the outputs into a new array - nil values will be skipped & will not leave holes in the new array
local function Map1D<T>(Array: {T}, Operator: (T, number) -> T?, Allocate: number?): {T}
    local Result = table.create(Allocate or 0)
    local Index = 1

    for ItemIndex = 1, #Array do
        local Value = Array[ItemIndex]
        local Transformed = Operator(Value, ItemIndex)

        if (Transformed == nil) then
            -- Skip nil values
            continue
        end

        Result[Index] = Transformed
        Index += 1
    end

    return Result
end

return Map1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f54c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="26">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Map1D.spec</string>
								<string name="ScriptGuid">{C3F1DC32-010B-4708-8550-FCE052DAB08C}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Map1D = require(script.Parent.Map1D)

    describe("Array/Map1D", function()
        it("should return a blank array if passed in a blank array", function()
            local Result = Map1D({}, function(Value, Key)
                return Key, Value
            end)

            expect(next(Result)).to.equal(nil)
        end)

        it("should return all items in an array with a function passing back the same value, in order", function()
            local Result = Map1D({1, 2, 3, 4}, function(Value)
                return Value
            end)

            for Index = 1, 4 do
                expect(Result[Index]).to.equal(Index)
            end
        end)

        it("should double all items in an array with a double function, in order", function()
            local Result = Map1D({1, 2, 3, 4}, function(Value)
                return Value * 2
            end)

            for Index = 1, 4 do
                expect(Result[Index]).to.equal(Index * 2)
            end
        end)

        it("should ignore nil returns from the operation function", function()
            local Result = Map1D({1, 2, 3, 4}, function(Value)
                if (Value < 3) then
                    return nil
                end

                return Value
            end)

            expect(Result[1]).to.equal(3)
            expect(Result[2]).to.equal(4)
            expect(Result[3]).never.to.be.ok()
        end)

        it("should send the index to the operation function", function()
            Map1D({2, 4, 6, 8}, function(Value, Index)
                expect(Value / 2).to.equal(Index)
            end)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f54d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="27">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Merge1D</string>
								<string name="ScriptGuid">{123A414A-873B-4AC9-B982-6C8935245875}</string>
								<ProtectedString name="Source"><![CDATA[--- Merges multiple arrays together, in order
local function Merge1D<T>(...: {T}): {T}
    local Result = table.clone(select(1, ...))
    local Index = #Result + 1

    for SubArrayIndex = 2, select("#", ...) do
        local SubArray = select(SubArrayIndex, ...)
        local Size = #SubArray
        table.move(SubArray, 1, Size, Index, Result)
        Index += Size
    end

    return Result
end

return Merge1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f54e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="28">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Merge1D.spec</string>
								<string name="ScriptGuid">{F818249A-141C-48F8-AC65-21114402FC93}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Merge1D = require(script.Parent.Merge1D)

    describe("Array/Merge1D", function()
        it("should merge two blank arrays into a blank array", function()
            local Result = Merge1D({}, {})
            expect(next(Result)).to.never.be.ok()
        end)

        it("should merge more than two blank arrays into a blank array", function()
            local Result = Merge1D({}, {}, {}, {})
            expect(next(Result)).to.never.be.ok()
        end)

        it("should merge several one-item arrays into a final array, in order", function()
            local Result = Merge1D({1}, {2}, {3}, {4})

            for Index = 1, 4 do
                expect(Result[Index]).to.equal(Index)
            end
        end)

        it("should merge several multiple-item arrays into a final array, in order", function()
            local Result = Merge1D({1, 2, 3}, {4}, {5, 6}, {7, 8, 9, 10})

            for Index = 1, 10 do
                expect(Result[Index]).to.equal(Index)
            end
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f54f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="29">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Remove1D</string>
								<string name="ScriptGuid">{335B1A45-3C7F-4E83-8D14-776B9FCB3A14}</string>
								<ProtectedString name="Source"><![CDATA[--- Removes a single element from an array
local function Remove1D<T>(Array: {T}, Index: number): {T}
    local ArrayLength = #Array

    if (ArrayLength == 0) then
        return {}
    end

    Index = Index or ArrayLength

    assert(Index > 0, "Index must be greater than 0!")
    assert(Index <= ArrayLength, "Index out of bounds!")

    local Result = table.create(ArrayLength - 1)
    table.move(Array, 1, Index - 1, 1, Result)
    table.move(Array, Index + 1, ArrayLength, Index, Result)

    return Result
end

return Remove1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f550</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="30">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Remove1D.spec</string>
								<string name="ScriptGuid">{6F554D46-AC3C-4EC8-9A68-2E89DE44E004}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Remove1D = require(script.Parent.Remove1D)

    describe("Array/Remove1D", function()
        it("should return an empty array upon removing from an empty array", function()
            local Original = {}
            local Result = Remove1D(Original)

            expect(next(Result)).to.equal(nil)
            expect(Original).never.to.equal(Result)
        end)

        it("should remove the last item in a two-item array", function()
            local Result = Remove1D({1, 2})
            expect(Result[1]).to.equal(1)
            expect(Result[2]).never.to.be.ok()
        end)

        it("should remove the last item multiple times", function()
            local Result = Remove1D({1, 2, 3, 4})
            expect(Result[1]).to.equal(1)
            expect(Result[2]).to.equal(2)
            expect(Result[3]).to.equal(3)
            expect(Result[4]).never.to.be.ok()

            Result = Remove1D(Result)
            expect(Result[1]).to.equal(1)
            expect(Result[2]).to.equal(2)
            expect(Result[3]).never.to.be.ok()

            Result = Remove1D(Result)
            expect(Result[1]).to.equal(1)
            expect(Result[2]).never.to.be.ok()

            Result = Remove1D(Result)
            expect(Result[1]).never.to.be.ok()
        end)

        it("should remove an item in the middle", function()
            local Result = Remove1D({1, 2, 3, 4}, 2)
            expect(Result[1]).to.equal(1)
            expect(Result[2]).to.equal(3)
            expect(Result[3]).to.equal(4)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f551</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="31">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Reverse1D</string>
								<string name="ScriptGuid">{5C896991-0AB6-4B43-B795-53ACBEA01026}</string>
								<ProtectedString name="Source"><![CDATA[--- Flips all items in an array
local function Reverse1D<T>(Array: {T}): {T}
    local ArraySize = #Array
    local Result = table.create(ArraySize)

    for Index = 1, ArraySize do
        Result[Index] = Array[ArraySize - Index + 1]
    end

    return Result
end

return Reverse1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f552</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="32">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Reverse1D.spec</string>
								<string name="ScriptGuid">{ADCDC92F-B512-4EEE-B785-A940F4DC2014}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Reverse1D = require(script.Parent.Reverse1D)

    describe("Array/Reverse1D", function()
        it("should return an empty array if passed an empty array", function()
            local Result = Reverse1D({})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return a one-item array from a one-item array", function()
            local Result = Reverse1D({1})
            expect(Result[1]).to.equal(1)
        end)

        it("should swap two items in a two-item array", function()
            local Result = Reverse1D({1, 2})
            expect(Result[1]).to.equal(2)
            expect(Result[2]).to.equal(1)
        end)

        it("should swap items in an odd-number-of-items array", function()
            local Result = Reverse1D({1, 2, 3})
            expect(Result[1]).to.equal(3)
            expect(Result[2]).to.equal(2)
            expect(Result[3]).to.equal(1)
        end)

        it("should reverse 1000 items", function()
            local Result = {}

            for Index = 1, 1000 do
                table.insert(Result, Index)
            end

            Result = Reverse1D(Result)

            for Index = 1, 1000 do
                expect(Result[Index]).to.equal(1000 - Index + 1)
            end
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f553</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="33">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SelectFirst1D</string>
								<string name="ScriptGuid">{69ECC011-757B-48CC-B103-5080B304BB66}</string>
								<ProtectedString name="Source"><![CDATA[--- Selects the first item in an array which satisfies some condition
local function SelectFirst1D<T>(Array: {T}, Condition: (T, number) -> boolean): T?
    for Index = 1, #Array do
        local Value = Array[Index]

        if (Condition(Value, Index)) then
            return Value
        end
    end

    return nil
end

return SelectFirst1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f554</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="34">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SelectFirst1D.spec</string>
								<string name="ScriptGuid">{619B8E86-8721-4DC9-B613-C011BC3E45F4}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local SelectFirst1D = require(script.Parent.SelectFirst1D)

    describe("Array/SelectFirst1D", function()
        it("should select nothing on an empty array", function()
            expect(SelectFirst1D({}, function() end)).never.to.be.ok()
        end)

        it("should select the first item in an array for a return-true function", function()
            expect(SelectFirst1D({1}, function()
                return true
            end)).to.equal(1)
        end)

        it("should select the first item greater than some number", function()
            expect(SelectFirst1D({1, 2, 4, 8, 16, 32}, function(Value)
                return Value >= 8
            end)).to.equal(8)
        end)

        it("should select the first index greater than some number", function()
            expect(SelectFirst1D({1, 2, 4, 8, 16, 32}, function(_, Index)
                return Index >= 3
            end)).to.equal(4)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f555</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="35">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SelectLast1D</string>
								<string name="ScriptGuid">{59D73FE9-6CB7-4D94-B13A-D3CCF9379CD0}</string>
								<ProtectedString name="Source"><![CDATA[--- Selects the last item in an array which satisfies some condition
local function SelectLast1D<T>(Array: {T}, Condition: (T, number) -> boolean): T?
    for Index = #Array, 1, -1 do
        local Value = Array[Index]

        if (Condition(Value, Index)) then
            return Value
        end
    end

    return nil
end

return SelectLast1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f556</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="36">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SelectLast1D.spec</string>
								<string name="ScriptGuid">{B7865722-3B0B-4DDD-B57A-10576D61719F}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local SelectLast1D = require(script.Parent.SelectLast1D)

    describe("Array/SelectLast1D", function()
        it("should select nothing on an empty array", function()
            expect(SelectLast1D({}, function() end)).never.to.be.ok()
        end)

        it("should select the last item in an array for a return-true function", function()
            expect(SelectLast1D({1}, function()
                return true
            end)).to.equal(1)
        end)

        it("should select the last item greater than some number", function()
            expect(SelectLast1D({1, 2, 4, 8, 16, 32}, function(Value)
                return Value >= 8
            end)).to.equal(32)
        end)

        it("should select the last index greater than some number", function()
            expect(SelectLast1D({1, 2, 4, 8, 16, 32}, function(_, Index)
                return Index >= 3
            end)).to.equal(32)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f557</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="37">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Shuffle1D</string>
								<string name="ScriptGuid">{D514EC2D-5745-48AD-A98A-1770A3E9717E}</string>
								<ProtectedString name="Source"><![CDATA[local RandomGenerator = Random.new()

--- Scrambles an array with an optional random seed
local function Shuffle1D<T>(Array: {T}, Seed: number?): {T}
    local Generator = Seed and Random.new(Seed) or RandomGenerator

    local ArraySize = #Array
    local Result = table.clone(Array)

    for Index = 1, ArraySize do
        local Generated = Generator:NextInteger(1, ArraySize)
        Result[Index], Result[Generated] = Result[Generated], Result[Index]
    end

    return Result
end

return Shuffle1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f558</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="38">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Shuffle1D.spec</string>
								<string name="ScriptGuid">{FAAF7A5F-5EA1-443A-B62B-C58935CB3386}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Shuffle1D = require(script.Parent.Shuffle1D)

    describe("Array/Shuffle1D", function()
        it("should return an empty array given an empty array", function()
            local Result = Shuffle1D({})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return a one-item array given a one-item array", function()
            local Result = Shuffle1D({1})
            expect(Result[1]).to.equal(1)
        end)

        it("should shuffle items given a seed", function()
            local Original = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

            -- Two tests to ensure seed is locally deterministic
            local Result1 = Shuffle1D(Original, 100)
            local Result2 = Shuffle1D(Original, 100)

            local Sum0 = 0
            local Sum1 = 0
            local Sum2 = 0

            local Different1 = false
            local Different2 = false

            for Index = 1, #Result1 do
                Sum0 += Original[Index]
                Sum1 += Result1[Index]
                Sum2 += Result2[Index]

                Different1 = Different1 or Result1[Index] ~= Original[Index]
                Different2 = Different2 or Result2[Index] ~= Original[Index]
                expect(Result1[Index]).to.equal(Result2[Index])
            end

            expect(Sum0).to.equal(Sum1)
            expect(Sum1).to.equal(Sum2)
            expect(Different1).to.equal(true)
            expect(Different2).to.equal(true)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f559</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="39">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Sort1D</string>
								<string name="ScriptGuid">{8FC8E7AF-C946-488E-BCA5-FC61737E45FD}</string>
								<ProtectedString name="Source"><![CDATA[--- Copies & sorts an array according to some condition
local function Sort1D<T>(Array: {T}, Condition: (T, T) -> boolean): {T}
    local Result = table.clone(Array)
    table.sort(Result, Condition)
    return Result
end

return Sort1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f55a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="40">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Sort1D.spec</string>
								<string name="ScriptGuid">{5EFD482D-E72F-462D-B241-5F9DAC9C5487}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Sort1D = require(script.Parent.Sort1D)

    describe("Array/Sort1D", function()
        it("should return an empty array given an empty array", function()
            local Result = Sort1D({})
            expect(next(Result)).to.equal(nil)
        end)

        it("should return a one-item array given a one-item array", function()
            local Result = Sort1D({1})
            expect(Result[1]).to.equal(1)
        end)

        it("should sort ascending given an ascending function", function()
            local Result = Sort1D({4, 8, 1, 2}, function(Initial, Other)
                return Initial < Other
            end)

            expect(Result[1]).to.equal(1)
            expect(Result[2]).to.equal(2)
            expect(Result[3]).to.equal(4)
            expect(Result[4]).to.equal(8)
        end)

        it("should sort descending given an ascending function", function()
            local Result = Sort1D({4, 8, 1, 2}, function(Initial, Other)
                return Initial > Other
            end)

            expect(Result[1]).to.equal(8)
            expect(Result[2]).to.equal(4)
            expect(Result[3]).to.equal(2)
            expect(Result[4]).to.equal(1)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f55b</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="41">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Map</string>
							<string name="ScriptGuid">{01D6DC55-EBDD-4DDB-8BC1-34F8CE0B54BA}</string>
							<ProtectedString name="Source"><![CDATA[return {
    MergeDeep = require(script:WaitForChild("MergeDeep"));
    Filter1D = require(script:WaitForChild("Filter1D"));
    Values1D = require(script:WaitForChild("Values1D"));
    Merge1D = require(script:WaitForChild("Merge1D"));
    Keys1D = require(script:WaitForChild("Keys1D"));
    Map1D = require(script:WaitForChild("Map1D"));
};]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f55c</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="42">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CreateNonOverwritingPatchDeep</string>
								<string name="ScriptGuid">{2C95A8B9-B182-4C5E-A9C4-C64018C0F466}</string>
								<ProtectedString name="Source"><![CDATA[--- Creates a "patch template" into another object recursively.
--- This allows us to apply an additional merge to add new fields to values which were not originally nil.
--- Good use case: want to merge in new default fields to a player's data structure without overwriting existing fields.
--- @todo Return nil if result is empty & wrap top level with another function? That way we trim recursive merge work for the resulting empty tables, which will be the common use case.
local TYPE_TABLE = "table"

local function CreateNonOverwritingPatchDeep(Previous, Template)
    local Result = {}

    for Key, Value in Template do
        local ExistingValue = Previous[Key]

        if (type(Value) == TYPE_TABLE and type(ExistingValue) == TYPE_TABLE) then
            Result[Key] = CreateNonOverwritingPatchDeep(ExistingValue or {}, Value)
            continue
        end

        if (ExistingValue ~= nil) then
            continue
        end

        Result[Key] = Value
    end

    return Result
end

return CreateNonOverwritingPatchDeep]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f55d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="43">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CreateNonOverwritingPatchDeep.spec</string>
								<string name="ScriptGuid">{8AFFD945-14FB-4F93-8CA5-B636BFC71075}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local CreateNonOverwritingPatchDeep = require(script.Parent.CreateNonOverwritingPatchDeep)

    describe("Map/CreateNonOverwritingPatchDeep", function()
        it("should return a blank table for no data", function()
            expect(next(CreateNonOverwritingPatchDeep({}, {}))).never.to.be.ok()
        end)

        it("should apply all new items in a flat table", function()
            local Result = CreateNonOverwritingPatchDeep({}, {
                X = 1;
                Y = 2;
                Z = 3;
            })

            expect(Result.X).to.equal(1)
            expect(Result.Y).to.equal(2)
            expect(Result.Z).to.equal(3)

            local Count = 0

            for _ in Result do
                Count += 1
            end

            expect(Count).to.equal(3)
        end)

        it("should not overwrite existing items in a flat table but apply new", function()
            local Result = CreateNonOverwritingPatchDeep({
                X = 20;
            }, {
                X = 1;
                Y = 2;
                Z = 3;
            })

            expect(Result.Y).to.equal(2)
            expect(Result.Z).to.equal(3)

            local Count = 0

            for _ in Result do
                Count += 1
            end

            expect(Count).to.equal(2)
        end)

        it("should apply all new items in a nested table", function()
            local Result = CreateNonOverwritingPatchDeep({}, {
                X = {
                    Y = {
                        Z = 1;
                    };
                };
            })

            expect(Result.X.Y.Z).to.equal(1)
        end)

        it("should not overwrite existing items in a nested table but apply new", function()
            local Result = CreateNonOverwritingPatchDeep({
                X = {
                    Y = {
                        Z = 20;
                    };
                };
            }, {
                X = {
                    Y = {
                        Z = 1;
                        H = 200;
                    };
                };
            })

            expect(Result.X.Y.Z).to.equal(nil)
            expect(Result.X.Y.H).to.equal(200)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f55e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="44">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Filter1D</string>
								<string name="ScriptGuid">{5538C9F0-89C4-4597-BE97-545D657CC4EE}</string>
								<ProtectedString name="Source"><![CDATA[--- Filters a table for all items which satisfy some condition
local function Filter1D<K, V>(Structure: {[K]: V}, Condition: (V, K) -> boolean): {[K]: V}
    local Result = {}

    for Key, Value in Structure do
        if (Condition(Value, Key)) then
            Result[Key] = Value
        end
    end

    return Result
end

return Filter1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f55f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="45">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Filter1D.spec</string>
								<string name="ScriptGuid">{9938CC99-CF1E-49B5-B5F0-AB167923694F}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Filter1D = require(script.Parent.Filter1D)

    describe("Map/Filter1D", function()
        it("should return a blank table for no data", function()
            local Results = Filter1D({}, function()
                return true
            end)

            expect(next(Results)).never.to.be.ok()
        end)

        it("should return all items for true condition", function()
            local Results = Filter1D({A = 1, B = 2, C =3}, function()
                return true
            end)

            expect(Results.A).to.equal(1)
            expect(Results.B).to.equal(2)
            expect(Results.C).to.equal(3)
        end)

        it("should return all items greater than 3", function()
            local Results = Filter1D({A = 2, B = 4, C =8}, function(Value)
                return Value > 3
            end)

            expect(Results.A).never.to.be.ok()
            expect(Results.B).to.equal(4)
            expect(Results.C).to.equal(8)
        end)

        it("should pass the keys", function()
            local Results = Filter1D({A = 2, B = 4, C =8}, function(_, Key)
                return Key == "A" or Key == "B"
            end)

            expect(Results.A).to.equal(2)
            expect(Results.B).to.equal(4)
            expect(Results.C).never.to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f560</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="46">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Keys1D</string>
								<string name="ScriptGuid">{51606369-16EA-4145-853B-519E9D1B1004}</string>
								<ProtectedString name="Source"><![CDATA[--- Obtains the keys from a table
local function Keys1D<K>(Structure: {[K]: any}): {K}
    local Result = {}
    local Index = 1

    for Key in Structure do
        Result[Index] = Key
        Index += 1
    end

    return Result
end

return Keys1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f561</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="47">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Keys1D.spec</string>
								<string name="ScriptGuid">{F864B1BC-E3AE-4DBB-AFAA-C18D5C6EBC96}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Keys1D = require(script.Parent.Keys1D)

    describe("Map/Keys1D", function()
        it("should return a blank table given a blank table", function()
            local Result = Keys1D({})
            expect(Result).to.be.ok()
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return one key given a one key table", function()
            local Result = Keys1D({A = 1000})
            expect(table.find(Result, "A")).to.be.ok()
        end)

        it("should return multiple keys given a multiple key table", function()
            local Result = Keys1D({A = 1000, B = 2000, C = true})
            expect(table.find(Result, "A")).to.be.ok()
            expect(table.find(Result, "B")).to.be.ok()
            expect(table.find(Result, "C")).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f562</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="48">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Map1D</string>
								<string name="ScriptGuid">{AC15A704-A87D-4F29-9F45-03FD040E5D6A}</string>
								<ProtectedString name="Source"><![CDATA[--- Puts each key-value pair in a table through a transformation function, mapping the outputs into a new table
local function Map1D<K, V, KT, VT>(Structure: {[K]: V}, Operation: (V, K) -> (VT?, KT?)): {[KT | K]: VT}
    local Result = {}

    for Key, Value in Structure do
        local NewValue, NewKey = Operation(Value, Key)
        Result[NewKey or Key] = NewValue
    end

    return Result
end

return Map1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f563</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="49">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Map1D.spec</string>
								<string name="ScriptGuid">{515493EF-8A74-4518-94C1-F51AD8B88D54}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Map1D = require(script.Parent.Map1D)

    describe("Map/Map1D", function()
        it("should return a blank array if passed in a blank array", function()
            local Result = Map1D({}, function(Value, Key)
                return Key, Value
            end)

            expect(next(Result)).to.equal(nil)
        end)

        it("should return all items given a return-same-value function", function()
            local Result = Map1D({A = 1, B = 2}, function(Value)
                return Value
            end)

            expect(Result.A).to.equal(1)
            expect(Result.B).to.equal(2)
        end)

        it("should pass in keys and allow for custom keys", function()
            local Result = Map1D({A = 1, B = 2}, function(Value, Key)
                return Value, Key:lower()
            end)

            expect(Result.a).to.equal(1)
            expect(Result.b).to.equal(2)
            expect(Result.A).never.to.be.ok()
            expect(Result.B).never.to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f564</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="50">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Merge1D</string>
								<string name="ScriptGuid">{A3CAD0C1-4E1C-425D-9D90-E185DAEA50F0}</string>
								<ProtectedString name="Source"><![CDATA[--- Merges various tables together, into a union data type.
local function Merge1D(...)
    local Result = {}

    for Index = 1, select("#", ...) do
        for Key, Value in select(Index, ...) do
            Result[Key] = Value
        end
    end

    return Result
end

return Merge1D :: <K0, V0, K1, V1>({[K0]: V0}, {[K1]: V1}, ...any) -> ({[K0 | K1]: {V0 | V1}})]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f565</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="51">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Merge1D.spec</string>
								<string name="ScriptGuid">{E647FD25-020D-4E74-BB46-E79C321B0E77}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Merge1D = require(script.Parent.Merge1D)

    describe("Map/Merge1D", function()
        it("should return a blank table for no inputs", function()
            local Result = Merge1D()
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return a blank table for one blank table input", function()
            local Result = Merge1D({})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return a blank table for multiple blank table inputs", function()
            local Result = Merge1D({}, {}, {}, {})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should merge two tables", function()
            local Result = Merge1D({A = 1, B = 2}, {C = 3})
            expect(Result.A).to.equal(1)
            expect(Result.B).to.equal(2)
            expect(Result.C).to.equal(3)
        end)

        it("should overwrite former tables", function()
            local Result = Merge1D({A = 1, B = 2}, {B = 3}, {B = 4})
            expect(Result.A).to.equal(1)
            expect(Result.B).to.equal(4)
        end)

        it("should merge several tables", function()
            local Result = Merge1D({A = 1, B = 2}, {C = 3}, {D = 4})
            expect(Result.A).to.equal(1)
            expect(Result.B).to.equal(2)
            expect(Result.C).to.equal(3)
            expect(Result.D).to.equal(4)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f566</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="52">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MergeDeep</string>
								<string name="ScriptGuid">{ADB42539-1FF2-4DA3-8889-B3F387FFD0D6}</string>
								<ProtectedString name="Source"><![CDATA[local TYPE_TABLE = "table"

--- Creates a new data structure, representing the recursive merge of one table into another. Ensures structural sharing.
local function MergeDeep(Structure, Into)
    local Result = {}

    -- Copy top level
    for Key, Value in Into do
        Result[Key] = Value
    end

    -- Structure overwrites
    for Key, Value in Structure do
        if (type(Value) ~= TYPE_TABLE) then
            Result[Key] = Value
            continue
        end

        local OtherValue = Into[Key]
        local IntoTarget = (type(OtherValue) == TYPE_TABLE and OtherValue or {})
        Result[Key] = MergeDeep(Value, IntoTarget)
    end

    return Result
end

return MergeDeep]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f567</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="53">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Values1D</string>
								<string name="ScriptGuid">{96367B6B-28FA-40DA-BE28-2749C8F228B4}</string>
								<ProtectedString name="Source"><![CDATA[--- Obtains the values from a table
local function Values1D<T>(Structure: {[any]: T}): T
    local Result = {}
    local Index = 1

    for _, Value in Structure do
        Result[Index] = Value
        Index += 1
    end

    return Result
end

return Values1D]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f568</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="54">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Values1D.spec</string>
								<string name="ScriptGuid">{E7E9805D-3019-4FD0-92A0-B99FED3B9632}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Values1D = require(script.Parent.Values1D)

    describe("Map/Values1D", function()
        it("should return a blank table given a blank table", function()
            local Result = Values1D({})
            expect(Result).to.be.ok()
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return one value given a one value table", function()
            local Result = Values1D({A = 1000})
            expect(table.find(Result, 1000)).to.be.ok()
        end)

        it("should return multiple values given a multiple value table", function()
            local Result = Values1D({A = 1000, B = 2000, C = true})
            expect(table.find(Result, 1000)).to.be.ok()
            expect(table.find(Result, 2000)).to.be.ok()
            expect(table.find(Result, true)).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f569</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="55">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Set</string>
							<string name="ScriptGuid">{70AC8C0F-3F26-454C-A81F-3F12C7A3BD59}</string>
							<ProtectedString name="Source"><![CDATA[return {
    FromValues = require(script:WaitForChild("FromValues"));
    FromKeys = require(script:WaitForChild("FromKeys"));

    Intersection = require(script:WaitForChild("Intersection"));
    Negation = require(script:WaitForChild("Negation"));
    Union = require(script:WaitForChild("Union"));
    Outer = require(script:WaitForChild("Outer"));
};]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f56a</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="56">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Equals</string>
								<string name="ScriptGuid">{CD49C657-C371-4F09-8B6B-F02E91EDD496}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function Equals<T>(Set1: Set<T>, Set2: Set<T>): boolean
    for Key in Set1 do
        if (not Set2[Key]) then
            return false
        end
    end

    for Key in Set2 do
        if (not Set1[Key]) then
            return false
        end
    end

    return true
end

return Equals]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f56b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="57">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Equals.spec</string>
								<string name="ScriptGuid">{B14F94FF-88EE-4F78-83B5-BB3FB66F1880}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local FromValues = require(script.Parent.FromValues)
    local Equals = require(script.Parent.Equals)

    describe("Set/Equals", function()
        it("should return true for two empty sets", function()
            expect(Equals(FromValues({}), FromValues({}))).to.equal(true)
        end)

        it("should return false for two sets with different values", function()
            expect(Equals(FromValues({1, 2, 3}), FromValues({4, 5, 6}))).to.equal(false)
        end)

        it("should return true for two sets with the same values", function()
            expect(Equals(FromValues({1, 2, 3}), FromValues({1, 2, 3}))).to.equal(true)
            expect(Equals(FromValues({1, 2, 3}), FromValues({3, 2, 1}))).to.equal(true)
        end)

        it("should return false for an intersection which is not equal to A or B", function()
            expect(Equals(FromValues({1, 2, 3}), FromValues({2, 3, 4}))).to.equal(false)
            expect(Equals(FromValues({1, 2, 3}), FromValues({1, 2, 4}))).to.equal(false)
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f56c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="58">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FromKeys</string>
								<string name="ScriptGuid">{CB243AF4-61EB-464E-821D-23A0435EA674}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function FromKeys<T>(KeysTable: {[T]: any}): Set<T>
    local Result = {}

    for Key in KeysTable do
        Result[Key] = true
    end

    return Result
end

return FromKeys]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f56d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="59">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FromKeys.spec</string>
								<string name="ScriptGuid">{F61CC998-2667-43A9-A4E7-B9D6DC92F4C4}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local FromKeys = require(script.Parent.FromKeys)

    describe("Set/FromKeys", function()
        it("should return an empty table given an empty table", function()
            local Result = FromKeys({})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return correctly for one item", function()
            local Result = FromKeys({A = 1234})
            expect(Result.A).to.be.ok()
        end)

        it("should return correctly for multiple items", function()
            local Result = FromKeys({A = 1, B = 2, C = 3})
            expect(Result.A).to.be.ok()
            expect(Result.B).to.be.ok()
            expect(Result.C).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f56e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="60">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FromValues</string>
								<string name="ScriptGuid">{68F92B4A-4294-4030-970A-5E160E2FD192}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function FromValues<T>(ValuesTable: {[any]: T}): Set<T>
    local Result = {}

    for _, Value in ValuesTable do
        Result[Value] = true
    end

    return Result
end

return FromValues]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f56f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="61">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FromValues.spec</string>
								<string name="ScriptGuid">{B4D08658-A0AA-4A79-A099-874351207B22}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local FromValues = require(script.Parent.FromValues)

    describe("Set/FromValues", function()
        it("should return an empty table given an empty table", function()
            local Result = FromValues({})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return correctly for one item", function()
            local Result = FromValues({A = "1234"})
            expect(Result["1234"]).to.be.ok()
        end)

        it("should return correctly for multiple items", function()
            local Result = FromValues({A = "1", B = "2", C = "3"})
            expect(Result["1"]).to.be.ok()
            expect(Result["2"]).to.be.ok()
            expect(Result["3"]).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f570</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="62">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Intersection</string>
								<string name="ScriptGuid">{653FF119-5670-4B81-9F8F-477ED8B4B70E}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function Intersection<T>(Set1: Set<T>, Set2: Set<T>): Set<T>
    local Result = {}

    for Key in Set1 do
        if (Set2[Key] and Set1[Key]) then
            Result[Key] = true
        end
    end

    return Result
end

return Intersection]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f571</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="63">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Intersection.spec</string>
								<string name="ScriptGuid">{09051716-40ED-4CE5-810D-96B69C6E638E}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Intersection = require(script.Parent.Intersection)
    local FromValues = require(script.Parent.FromValues)

    describe("Set/Intersection", function()
        it("should find no intersection with two empty sets", function()
            local Result = Intersection({}, {})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should find an intersection between one common element", function()
            local Result = Intersection(FromValues( {"A", "B"} ), FromValues( {"A", "C"} ))
            expect(Result.A).to.be.ok()
            expect(Result.B).never.to.be.ok()
            expect(Result.C).never.to.be.ok()
        end)

        it("should find multiple intersecting elements", function()
            local Result = Intersection(FromValues( {"A", "B", "X"} ), FromValues( {"A", "B", "Y"} ))
            expect(Result.A).to.be.ok()
            expect(Result.B).to.be.ok()
            expect(Result.X).never.to.be.ok()
            expect(Result.Y).never.to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f572</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="64">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Negation</string>
								<string name="ScriptGuid">{9D7D62B2-C59A-41E1-BC5A-05710A0BC9F3}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function Negation<T>(Set1: Set<T>, Set2: Set<T>): Set<T>
    local Result = {}

    for Key in Set1 do
        if (Set2[Key] == nil) then
            Result[Key] = true
        end
    end

    return Result
end

return Negation]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f573</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="65">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Negation.spec</string>
								<string name="ScriptGuid">{EA04D3BF-F635-4493-B996-CF85341EEB18}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Negation = require(script.Parent.Negation)
    local FromValues = require(script.Parent.FromValues)

    describe("Set/Negation", function()
        it("should return a blank set from two blank set inputs", function()
            local Result = Negation(FromValues( {} ), FromValues( {} ))
            expect(next(Result)).never.to.be.ok()
        end)

        it("should remove the latter from the former with one item", function()
            local Result = Negation(FromValues( {1} ), FromValues( {1} ))
            expect(next(Result)).never.to.be.ok()
        end)

        it("should remove the latter from the former with multiple items", function()
            local Result = Negation(FromValues( {1, 4, 8} ), FromValues( {4, 8, 1} ))
            expect(next(Result)).never.to.be.ok()
        end)

        it("should remove the latter from the former with multiple items and leave non-negated present", function()
            local Result = Negation(FromValues( {1, 4, 8, 2} ), FromValues( {4, 8, 1} ))
            expect(Result[2]).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f574</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="66">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Outer</string>
								<string name="ScriptGuid">{06F936E1-929E-405C-A991-AAC22F0FD369}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function Outer<T>(Set1: Set<T>, Set2: Set<T>): Set<T>
    local Result = {}

    for Key in Set1 do
        if (not (Set2[Key] and Set1[Key])) then
            Result[Key] = true
        end
    end

    for Key in Set2 do
        if (not (Set2[Key] and Set1[Key])) then
            Result[Key] = true
        end
    end

    return Result
end

return Outer]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f575</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="67">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Outer.spec</string>
								<string name="ScriptGuid">{5C2524CE-F0CA-4743-9689-9C37312C8E35}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Outer = require(script.Parent.Outer)
    local FromValues = require(script.Parent.FromValues)

    describe("Set/Outer", function()
        it("should return a blank set from two blank set inputs", function()
            local Result = Outer(FromValues( {} ), FromValues( {} ))
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return the left items given a left set and a blank right set", function()
            local Result = Outer(FromValues( {1, 2, 3} ), FromValues( {} ))
            expect(Result[1]).to.be.ok()
            expect(Result[2]).to.be.ok()
            expect(Result[3]).to.be.ok()
        end)

        it("should return the right items given a blank left set and a right set", function()
            local Result = Outer(FromValues( {} ), FromValues( {1, 2, 3} ))
            expect(Result[1]).to.be.ok()
            expect(Result[2]).to.be.ok()
            expect(Result[3]).to.be.ok()
        end)

        it("should return the outer items without the intersections", function()
            local Result = Outer(FromValues( {1, 2, 3, 4} ), FromValues( {3, 4, 5, 6} ))
            expect(Result[1]).to.be.ok()
            expect(Result[2]).to.be.ok()
            expect(Result[3]).never.to.be.ok()
            expect(Result[4]).never.to.be.ok()
            expect(Result[5]).to.be.ok()
            expect(Result[6]).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f576</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="68">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Union</string>
								<string name="ScriptGuid">{C99B1CCF-4810-4E71-A422-003708628F83}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local SetType = require(script.Parent:WaitForChild("_SetType"))
type Set<T> = SetType.Set<T>

local function Union<T>(Set1: Set<T>, Set2: Set<T>): Set<T>
    if (next(Set1) == nil) then
        return Set2
    end

    if (next(Set2) == nil) then
        return Set1
    end

    local Result = {}

    for Key in Set1 do
        Result[Key] = true
    end

    for Key in Set2 do
        Result[Key] = true
    end

    return Result
end

return Union]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f577</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="69">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Union.spec</string>
								<string name="ScriptGuid">{81C4F741-5A43-4E98-AF95-F21A7A8F5315}</string>
								<ProtectedString name="Source"><![CDATA[return function()
    local Union = require(script.Parent.Union)
    local FromValues = require(script.Parent.FromValues)

    describe("Set/Union", function()
        it("should combine two empty sets into an empty set", function()
            local Result = Union({}, {})
            expect(next(Result)).never.to.be.ok()
        end)

        it("should return A for A union B where B is empty" , function()
            local A = FromValues({"x", "y", "z"})
            local B = FromValues({})

            expect(Union(A, B)).to.equal(A)
        end)

        it("should return B for A union B where A is empty" , function()
            local A = FromValues({})
            local B = FromValues({"x", "y", "z"})

            expect(Union(A, B)).to.equal(B)
        end)

        it("should return an equal set for two equivalent sets", function()
            local A = FromValues({"x", "y", "z"})
            local B = FromValues({"x", "y", "z"})

            for Key in A do
                expect(B[Key]).to.equal(A[Key])
            end

            for Key in B do
                expect(A[Key]).to.equal(B[Key])
            end
        end)

        it("should return a union of two sets", function()
            local A = FromValues({"X", "Y", "Z"})
            local B = FromValues({"P", "Q", "R"})
            local Merge = Union(A, B)

            expect(Merge.X).to.be.ok()
            expect(Merge.Y).to.be.ok()
            expect(Merge.Z).to.be.ok()
            expect(Merge.P).to.be.ok()
            expect(Merge.Q).to.be.ok()
            expect(Merge.R).to.be.ok()
        end)
    end)
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f578</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="70">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_SetType</string>
								<string name="ScriptGuid">{5960CCDE-24B9-46C0-8652-3C28138DEBEB}</string>
								<ProtectedString name="Source"><![CDATA[export type Set<T> = {[T]: boolean}
return true]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f579</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="71">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tpc9000_typeguard@2.3.0</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f57a</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="72">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">typeguard</string>
						<string name="ScriptGuid">{C756E90D-FC28-4EF2-AF23-F7F98050D90B}</string>
						<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
-- @TODO This script really needs splitting up into sub-modules

local CHECK_TAG_SUFFIX = ".Check"
local EMPTY_STRING = ""

local TYPE_SOMETHING = "something"
local TYPE_ENUM_ITEM = "EnumItem"
local TYPE_INSTANCE = "Instance"
local TYPE_ENUM = "Enum"

local TYPE_FUNCTION = "function"
local TYPE_USERDATA = "userdata"
local TYPE_BOOLEAN = "boolean"
local TYPE_THREAD = "thread"
local TYPE_NUMBER = "number"
local TYPE_STRING = "string"
local TYPE_TABLE = "table"
local TYPE_NIL = "nil"

local INVALID_ARGUMENT = "Invalid argument #%s (%s expected, got %s)"
local INVALID_TYPE = "Expected %s, got %s"

-- Cache up here so these arrays aren't re-created with every function call for the simple checking system
local EXPECT_ENUM_OR_ENUM_ITEM_OR_FUNCTION = {TYPE_ENUM, TYPE_ENUM_ITEM, TYPE_FUNCTION}
local EXPECT_INSTANCE_OR_FUNCTION = {TYPE_INSTANCE, TYPE_FUNCTION}
local EXPECT_BOOLEAN_OR_FUNCTION = {TYPE_BOOLEAN, TYPE_FUNCTION}
local EXPECT_STRING_OR_FUNCTION = {TYPE_STRING, TYPE_FUNCTION}
local EXPECT_NUMBER_OR_FUNCTION = {TYPE_NUMBER, TYPE_FUNCTION}
local EXPECT_TABLE_OR_FUNCTION = {TYPE_TABLE, TYPE_FUNCTION}
local EXPECT_SOMETHING = {TYPE_SOMETHING}
local EXPECT_FUNCTION = {TYPE_FUNCTION}
local EXPECT_STRING = {TYPE_STRING}
local EXPECT_TABLE = {TYPE_TABLE}

--- This is only really for type checking internally for data passed to constraints and util functions
local function ExpectType<T>(PassedArg: T, ExpectedTypes: {string}, ArgKey: number | string)
    local GotType = typeof(PassedArg)
    local Satisfied = false

    for _, PossibleType in ExpectedTypes do
        if (GotType == PossibleType) then
            Satisfied = true
            break
        end
    end

    assert(Satisfied, INVALID_ARGUMENT:format(tostring(ArgKey), table.concat(ExpectedTypes, " or "), GotType))
end

local function CreateStandardInitial(ExpectedTypeName: string): ((...any) -> (boolean, string))
    return function(_, Item)
        local ItemType = typeof(Item)

        if (ItemType == ExpectedTypeName) then
            return true, EMPTY_STRING
        end

        return false, INVALID_TYPE:format(ExpectedTypeName, ItemType)
    end
end

local function ConcatWithToString<T>(Array: {T}, Separator: string): string
    local Result = EMPTY_STRING

    for _, Value in Array do
        Result ..= tostring(Value) .. Separator
    end

    return (#Array > 0 and Result:sub(1, #Result - #Separator) or Result)
end

local STRUCTURE_TO_FLAT_STRING_MT = {
    __tostring = function(self)
        local Pairings = {}

        for Key, Value in self do
            table.insert(Pairings, tostring(Key) .. " = " .. tostring(Value))
        end

        return "{" .. ConcatWithToString(Pairings, ", ") .. "}"
    end;
}

local WEAK_KEY_MT = {__mode = "k"}

-- Standard re-usable functions throughout all TypeCheckers
    local function IsAKeyIn(self, Store)
        ExpectType(Store, EXPECT_TABLE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAKeyIn", function(_, Key, Store)
            if (Store[Key] == nil) then
                return false, "Key " .. tostring(Key) .. " was not found in table: " .. tostring(Store)
            end

            return true, EMPTY_STRING
        end, Store)
    end

    local function IsAValueIn(self, Store)
        ExpectType(Store, EXPECT_TABLE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAValueIn", function(_, TargetValue, Store)
            for _, Value in Store do
                if (Value == TargetValue) then
                    return true, EMPTY_STRING
                end
            end

            return false, "Value " .. tostring(TargetValue) .. " was not found in table: " .. tostring(Store)
        end, Store)
    end

    local function Equals(self, ExpectedValue)
        return self:_AddConstraint("Equals", function(_, Value, ExpectedValue)
            if (Value == ExpectedValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " does not equal " .. tostring(ExpectedValue)
        end, ExpectedValue)
    end

    local function GreaterThan(self, GTValue)
        return self:_AddConstraint("GreaterThan", function(_, Value, GTValue)
            if (Value > GTValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not greater than " .. tostring(GTValue)
        end, GTValue)
    end

    local function LessThan(self, LTValue)
        return self:_AddConstraint("LessThan", function(_, Value, LTValue)
            if (Value < LTValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not less than " .. tostring(LTValue)
        end, LTValue)
    end

    local function GreaterThanOrEqualTo(self, GTEValue)
        return self:_AddConstraint("GreaterThanOrEqualTo", function(_, Value, GTEValue)
            if (Value >= GTEValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not greater than or equal to " .. tostring(GTEValue)
        end, GTEValue)
    end

    local function LessThanOrEqualTo(self, LTEValue)
        return self:_AddConstraint("LessThanOrEqualTo", function(_, Value, LTEValue)
            if (Value <= LTEValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not less than or equal to " .. tostring(LTEValue)
        end, LTEValue)
    end




type SelfReturn<T, P...> = ((T, P...) -> T)

type TypeCheckerConstructor<T, P...> = ((P...) -> T)

type TypeChecker<T> = {
    Or: SelfReturn<T, TypeChecker<any> | () -> TypeChecker<any>>;
    And: SelfReturn<T, TypeChecker<any>>;
    Alias: SelfReturn<T, string>;
    Negate: SelfReturn<T>;
    Cached: SelfReturn<T>;
    Optional: SelfReturn<T>;
    WithContext: SelfReturn<T, any?>;
    FailMessage: SelfReturn<T, string>;

    WrapCheck: (T) -> ((any) -> (boolean, string));
    WrapAssert: (T) -> ((any) -> ());
    Check: (T, any) -> (string, boolean);
    Assert: (T, any) -> ();

    -- Standard constraints
    Equals: SelfReturn<T, any>;
    equals: SelfReturn<T, any>;

    IsAValueIn: SelfReturn<T, any>;
    isAValueIn: SelfReturn<T, any>;

    IsAKeyIn: SelfReturn<T, any>;
    isAKeyIn: SelfReturn<T, any>;

    GreaterThan: SelfReturn<T, number | (any?) -> number>;
    greaterThan: SelfReturn<T, number | (any?) -> number>;

    LessThan: SelfReturn<T, number | (any?) -> number>;
    lessThan: SelfReturn<T, number | (any?) -> number>;

    GreaterThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
    greaterThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;

    LessThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
    lessThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
};

local RootContext -- Faster & easier just using one high scope variable which all TypeCheckers can access during checking time, than propogating the context downwards
local TypeGuard = {}

--- Creates a template TypeChecker object that can be used to extend behaviors via constraints
function TypeGuard.Template(Name: string)
    ExpectType(Name, EXPECT_STRING, 1)

    local TemplateClass = {}
    TemplateClass.__index = TemplateClass
    TemplateClass._InitialConstraints = nil
    TemplateClass._InitialConstraint = nil
    TemplateClass.IsTemplate = true
    TemplateClass.Type = Name

    function TemplateClass.new(...)
        local self = {
            _Tags = {};
            _Disjunction = {};
            _Conjunction = {};
            _ActiveConstraints = {};

            _LastConstraint = EMPTY_STRING;

            _Cache = nil;
            _Context = nil;
            _FailMessage = nil;
        }

        setmetatable(self, TemplateClass)

        local NumArgs = select("#", ...)

        -- Support for a single constraint passed as the constructor, with an arbitrary number of args
        local InitialConstraint = self._InitialConstraint

        if (InitialConstraint and NumArgs > 0) then
            return InitialConstraint(self, ...)
        end

        -- Multiple constraints support (but only ONE arg per constraint is supported currently)
        local InitialConstraints = TemplateClass._InitialConstraints

        if (InitialConstraints and NumArgs > 0) then
            for Index = 1, NumArgs do
                self = InitialConstraints[Index](self, select(Index, ...))
            end

            return self
        end

        return self
    end

    function TemplateClass:Copy()
        local New = TemplateClass.new()

        -- Copy tags
        for Key, Value in self._Tags do
            New._Tags[Key] = Value
        end

        -- Copy OR
        for Index, Disjunction in self._Disjunction do
            New._Disjunction[Index] = Disjunction
        end

        -- Copy AND
        for Index, Conjunction in self._Conjunction do
            New._Conjunction[Index] = Conjunction
        end

        -- Copy constraints
        for ConstraintName, Constraint in self._ActiveConstraints do
            New._ActiveConstraints[ConstraintName] = Constraint
        end

        New._Context = self._Context
        New._FailMessage = self._FailMessage
        New._LastConstraint = self._LastConstraint

        return New
    end
    TemplateClass.copy = TemplateClass.Copy

    --- Wraps & negates the last constraint (i.e. if it originally would fail, it passes, and vice versa)
    function TemplateClass:Negate()
        self = self:Copy()

        local LastConstraint = self._LastConstraint
        assert(LastConstraint ~= EMPTY_STRING, "Nothing to negate! (No constraints active)")
        self._ActiveConstraints[LastConstraint][4] = true

        return self
    end
    TemplateClass.negate = TemplateClass.Negate

    --- Sets a custom fail message to return if Check() fails
    function TemplateClass:FailMessage(Message: string)
        ExpectType(Message, EXPECT_STRING, 1)

        self = self:Copy()
        self._FailMessage = Message
        return self
    end
    TemplateClass.failMessage = TemplateClass.FailMessage

    function TemplateClass:Cached()
        return self:_AddTag("Cached")
    end
    TemplateClass.cached = TemplateClass.Cached

    function TemplateClass:_AddConstraint(ConstraintName, Constraint, ...)
        ExpectType(ConstraintName, EXPECT_STRING, 1)
        ExpectType(Constraint, EXPECT_FUNCTION, 2)

        self = self:Copy()
        self._LastConstraint = ConstraintName

        local Args = {...}
        local HasFunctions = false

        for _, Value in Args do
            local ArgType = typeof(Value)

            if (ArgType == TYPE_FUNCTION) then
                HasFunctions = true
                continue
            end
        end

        local ActiveConstraints = self._ActiveConstraints
        assert(ActiveConstraints[ConstraintName] == nil, "Constraint already exists: " .. ConstraintName)
        ActiveConstraints[ConstraintName] = {Constraint, Args, HasFunctions, false}
        return self
    end

    --- Adds a tag (for internal purposes)
    function TemplateClass:_AddTag(TagName)
        ExpectType(TagName, EXPECT_STRING, 1)
        assert(self._Tags[TagName] == nil, "Tag already exists: " .. TagName)

        self = self:Copy()
        self._Tags[TagName] = true
        return self
    end

    function TemplateClass:_GetCache()
        local Cache = self._Cache

        if (not Cache) then
            Cache = setmetatable({}, WEAK_KEY_MT); -- Weak keys because we don't want to leak Instances or tables
            self._Cache = Cache
        end

        return Cache
    end

    --- Checks if the value is of the correct type
    function TemplateClass:_Check(Value)
        debug.profilebegin(Name .. CHECK_TAG_SUFFIX)

        local Tags = self._Tags
        local CacheTag = Tags.Cached
        local Cache

        if (CacheTag) then
            Cache = self:_GetCache()

            local CacheValue = Cache[Value]

            if (CacheValue) then
                local Success = CacheValue[1]
                local Result = CacheValue[2]
                debug.profileend()
                return Success, Result
            end
        end

        -- Handle "type x or type y or type z ..."
        -- We do this before checking constraints to check if any of the other conditions succeed
        local Disjunctions = self._Disjunction
        local DidTryDisjunction = (Disjunctions[1] ~= nil)

        for _, AlternateType in Disjunctions do
            if (typeof(AlternateType) == TYPE_FUNCTION) then
                AlternateType = AlternateType(self)
            end

            local Success, _ = AlternateType:_Check(Value, RootContext)

            if (Success) then
                if (CacheTag) then
                    Cache[Value] = {true, EMPTY_STRING}
                end

                debug.profileend()
                return true, EMPTY_STRING
            end
        end

        -- Handle "type x and type y and type z ..." - this is only really useful for objects and arrays
        for _, Conjunction in self._Conjunction do
            local Success, Message = Conjunction:_Check(Value, RootContext)

            if (not Success) then
                local Result = self._FailMessage or ("[Conjunction " .. tostring(Conjunction) .. "] " .. Message)

                if (CacheTag) then
                    Cache[Value] = {false, Result}
                end

                debug.profileend()
                return false, Result
            end
        end

        -- Optional allows the value to be nil, in which case it won't be checked and we can resolve
        if (Tags.Optional and Value == nil) then
            if (CacheTag) then
                Cache[Value] = {true, EMPTY_STRING}
            end

            debug.profileend()
            return true, EMPTY_STRING
        end

        -- Handle initial type check
        local Success, Message = self:_Initial(Value)

        if (not Success) then
            if (DidTryDisjunction) then
                local Result = self._FailMessage or ("Disjunctions failed on " .. tostring(self))

                if (CacheTag) then
                    Cache[Value] = {false, Result}
                end

                debug.profileend()
                return false, Result
            else
                Message = self._FailMessage or Message

                if (CacheTag) then
                    Cache[Value] = {false, Message}
                end

                debug.profileend()
                return false, Message
            end
        end

        -- Handle active constraints
        for ConstraintName, Constraint in self._ActiveConstraints do
            local Call = Constraint[1]
            local Args = Constraint[2]
            local HasFunctionalParams = Constraint[3]
            local ShouldNegate = Constraint[4]

            -- Functional params -> transform into values when type checking
            if (HasFunctionalParams) then
                Args = table.clone(Args)

                for Index, Arg in Args do
                    if (typeof(Arg) == TYPE_FUNCTION) then
                        Args[Index] = Arg(RootContext)
                    end
                end
            end

            -- Call the constraint to verify it is satisfied
            local SubSuccess, SubMessage = Call(self, Value, unpack(Args))

            if (ShouldNegate) then
                SubMessage = if (SubSuccess) then
                                "Constraint '" .. ConstraintName .. "' succeeded but was expected to fail on value " .. tostring(Value)
                                else
                                EMPTY_STRING

                SubSuccess = not SubSuccess
            end

            if (not SubSuccess) then
                if (DidTryDisjunction) then
                    local Result = self._FailMessage or ("Disjunctions failed on " .. tostring(self))

                    if (CacheTag) then
                        Cache[Value] = {false, Result}
                    end

                    debug.profileend()
                    return false, Result
                else
                    SubMessage = self._FailMessage or SubMessage

                    if (CacheTag) then
                        Cache[Value] = {false, SubMessage}
                    end

                    debug.profileend()
                    return false, SubMessage
                end
            end
        end

        if (CacheTag) then
            Cache[Value] = {true, EMPTY_STRING}
        end

        debug.profileend()
        return true, EMPTY_STRING
    end

    --- Calling this will only check the type of the passed value if that value is not nil, i.e. it's an optional value so nothing can be passed, but if it is not nothing then it will be checked
    function TemplateClass:Optional()
        return self:_AddTag("Optional")
    end
    TemplateClass.optional = TemplateClass.Optional

    --- Enqueues a new constraint to satisfy 'or' i.e. "check x or check y or check z or ..." must pass
    function TemplateClass:Or(OtherType)
        if (typeof(OtherType) ~= TYPE_FUNCTION) then
            TypeGuard._AssertIsTypeBase(OtherType, 1)
        end

        self = self:Copy()
        table.insert(self._Disjunction, OtherType)
        return self
    end
    TemplateClass["or"] = TemplateClass.Or

    --- Enqueues a new constraint to satisfy 'and' i.e. "check x and check y and check z and ..." must pass
    function TemplateClass:And(OtherType)
        TypeGuard._AssertIsTypeBase(OtherType, 1)

        self = self:Copy()
        table.insert(self._Conjunction, OtherType)
        return self
    end
    TemplateClass["and"] = TemplateClass.And

    --- Creates an Alias - useful for replacing large "Or" chains in big structures to identify where it is failing
    function TemplateClass:Alias(AliasName)
        ExpectType(AliasName, EXPECT_STRING, 1)

        self = self:Copy()
        self._Alias = AliasName
        return self
    end
    TemplateClass.alias = TemplateClass.Alias

    --- Passes down a "context" value to constraints with functional values
    --- We don't copy here because performance is important at the checking phase
    function TemplateClass:WithContext(Context)
        self._Context = Context
        return self
    end
    TemplateClass.withContext = TemplateClass.WithContext

    --- Wrap Check into its own callable function
    function TemplateClass:WrapCheck()
        return function(Value)
            return self:_Check(Value)
        end
    end
    TemplateClass.wrapCheck = TemplateClass.WrapCheck

    --- Wraps Assert into its own callable function
    function TemplateClass:WrapAssert()
        return function(Value)
            return self:Assert(Value)
        end
    end
    TemplateClass.wrapAssert = TemplateClass.WrapAssert

    --- Check (like above) except sets a universal context for the duration of the check
    function TemplateClass:Check(Value)
        RootContext = self._Context
        local Success, Result = self:_Check(Value)
        RootContext = nil
        return Success, Result
    end
    TemplateClass.check = TemplateClass.Check

    --- Throws an error if the check is unsatisfied
    function TemplateClass:Assert(Value)
        assert(self:Check(Value))
    end
    TemplateClass.assert = TemplateClass.Assert

    function TemplateClass:__tostring()
        -- User can create a unique alias to help simplify "where did it fail?"
        if (self._Alias) then
            return self._Alias
        end

        local Fields = {}

        -- Constraints list (including arg, possibly other type defs)
        if (next(self._ActiveConstraints) ~= nil) then
            local InnerConstraints = {}

            for ConstraintName, Constraint in self._ActiveConstraints do
                table.insert(InnerConstraints, ConstraintName .. "(" .. ConcatWithToString(Constraint[2], ", ") .. ")")
            end

            table.insert(Fields, "Constraints = {" .. ConcatWithToString(InnerConstraints, ", ") .. "}")
        end

        -- Alternatives field str
        if (#self._Disjunction > 0) then
            local Alternatives = {}

            for _, AlternateType in self._Disjunction do
                table.insert(Alternatives, tostring(AlternateType))
            end

            table.insert(Fields, "Or = {" .. ConcatWithToString(Alternatives, ", ") .. "}")
        end

        -- Union fields str
        if (#self._Conjunction > 0) then
            local Unions = {}

            for _, Union in self._Conjunction do
                table.insert(Unions, tostring(Union))
            end

            table.insert(Fields, "And = {" .. ConcatWithToString(Unions, ", ") .. "}")
        end

        -- Tags (e.g. Optional, Strict)
        if (next(self._Tags) ~= nil) then
            local Tags = {}

            for Tag in self._Tags do
                table.insert(Tags, Tag)
            end

            table.insert(Fields, "Tags = {" .. ConcatWithToString(Tags, ", ") .. "}")
        end

        if (self._Context) then
            table.insert(Fields, "Context = " .. tostring(self._Context))
        end

        return self.Type .. "(" .. ConcatWithToString(Fields, ", ") .. ")"
    end

    TemplateClass.Equals = Equals
    TemplateClass.equals = Equals

    TemplateClass.IsAValueIn = IsAValueIn
    TemplateClass.isAValueIn = IsAValueIn

    TemplateClass.IsAKeyIn = IsAKeyIn
    TemplateClass.isAKeyIn = IsAKeyIn

    TemplateClass.GreaterThan = GreaterThan
    TemplateClass.greaterThan = GreaterThan

    TemplateClass.LessThan = LessThan
    TemplateClass.lessThan = LessThan

    TemplateClass.GreaterThanOrEqualTo = GreaterThanOrEqualTo
    TemplateClass.greaterThanOrEqualTo = GreaterThanOrEqualTo

    TemplateClass.LessThanOrEqualTo = LessThanOrEqualTo
    TemplateClass.lessThanOrEqualTo = LessThanOrEqualTo

    return function(...)
        return TemplateClass.new(...)
    end, TemplateClass
end

--- Checks if an object contains the fields which define a type template from this module
function TypeGuard._AssertIsTypeBase(Subject: any, Position: number | string)
    ExpectType(Subject, EXPECT_TABLE, Position)

    assert(Subject.IsTemplate, "Subject is not a type template")
end

--- Cheap & easy way to create a type without any constraints, and just an initial check corresponding to Roblox's typeof
function TypeGuard.FromTypeName(TypeName: string)
    ExpectType(TypeName, EXPECT_STRING, 1)

    local CheckerFunction, CheckerClass = TypeGuard.Template(TypeName)
    CheckerClass._Initial = CreateStandardInitial(TypeName)

    type CustomTypeChecker = TypeChecker<CustomTypeChecker> & {}
    return CheckerFunction :: TypeCheckerConstructor<CustomTypeChecker>
end
TypeGuard.fromTypeName = TypeGuard.FromTypeName




do
    type NumberTypeChecker = TypeChecker<NumberTypeChecker> & {
        Integer: SelfReturn<NumberTypeChecker>;
        integer: SelfReturn<NumberTypeChecker>;

        Decimal: SelfReturn<NumberTypeChecker>;
        decimal: SelfReturn<NumberTypeChecker>;

        RangeInclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        rangeInclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;

        RangeExclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        rangeExclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;

        Positive: SelfReturn<NumberTypeChecker>;
        positive: SelfReturn<NumberTypeChecker>;

        Negative: SelfReturn<NumberTypeChecker>;
        negative: SelfReturn<NumberTypeChecker>;

        IsNaN: SelfReturn<NumberTypeChecker>;
        isNan: SelfReturn<NumberTypeChecker>;

        IsInfinite: SelfReturn<NumberTypeChecker>;
        isInfinite: SelfReturn<NumberTypeChecker>;

        IsClose: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        isClose: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
    };

    local Number: TypeCheckerConstructor<NumberTypeChecker, TypeChecker<any>?>, NumberClass = TypeGuard.Template("Number")
    NumberClass._Initial = CreateStandardInitial(TYPE_NUMBER)

    --- Checks if the value is whole
    function NumberClass:Integer()
        return self:_AddConstraint("Integer", function(_, Item)
            if (Item % 1 == 0) then
                return true, EMPTY_STRING
            end

            return false, "Expected integer form, got " .. tostring(Item)
        end)
    end
    NumberClass.integer = NumberClass.Integer

    --- Checks if the number is a decimal
    function NumberClass:Decimal()
        return self:_AddConstraint("Decimal", function(_, Item)
            if (Item % 1 ~= 0) then
                return true, EMPTY_STRING
            end

            return false, "Expected decimal form, got " .. tostring(Item)
        end)
    end
    NumberClass.decimal = NumberClass.Decimal

    --- Ensures a number is between or equal to a minimum and maxmimu value
    function NumberClass:RangeInclusive(Min, Max)
        ExpectType(Min, EXPECT_NUMBER_OR_FUNCTION, 1)
        ExpectType(Max, EXPECT_NUMBER_OR_FUNCTION, 2)

        return self:GreaterThanOrEqualTo(Min):LessThanOrEqualTo(Max)
    end
    NumberClass.rangeInclusive = NumberClass.RangeInclusive

    --- Ensures a number is between but not equal to a minimum and maximum value
    function NumberClass:RangeExclusive(Min, Max)
        return self:GreaterThan(Min):LessThan(Max)
    end
    NumberClass.rangeExclusive = NumberClass.RangeExclusive

    --- Checks the number is positive
    function NumberClass:Positive()
        return self:_AddConstraint("Positive", function(_, Item)
            if (Item < 0) then
                return false, "Expected positive number, got " .. tostring(Item)
            end

            return true, EMPTY_STRING
        end)
    end
    NumberClass.positive = NumberClass.Positive

    --- Checks the number is negative
    function NumberClass:Negative()
        return self:_AddConstraint("Negative", function(_, Item)
            if (Item >= 0) then
                return false, "Expected negative number, got " .. tostring(Item)
            end

            return true, EMPTY_STRING
        end)
    end
    NumberClass.negative = NumberClass.Negative

    --- Checks if the number is NaN
    function NumberClass:IsNaN()
        return self:_AddConstraint("IsNaN", function(_, Item)
            if (Item ~= Item) then
                return true, EMPTY_STRING
            end

            return false, "Expected NaN, got " .. tostring(Item)
        end)
    end
    NumberClass.isNaN = NumberClass.IsNaN

    --- Checks if the number is infinite
    function NumberClass:IsInfinite()
        return self:_AddConstraint("IsInfinite", function(_, Item)
            if (Item == math.huge or Item == -math.huge) then
                return true, EMPTY_STRING
            end

            return false, "Expected infinite, got " .. tostring(Item)
        end)
    end
    NumberClass.isInfinite = NumberClass.IsInfinite

    --- Checks if the number is close to another
    function NumberClass:IsClose(CloseTo, Tolerance)
        ExpectType(CloseTo, EXPECT_NUMBER_OR_FUNCTION, 1)
        Tolerance = Tolerance or 0.00001

        return self:_AddConstraint("IsClose", function(_, NumberValue, CloseTo, Tolerance)
            if (math.abs(NumberValue - CloseTo) < Tolerance) then
                return true, EMPTY_STRING
            end

            return false, "Expected " .. tostring(CloseTo) .. " +/- " .. tostring(Tolerance) .. ", got " .. tostring(NumberValue)
        end, CloseTo, Tolerance)
    end

    TypeGuard.Number = Number
    TypeGuard.number = Number
end




do
    type StringTypeChecker = TypeChecker<StringTypeChecker> & {
        MinLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;
        minLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;

        MaxLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;
        maxLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;

        Pattern: SelfReturn<StringTypeChecker, string | (any?) -> string>;
        pattern: SelfReturn<StringTypeChecker, string | (any?) -> string>;

        Contains: SelfReturn<StringTypeChecker, string | (any?) -> string>;
        contains: SelfReturn<StringTypeChecker, string | (any?) -> string>;
    };

    local String: TypeCheckerConstructor<StringTypeChecker, TypeChecker<any>?>, StringClass = TypeGuard.Template("String")
    StringClass._Initial = CreateStandardInitial(TYPE_STRING)

    --- Ensures a string is at least a certain length
    function StringClass:MinLength(MinLength)
        ExpectType(MinLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MinLength", function(_, Item, MinLength)
            if (#Item < MinLength) then
                return false, "Length must be at least " .. MinLength .. ", got " .. #Item
            end

            return true, EMPTY_STRING
        end, MinLength)
    end
    StringClass.minLength = StringClass.MinLength

    --- Ensures a string is at most a certain length
    function StringClass:MaxLength(MaxLength)
        ExpectType(MaxLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MaxLength", function(_, Item, MaxLength)
            if (#Item > MaxLength) then
                return false, "Length must be at most " .. MaxLength .. ", got " .. #Item
            end

            return true, EMPTY_STRING
        end, MaxLength)
    end
    StringClass.maxLength = StringClass.MaxLength

    --- Ensures a string matches a pattern
    function StringClass:Pattern(PatternString)
        ExpectType(PatternString, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("Pattern", function(_, Item, Pattern)
            if (string.match(Item, Pattern) ~= Item) then
                return false, "String does not match pattern " .. tostring(Pattern)
            end

            return true, EMPTY_STRING
        end, PatternString)
    end
    StringClass.pattern = StringClass.Pattern

    --- Ensures a string contains a certain substring
    function StringClass:Contains(SubstringValue)
        ExpectType(SubstringValue, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("Contains", function(_, Item, Substring)
            if (string.find(Item, Substring) == nil) then
                return false, "String does not contain substring " .. tostring(Substring)
            end

            return true, EMPTY_STRING
        end, SubstringValue)
    end

    TypeGuard.String = String
    TypeGuard.string = String
end




do
    local PREFIX_ARRAY = "Index "
    local PREFIX_PARAM = "Param #"
    local ERR_PREFIX = "[%s%d] "
    local ERR_UNEXPECTED_VALUE = ERR_PREFIX .. " Unexpected value (strict tag is present)"

    type ArrayTypeChecker = TypeChecker<ArrayTypeChecker> & {
        OfLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        ofLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        MinLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        minLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        MaxLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        maxLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        Contains: SelfReturn<ArrayTypeChecker, any>;
        contains: SelfReturn<ArrayTypeChecker, any>;

        OfType: SelfReturn<ArrayTypeChecker, TypeChecker<any>>;
        ofType: SelfReturn<ArrayTypeChecker, TypeChecker<any>>;

        OfStructure: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;
        ofStructure: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;

        StructuralEquals: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;
        structuralEquals: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;

        Strict: SelfReturn<ArrayTypeChecker>;
        strict: SelfReturn<ArrayTypeChecker>;

        DenoteParams: SelfReturn<ArrayTypeChecker>;
        denoteParams: SelfReturn<ArrayTypeChecker>;

        IsFrozen: SelfReturn<ArrayTypeChecker>;
        isFrozen: SelfReturn<ArrayTypeChecker>;

        IsOrdered: SelfReturn<ArrayTypeChecker, boolean | (any?) -> boolean>;
        isOrdered: SelfReturn<ArrayTypeChecker, boolean | (any?) -> boolean>;
    };

    local Array: TypeCheckerConstructor<ArrayTypeChecker, TypeChecker<any>?>, ArrayClass = TypeGuard.Template("Array")

    function ArrayClass:_PrefixError(ErrorString: string, Index: number)
        return ErrorString:format((self._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), Index)
    end

    function ArrayClass:_Initial(TargetArray)
        if (typeof(TargetArray) ~= TYPE_TABLE) then
            return false, "Expected table, got " .. typeof(TargetArray)
        end

        for Key in TargetArray do
            local KeyType = typeof(Key)

            if (KeyType ~= TYPE_NUMBER) then
                return false, "Non-numetic key detected: " .. KeyType
            end
        end

        return true, EMPTY_STRING
    end

    --- Ensures an array is of a certain length
    function ArrayClass:OfLength(Length)
        ExpectType(Length, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("Length", function(_, TargetArray, Length)
            if (#TargetArray ~= Length) then
                return false, "Length must be " .. Length .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, Length)
    end
    ArrayClass.ofLength = ArrayClass.OfLength

    --- Ensures an array is at least a certain length
    function ArrayClass:MinLength(MinLength)
        ExpectType(MinLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MinLength", function(_, TargetArray, MinLength)
            if (#TargetArray < MinLength) then
                return false, "Length must be at least " .. MinLength .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, MinLength)
    end
    ArrayClass.minLength = ArrayClass.MinLength

    --- Ensures an array is at most a certain length
    function ArrayClass:MaxLength(MaxLength)
        ExpectType(MaxLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MaxLength", function(_, TargetArray, MaxLength)
            if (#TargetArray > MaxLength) then
                return false, "Length must be at most " .. MaxLength .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, MaxLength)
    end
    ArrayClass.maxLength = ArrayClass.MaxLength

    --- Ensures an array contains some given value
    function ArrayClass:Contains(Value, StartPoint)
        if (Value == nil) then
            ExpectType(Value, EXPECT_SOMETHING, 1)
        end

        if (StartPoint) then
            ExpectType(StartPoint, EXPECT_NUMBER_OR_FUNCTION, 2)
        end

        return self:_AddConstraint("Contains", function(_, TargetArray, Value, StartPoint)
            if (table.find(TargetArray, Value, StartPoint) == nil) then
                return false, "Value not found in array: " .. tostring(Value)
            end

            return true, EMPTY_STRING
        end, Value, StartPoint)
    end
    ArrayClass.contains = ArrayClass.Contains

    --- Ensures each value in the template array satisfies the passed TypeChecker
    function ArrayClass:OfType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfType", function(SelfRef, TargetArray, SubType)
            for Index, Value in TargetArray do
                local Success, SubMessage = SubType:_Check(Value)

                if (not Success) then
                    return false, ERR_PREFIX:format((SelfRef._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), tostring(Index)) .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ArrayClass.ofType = ArrayClass.OfType

    -- Takes an array of types and checks it against the passed array
    function ArrayClass:OfStructure(SubTypesAtPositions)
        ExpectType(SubTypesAtPositions, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = table.create(#SubTypesAtPositions)

        for Index, Value in SubTypesAtPositions do
            TypeGuard._AssertIsTypeBase(Value, Index)
            SubTypesCopy[Index] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, TargetArray, SubTypesAtPositions)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Index, Checker in SubTypesAtPositions do
                local Success, SubMessage = Checker:_Check(TargetArray[Index])

                if (not Success) then
                    return false, SelfRef:_PrefixError(ERR_PREFIX, tostring(Index)) .. SubMessage
                end
            end

            -- Check there are no extra indexes which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Index in TargetArray do
                    local Checker = SubTypesAtPositions[Index]

                    if (not Checker) then
                        return false, SelfRef:_PrefixError(ERR_UNEXPECTED_VALUE, tostring(Index))
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy, SubTypesAtPositions)
    end
    ArrayClass.ofStructure = ArrayClass.OfStructure

    --- OfStructure but strict
    function ArrayClass:StructuralEquals(Other)
        return self:OfStructure(Other):Strict()
    end
    ArrayClass.structuralEquals = ArrayClass.StructuralEquals

    --- Tags this ArrayTypeChecker as strict i.e. no extra indexes allowed in OfStructure constraint
    function ArrayClass:Strict()
        return self:_AddTag("Strict")
    end
    ArrayClass.strict = ArrayClass.Strict

    --- Tags this ArrayTypeChecker as a params call (just for better information when using TypeGuard.Params)
    function ArrayClass:DenoteParams()
        return self:_AddTag("DenoteParams")
    end
    ArrayClass.denoteParams = ArrayClass.DenoteParams

    --- Checks if an array is frozen
    function ArrayClass:IsFrozen()
        return self:_AddConstraint("IsFrozen", function(_, TargetArray)
            if (table.isfrozen(TargetArray)) then
                return true, EMPTY_STRING
            end

            return false, "Table was not frozen"
        end)
    end
    ArrayClass.isFrozen = ArrayClass.IsFrozen

    --- Checks if an array is ordered
    --- @TODO If 'Descending' = false, assume ascending, but if 'Descending' = nil, assume ascending or descending from first 2 items in the array (accept ordering either way)
    function ArrayClass:IsOrdered(Descending)
        if (Descending ~= nil) then
            ExpectType(Descending, EXPECT_BOOLEAN_OR_FUNCTION, 1)
        end

        return self:_AddConstraint("IsOrdered", function(_, TargetArray, Descending)
            local Ascending = not Descending
            local Size = #TargetArray

            if (Size == 1) then
                return true, EMPTY_STRING
            end

            local Last = TargetArray[1]

            for Index = 2, Size do
                local Current = TargetArray[Index]

                if (Descending and Last < Current) then
                    return false, "Array is not ordered descending at index " .. Index
                elseif (Ascending and Last > Current) then
                    return false, "Array is not ordered ascending at index " .. Index
                end

                Last = Current
            end

            return true, EMPTY_STRING
        end, Descending)
    end
    ArrayClass.isOrdered = ArrayClass.IsOrdered

    ArrayClass._InitialConstraint = ArrayClass.OfType

    TypeGuard.Array = Array
end




do
    type ObjectTypeChecker = TypeChecker<ObjectTypeChecker> & {
        OfStructure: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;
        ofStructure: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;

        StructuralEquals: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;
        structuralEquals: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;

        Strict: SelfReturn<ObjectTypeChecker>;
        strict: SelfReturn<ObjectTypeChecker>;

        OfValueType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        ofValueType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;

        OfKeyType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        ofKeyType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;

        IsFrozen: SelfReturn<ObjectTypeChecker>;
        isFrozen: SelfReturn<ObjectTypeChecker>;

        CheckMetatable: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        checkMetatable: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;

        OfClass: SelfReturn<ObjectTypeChecker, any>;
        ofClass: SelfReturn<ObjectTypeChecker, any>;
    };

    local Object: TypeCheckerConstructor<ObjectTypeChecker, {[any]: TypeChecker<any>}?>, ObjectClass = TypeGuard.Template("Object")

    function ObjectClass:_Initial(TargetObject)
        if (typeof(TargetObject) ~= TYPE_TABLE) then
            return false, "Expected table, got " .. typeof(TargetObject)
        end

        for Key in TargetObject do
            if (typeof(Key) == TYPE_NUMBER) then
                return false, "Incorrect key type: number"
            end
        end

        return true, EMPTY_STRING
    end

    --- Ensures every key that exists in the subject also exists in the structure passed, optionally strict i.e. no extra key-value pairs
    function ObjectClass:OfStructure(OriginalSubTypes)
        ExpectType(OriginalSubTypes, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Index, Value in OriginalSubTypes do
            TypeGuard._AssertIsTypeBase(Value, Index)
            SubTypesCopy[Index] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, StructureCopy, SubTypes)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Key, Checker in SubTypes do
                local RespectiveValue = StructureCopy[Key]

                if (RespectiveValue == nil and not Checker._Tags.Optional) then
                    return false, "[Key '" .. tostring(Key) .. "'] is nil"
                end

                local Success, SubMessage = Checker:_Check(RespectiveValue)

                if (not Success) then
                    return false, "[Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra fields which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Key in StructureCopy do
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Key '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    ObjectClass.ofStructure = ObjectClass.OfStructure

    --- For all values in the passed table, they must satisfy the TypeChecker passed to this constraint
    function ObjectClass:OfValueType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfValueType", function(_, TargetArray, SubType)
            for Index, Value in TargetArray do
                local Success, SubMessage = SubType:_Check(Value)

                if (not Success) then
                    return false, "[OfValueType: Key '" .. tostring(Index) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ObjectClass.ofValueType = ObjectClass.OfValueType

    --- For all keys in the passed table, they must satisfy the TypeChecker passed to this constraint
    function ObjectClass:OfKeyType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfKeyType", function(_, TargetArray, SubType)
            for Key in TargetArray do
                local Success, SubMessage = SubType:_Check(Key)

                if (not Success) then
                    return false, "[OfKeyType: Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ObjectClass.ofKeyType = ObjectClass.OfKeyType

    --- Strict i.e. no extra key-value pairs than what is explicitly specified when using OfStructure
    function ObjectClass:Strict()
        return self:_AddTag("Strict")
    end
    ObjectClass.strict = ObjectClass.Strict

    --- OfStructure but strict
    function ObjectClass:StructuralEquals(Structure)
        return self:OfStructure(Structure):Strict()
    end
    ObjectClass.structuralEquals = ObjectClass.StructuralEquals

    --- Checks if an object is frozen
    function ObjectClass:IsFrozen()
        return self:_AddConstraint("IsFrozen", function(_, TargetObject)
            if (table.isfrozen(TargetObject)) then
                return true, EMPTY_STRING
            end

            return false, "Table was not frozen"
        end)
    end
    ObjectClass.isFrozen = ObjectClass.IsFrozen

    --- Checks an object's metatable
    function ObjectClass:CheckMetatable(Checker)
        TypeGuard._AssertIsTypeBase(Checker, 1)

        return self:_AddConstraint("CheckMetatable", function(_, TargetObject, Checker)
            local Success, Message = Checker:Check(getmetatable(TargetObject))
            return Success, "[Metatable] " .. Message
        end, Checker)
    end
    ObjectClass.checkMetatable = ObjectClass.CheckMetatable

    --- Checks if an object's __index points to the specified class
    function ObjectClass:OfClass(Class)
        ExpectType(Class, EXPECT_TABLE, 1)
        assert(Class.__index, "Class must have an __index")

        return self:CheckMetatable(Object():Equals(Class))
    end

    ObjectClass._InitialConstraint = ObjectClass.OfStructure

    TypeGuard.Object = Object
end




do
    type InstanceTypeChecker = TypeChecker<InstanceTypeChecker> & {
        OfStructure: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;
        ofStructure: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;

        StructuralEquals: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;
        structuralEquals: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;

        IsA: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        isA: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        Strict: SelfReturn<InstanceTypeChecker>;
        strict: SelfReturn<InstanceTypeChecker>;

        IsDescendantOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
        isDescendantOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;

        IsAncestorOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
        isAncestorOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;

        HasTag: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        hasTag: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        HasAttribute: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        hasAttribute: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        CheckAttribute: SelfReturn<InstanceTypeChecker, string, TypeChecker<any>>;
        checkAttribute: SelfReturn<InstanceTypeChecker, string, TypeChecker<any>>;

        HasTags: SelfReturn<InstanceTypeChecker, {string} | (any?) -> {string}>;
        hasTags: SelfReturn<InstanceTypeChecker, {string} | (any?) -> {string}>;

        HasAttributes: SelfReturn<InstanceTypeChecker, {string} | (any?) -> {string}>;
        hasAttributes: SelfReturn<InstanceTypeChecker, {string} | (any?) -> {string}>;

        CheckAttributes: SelfReturn<InstanceTypeChecker, {[string]: TypeChecker<any>} | (any?) -> {[string]: TypeChecker<any>}>;
        checkAttributes: SelfReturn<InstanceTypeChecker, {[string]: TypeChecker<any>} | (any?) -> {[string]: TypeChecker<any>}>;
    };

    local function Get(Inst, Key)
        return Inst[Key]
    end

    local function TryGet(Inst, Key)
        local Success, Result = pcall(Get, Inst, Key)

        if (Success) then
            return Result
        end

        return nil
    end

    local InstanceChecker: TypeCheckerConstructor<InstanceTypeChecker, string | (any?) -> string | nil, {[string]: TypeChecker<any>}?>, InstanceCheckerClass = TypeGuard.Template("Instance")
    InstanceCheckerClass._Initial = CreateStandardInitial(TYPE_INSTANCE)

    --- Ensures that an Instance has specific children and/or properties
    function InstanceCheckerClass:OfStructure(OriginalSubTypes)
        ExpectType(OriginalSubTypes, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Key, Value in OriginalSubTypes do
            TypeGuard._AssertIsTypeBase(Value, Key)
            SubTypesCopy[Key] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, InstanceRoot, SubTypes)
            -- Check all properties and children which should be in the Instance exist (unless optional) and the type check for each passes
            for Key, Checker in SubTypes do
                local Value = TryGet(InstanceRoot, Key)
                local Success, SubMessage = Checker:_Check(Value)

                if (not Success) then
                    return false, (typeof(Value) == TYPE_INSTANCE and "[Instance '" or "[Property '") .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra children which shouldn't be in the Instance
            if (SelfRef._Tags.Strict) then
                for _, Value in InstanceRoot:GetChildren() do
                    local Key = Value.Name
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Instance '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    InstanceCheckerClass.ofStructure = InstanceCheckerClass.OfStructur

    --- Uses Instance.IsA to assert the type of an Instance
    function InstanceCheckerClass:IsA(InstanceIsA)
        ExpectType(InstanceIsA, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("IsA", function(_, InstanceRoot, InstanceIsA)
            if (not InstanceRoot:IsA(InstanceIsA)) then
                return false, "Expected " .. InstanceIsA .. ", got " .. InstanceRoot.ClassName
            end

            return true, EMPTY_STRING
        end, InstanceIsA)
    end
    InstanceCheckerClass.isA = InstanceCheckerClass.IsA

    --- Activates strict tag for OfStructure
    function InstanceCheckerClass:Strict()
        return self:_AddTag("Strict")
    end
    InstanceCheckerClass.strict = InstanceCheckerClass.Strict

    --- OfStructure + strict tag i.e. no extra children exist beyond what is specified
    function InstanceCheckerClass:StructuralEquals(Structure)
        return self:OfStructure(Structure):Strict()
    end
    InstanceCheckerClass.structuralEquals = InstanceCheckerClass.StructuralEquals

    --- Checks if an Instance has a particular tag
    --- @deprecated Use HasTags instead
    function InstanceCheckerClass:HasTag(Tag: string)
        ExpectType(Tag, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasTag", function(_, InstanceRoot, Tag)
            if (CollectionService:HasTag(InstanceRoot, Tag)) then
                return true, EMPTY_STRING
            end

            return false, "Expected tag '" .. Tag .. "' on Instance " .. InstanceRoot:GetFullName()
        end, Tag)
    end
    InstanceCheckerClass.hasTag = InstanceCheckerClass.HasTag

    --- Checks if an Instance has a particular attribute
    --- @deprecated Use HasAttributes instead
    function InstanceCheckerClass:HasAttribute(Attribute: string)
        ExpectType(Attribute, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasAttribute", function(_, InstanceRoot, Attribute)
            if (InstanceRoot:GetAttribute(Attribute) ~= nil) then
                return true, EMPTY_STRING
            end

            return false, "Expected attribute '" .. Attribute .. "' to exist on Instance " .. InstanceRoot:GetFullName()
        end, Attribute)
    end
    InstanceCheckerClass.hasAttribute = InstanceCheckerClass.HasAttribute

    --- Applies a TypeChecker to an Instance's expected attribute
    --- @deprecated Use CheckAttributes instead
    function InstanceCheckerClass:CheckAttribute(Attribute: string, Checker: TypeChecker<any>)
        ExpectType(Attribute, EXPECT_STRING_OR_FUNCTION, 1)
        TypeGuard._AssertIsTypeBase(Checker, 2)

        return self:_AddConstraint("CheckAttribute", function(_, InstanceRoot, Attribute)
            local Success, SubMessage = Checker:_Check(InstanceRoot:GetAttribute(Attribute))

            if (not Success) then
                return false, "Attribute '" .. Attribute .. "' not satisfied on Instance " .. InstanceRoot:GetFullName() .. ": " .. SubMessage
            end

            return true, EMPTY_STRING
        end, Attribute, Checker)
    end
    InstanceCheckerClass.checkAttribute = InstanceCheckerClass.CheckAttribute





    --- Checks if an Instance has a set of tags
    function InstanceCheckerClass:HasTags(Tags: {string})
        ExpectType(Tags, EXPECT_TABLE_OR_FUNCTION, 1)

        if (typeof(Tags) == TYPE_TABLE) then
            for Index, Tag in Tags do
                assert(typeof(Tag) == "string", "Expected tag #" .. Index .. " to be a string")
            end
        end

        return self:_AddConstraint("HasTags", function(_, InstanceRoot, Tags)
            for _, Tag in Tags do
                if (not CollectionService:HasTag(InstanceRoot, Tag)) then
                    return false, "Expected tag '" .. Tag .. "' on Instance " .. InstanceRoot:GetFullName()
                end
            end

            return true, EMPTY_STRING
        end, Tags)
    end
    InstanceCheckerClass.hasTags = InstanceCheckerClass.HasTags

    --- Checks if an Instance has a set of attributes
    function InstanceCheckerClass:HasAttributes(Attributes: {string})
        ExpectType(Attributes, EXPECT_TABLE_OR_FUNCTION, 1)

        if (typeof(Attributes) == TYPE_TABLE) then
            for Index, Attribute in Attributes do
                assert(typeof(Attribute) == "string", "Expected attribute #" .. Index .. " to be a string")
            end
        end

        return self:_AddConstraint("HasAttributes", function(_, InstanceRoot, Attributes)
            for _, Attribute in Attributes do
                if (InstanceRoot:GetAttribute(Attribute) == nil) then
                    return false, "Expected attribute '" .. Attribute .. "' to exist on Instance " .. InstanceRoot:GetFullName()
                end
            end

            return true, EMPTY_STRING
        end, Attributes)
    end
    InstanceCheckerClass.hasAttributes = InstanceCheckerClass.HasAttributes

    --- Applies a TypeChecker to an Instance's expected attribute
    function InstanceCheckerClass:CheckAttributes(AttributeCheckers: {TypeChecker<any>})
        ExpectType(AttributeCheckers, EXPECT_TABLE, 1)

        for Attribute, Checker in AttributeCheckers do
            assert(typeof(Attribute) == "string", "Attribute '" .. tostring(Attribute) .. "' was not a string")
            TypeGuard._AssertIsTypeBase(Checker, "")
        end

        return self:_AddConstraint("CheckAttributes", function(_, InstanceRoot, AttributeCheckers)
            for Attribute, Checker in AttributeCheckers do
                local Success, SubMessage = Checker:_Check(InstanceRoot:GetAttribute(Attribute))

                if (not Success) then
                    return false, "Attribute '" .. Attribute .. "' not satisfied on Instance " .. InstanceRoot:GetFullName() .. ": " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, AttributeCheckers)
    end
    InstanceCheckerClass.checkAttributes = InstanceCheckerClass.CheckAttributes

    --- Checks if an Instance is a descendant of a particular Instance
    function InstanceCheckerClass:IsDescendantOf(Instance)
        ExpectType(Instance, EXPECT_INSTANCE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsDescendantOf", function(_, SubjectInstance, Instance)
            if (SubjectInstance:IsDescendantOf(Instance)) then
                return true, EMPTY_STRING
            end

            return false, "Expected Instance " .. SubjectInstance:GetFullName() .. " to be a descendant of " .. Instance:GetFullName()
        end, Instance)
    end
    InstanceCheckerClass.isDescendantOf = InstanceCheckerClass.IsDescendantOf

    --- Checks if an Instance is an ancestor of a particular Instance
    function InstanceCheckerClass:IsAncestorOf(Instance)
        ExpectType(Instance, EXPECT_INSTANCE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAncestorOf", function(_, SubjectInstance, Instance)
            if (SubjectInstance:IsAncestorOf(Instance)) then
                return true, EMPTY_STRING
            end

            return false, "Expected Instance " .. SubjectInstance:GetFullName() .. " to be an ancestor of " .. Instance:GetFullName()
        end, Instance)
    end
    InstanceCheckerClass.isAncestorOf = InstanceCheckerClass.IsAncestorOf

    --- Checks if a particular child exists in an Instance
    function InstanceCheckerClass:HasChild(Name)
        ExpectType(Name, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasChild", function(_, InstanceRoot, Name)
            if (InstanceRoot:FindFirstChild(Name)) then
                return true, EMPTY_STRING
            end

            return false, "Expected child '" .. Name .. "' to exist on Instance " .. InstanceRoot:GetFullName()
        end, Name)
    end

    InstanceCheckerClass._InitialConstraints = {InstanceCheckerClass.IsA, InstanceCheckerClass.OfStructure}

    TypeGuard.Instance = InstanceChecker
end




do
    type BooleanTypeChecker = TypeChecker<BooleanTypeChecker> & {};

    local Boolean: TypeCheckerConstructor<BooleanTypeChecker, boolean?>, BooleanClass = TypeGuard.Template("Boolean")
    BooleanClass._Initial = CreateStandardInitial(TYPE_BOOLEAN)

    BooleanClass._InitialConstraint = BooleanClass.Equals

    TypeGuard.Boolean = Boolean
    TypeGuard.boolean = Boolean
end




do
    type EnumTypeChecker = TypeChecker<EnumTypeChecker> & {
        IsA: SelfReturn<EnumTypeChecker, Enum | EnumItem | (any?) -> Enum | EnumItem>;
        isA: SelfReturn<EnumTypeChecker, Enum | EnumItem | (any?) -> Enum | EnumItem>;
    };

    local EnumChecker: TypeCheckerConstructor<EnumTypeChecker>, EnumCheckerClass = TypeGuard.Template("Enum")

    function EnumCheckerClass:_Initial(Value)
        local GotType = typeof(Value)

        if (GotType ~= TYPE_ENUM_ITEM and GotType ~= TYPE_ENUM) then
            return false, "Expected EnumItem or Enum, got " .. GotType
        end

        return true, EMPTY_STRING
    end

    --- Ensures that a passed EnumItem is either equivalent to an EnumItem or a sub-item of an Enum class
    function EnumCheckerClass:IsA(TargetEnum)
        ExpectType(TargetEnum, EXPECT_ENUM_OR_ENUM_ITEM_OR_FUNCTION, 1)

        return self:_AddConstraint("IsA", function(_, Value, TargetEnum)
            local TargetType = typeof(TargetEnum)

            -- Both are EnumItems
            if (TargetType == TYPE_ENUM_ITEM) then
                if (Value == TargetEnum) then
                    return true, EMPTY_STRING
                end

                return false, "Expected " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            -- TargetType is an Enum
            if (table.find(TargetEnum:GetEnumItems(), Value) == nil) then
                return false, "Expected a " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            return true, EMPTY_STRING
        end, TargetEnum)
    end
    EnumCheckerClass.isA = EnumCheckerClass.IsA

    EnumCheckerClass._InitialConstraint = EnumCheckerClass.IsA

    TypeGuard.Enum = EnumChecker
end




do
    type ThreadTypeChecker = TypeChecker<ThreadTypeChecker> & {
        IsDead: SelfReturn<ThreadTypeChecker>;
        isDead: SelfReturn<ThreadTypeChecker>;

        IsSuspended: SelfReturn<ThreadTypeChecker>;
        isSuspended: SelfReturn<ThreadTypeChecker>;

        IsRunning: SelfReturn<ThreadTypeChecker>;
        isRunning: SelfReturn<ThreadTypeChecker>;

        IsNormal: SelfReturn<ThreadTypeChecker>;
        isNormal: SelfReturn<ThreadTypeChecker>;

        HasStatus: SelfReturn<ThreadTypeChecker, string | (any?) -> string>;
        hasStatus: SelfReturn<ThreadTypeChecker, string | (any?) -> string>;
    };

    local ThreadChecker: TypeCheckerConstructor<ThreadTypeChecker>, ThreadCheckerClass = TypeGuard.Template("Thread")
    ThreadCheckerClass._Initial = CreateStandardInitial(TYPE_THREAD)

    function ThreadCheckerClass:IsDead()
        return self:HasStatus("dead"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsSuspended()
        return self:HasStatus("suspended"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsRunning()
        return self:HasStatus("running"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsNormal()
        return self:HasStatus("normal"):_AddTag("StatusCheck")
    end

    --- Checks the coroutine's status against a given status string
    function ThreadCheckerClass:HasStatus(Status)
        ExpectType(Status, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasStatus", function(_, Thread, Status)
            local CurrentStatus = coroutine.status(Thread)

            if (CurrentStatus == Status) then
                return true, EMPTY_STRING
            end

            return false, "Expected thread to have status '" .. Status .. "', got " .. CurrentStatus
        end, Status)
    end

    TypeGuard._InitialConstraint = ThreadCheckerClass.HasStatus

    TypeGuard.Thread = ThreadChecker
    TypeGuard.thread = ThreadChecker
end




do
    type AnyTypeChecker = TypeChecker<AnyTypeChecker> & {}

    local AnyChecker: TypeCheckerConstructor<AnyTypeChecker>, AnyCheckerClass = TypeGuard.Template("Any")
    function AnyCheckerClass:_Initial(Item)
        if (Item == nil) then
            return false, "Expected something, got nil"
        end

        return true, EMPTY_STRING
    end

    TypeGuard.Any = AnyChecker
    TypeGuard.any = AnyChecker
end




-- Luau data types
TypeGuard.Axes = TypeGuard.FromTypeName("Axes")
TypeGuard.BrickColor = TypeGuard.FromTypeName("BrickColor")
TypeGuard.CatalogSearchParams = TypeGuard.FromTypeName("CatalogSearchParams")
TypeGuard.CFrame = TypeGuard.FromTypeName("CFrame")
TypeGuard.Color3 = TypeGuard.FromTypeName("Color3")
TypeGuard.ColorSequence = TypeGuard.FromTypeName("ColorSequence")
TypeGuard.ColorSequenceKeypoint = TypeGuard.FromTypeName("ColorSequenceKeypoint")
TypeGuard.DateTime = TypeGuard.FromTypeName("DateTime")
TypeGuard.DockWidgetPluginGuiInfo = TypeGuard.FromTypeName("DockWidgetPluginGuiInfo")
TypeGuard.Enums = TypeGuard.FromTypeName("Enums")
TypeGuard.Faces = TypeGuard.FromTypeName("Faces")
TypeGuard.FloatCurveKey = TypeGuard.FromTypeName("FloatCurveKey")
TypeGuard.NumberRange = TypeGuard.FromTypeName("NumberRange")
TypeGuard.NumberSequence = TypeGuard.FromTypeName("NumberSequence")
TypeGuard.NumberSequenceKeypoint = TypeGuard.FromTypeName("NumberSequenceKeypoint")
TypeGuard.OverlapParams = TypeGuard.FromTypeName("OverlapParams")
TypeGuard.PathWaypoint = TypeGuard.FromTypeName("PathWaypoint")
TypeGuard.PhysicalProperties = TypeGuard.FromTypeName("PhysicalProperties")
TypeGuard.Random = TypeGuard.FromTypeName("Random")
TypeGuard.Ray = TypeGuard.FromTypeName("Ray")
TypeGuard.RaycastParams = TypeGuard.FromTypeName("RaycastParams")
TypeGuard.RaycastResult = TypeGuard.FromTypeName("RaycastResult")
TypeGuard.RBXScriptConnection = TypeGuard.FromTypeName("RBXScriptConnection")
TypeGuard.RBXScriptSignal = TypeGuard.FromTypeName("RBXScriptSignal")
TypeGuard.Rect = TypeGuard.FromTypeName("Rect")
TypeGuard.Region3 = TypeGuard.FromTypeName("Region3")
TypeGuard.Region3int16 = TypeGuard.FromTypeName("Region3int16")
TypeGuard.TweenInfo = TypeGuard.FromTypeName("TweenInfo")
TypeGuard.UDim = TypeGuard.FromTypeName("UDim")
TypeGuard.UDim2 = TypeGuard.FromTypeName("UDim2")
TypeGuard.Vector2 = TypeGuard.FromTypeName("Vector2")
TypeGuard.Vector2int16 = TypeGuard.FromTypeName("Vector2int16")
TypeGuard.Vector3 = TypeGuard.FromTypeName("Vector3")
TypeGuard.Vector3int16 = TypeGuard.FromTypeName("Vector3int16")

-- Extra base Lua data types
TypeGuard.Function = TypeGuard.FromTypeName(TYPE_FUNCTION)
TypeGuard[TYPE_FUNCTION] = TypeGuard.Function

TypeGuard.Userdata = TypeGuard.FromTypeName(TYPE_USERDATA)
TypeGuard[TYPE_USERDATA] = TypeGuard.Userdata

TypeGuard.Nil = TypeGuard.FromTypeName(TYPE_NIL)
TypeGuard[TYPE_NIL] = TypeGuard.Nil

--- Creates a function which checks params as if they were a strict Array checker
function TypeGuard.Params(...: TypeChecker<any>)
    local Args = {...}
    local ArgSize = #Args

    for Index, ParamChecker in Args do
        TypeGuard._AssertIsTypeBase(ParamChecker, Index)
    end

    return function(...)
        local Size = select("#", ...)

        if (ArgSize ~= Size) then
            error("Expected " .. ArgSize .. " argument" .. (ArgSize == 1 and "" or "s") .. ", got " .. Size)
        end

        for Index = 1, Size do
            local Success, Message = Args[Index]:Check(select(Index, ...))

            if (not Success) then
                error("Invalid argument #" .. Index .. " (" .. Message .. ")")
            end
        end
    end
end
TypeGuard.params = TypeGuard.Params

--- Creates a function which checks variadic params against a single given TypeChecker
function TypeGuard.VariadicParams(CompareType: TypeChecker<any>)
    TypeGuard._AssertIsTypeBase(CompareType, 1)

    return function(...)
        local Size = select("#", ...)

        for Index = 1, Size do
            local Success, Message = CompareType:Check(select(Index, ...))

            if (not Success) then
                error("Invalid argument #" .. Index .. " (" .. Message .. ")")
            end
        end
    end
end
TypeGuard.variadicParams = TypeGuard.VariadicParams

--- Creates a function which checks params as if they were a strict Array checker, using context as the first param; context is passed down to functional constraint args
function TypeGuard.ParamsWithContext(...: TypeChecker<any>)
    local Args = {...}
    local ArgSize = #Args

    for Index, ParamChecker in Args do
        TypeGuard._AssertIsTypeBase(ParamChecker, Index)
    end

    return function(Context: any?, ...)
        local Size = select("#", ...)

        if (ArgSize ~= Size) then
            error("Expected " .. ArgSize .. " argument" .. (ArgSize == 1 and "" or "s") .. ", got " .. Size)
        end

        for Index = 1, Size do
            local Success, Message = Args[Index]:WithContext(Context):Check(select(Index, ...))

            if (not Success) then
                error("Invalid argument #" .. Index .. " (" .. Message .. ")")
            end
        end
    end
end

--- Creates a function which checks variadic params against a single given TypeChecker, using context as the first param; context is passed down to functional constraint args
function TypeGuard.VariadicParamsWithContext(CompareType: TypeChecker<any>)
    TypeGuard._AssertIsTypeBase(CompareType, 1)

    return function(Context: any?, ...)
        local Size = select("#", ...)

        for Index = 1, Size do
            local Success, Message = CompareType:WithContext(Context):Check(select(Index, ...))

            if (not Success) then
                error("Invalid argument #" .. Index .. " (" .. Message .. ")")
            end
        end
    end
end

--- Wraps a function in a param checker function
function TypeGuard.WrapFunctionParams(Call: (...any) -> (...any), ...: TypeChecker<any>)
    ExpectType(Call, EXPECT_FUNCTION, 1)

    for Index = 1, select("#", ...) do
        TypeGuard._AssertIsTypeBase(select(Index, ...), Index)
    end

    local ParamChecker = TypeGuard.Params(...)

    return function(...)
        ParamChecker(...)
        return Call(...)
    end
end

--- Wraps a function in a variadic param checker function
function TypeGuard.WrapFunctionVariadicParams(Call: (...any) -> (...any), VariadicParamType: TypeChecker<any>)
    ExpectType(Call, EXPECT_FUNCTION, 1)
    TypeGuard._AssertIsTypeBase(VariadicParamType, 2)

    local ParamChecker = TypeGuard.VariadicParams(VariadicParamType)

    return function(...)
        ParamChecker(...)
        return Call(...)
    end
end

return TypeGuard]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f57b</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="73">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TypeGuard.spec</string>
							<string name="ScriptGuid">{1133A44A-452E-47F7-8965-105E1C3F6108}</string>
							<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

return function()
    local TypeGuard = require(script.Parent)

    describe("Template", function()
        it("should reject no Name given", function()
            expect(function()
                TypeGuard.Template()
            end).to.throw()
        end)

        it("should reject incorrect types for Name", function()
            expect(function()
                TypeGuard.Template(1)
            end).to.throw()

            expect(function()
                TypeGuard.Template({})
            end).to.throw()

            expect(function()
                TypeGuard.Template(true)
            end).to.throw()

            expect(function()
                TypeGuard.Template("Test")
            end).never.to.throw()
        end)

        it("should return a constructor function and a TypeChecker class for extension", function()
            local TestCreate, TestClass = TypeGuard.Template("Test")
            expect(TestCreate).to.be.a("function")
            expect(TestClass).to.be.a("table")
            expect(TestClass.IsTemplate).to.equal(true)
        end)
    end)

    describe("Params", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.Params(1)
            end).to.throw()

            expect(function()
                TypeGuard.Params({})
            end).to.throw()

            expect(function()
                TypeGuard.Params(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number())(1)
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Number())("Test")
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number(), TypeGuard.String())(1, "Test")
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Number(), TypeGuard.String())(1, 1)
            end).to.throw()
        end)
    end)

    describe("ParamsWithContext", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.ParamsWithContext(1)
            end).to.throw()

            expect(function()
                TypeGuard.ParamsWithContext({})
            end).to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, "Test")
            end).to.throw()
        end)

        it("should accept a context as first arg (or nil)", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())("Test", 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()
        end)

        it("should pass the context down", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1)
            end).never.to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number(), TypeGuard.String())(nil, 1, "Test")
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number(), TypeGuard.String())(nil, 1, 1)
            end).to.throw()
        end)
    end)

    describe("VariadicParams", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParams({})
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParams(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())("Test")
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1, "Test")
            end).to.throw()
        end)
    end)

    describe("VariadicParamsWithContext", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(1)
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext({})
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, "Test")
            end).to.throw()
        end)

        it("should accept a context as first arg (or nil)", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())("Test", 1, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, 1, 1)
            end).never.to.throw()
        end)

        it("should pass the context down", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1, 1, 2)
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, "Test")
            end).to.throw()
        end)
    end)

    describe("WrapFunctionParams", function()
        it("should reject non functions as first arg", function()
            expect(function()
                TypeGuard.WrapFunctionParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams({})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(true)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end)
            end).never.to.throw()
        end)

        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionParams(function() end, 1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, {})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should wrap a function", function()
            local function TestFunction(_X, _Y, _Z) end

            local TestWrapped = TypeGuard.WrapFunctionParams(TestFunction, TypeGuard.Number(), TypeGuard.String(), TypeGuard.Boolean())
            expect(TestWrapped).to.be.a("function")

            expect(function()
                TestWrapped(1, "x", true)
            end).never.to.throw()

            expect(function()
                TestWrapped(1, "x", "y")
            end).to.throw()

            expect(function()
                TestWrapped(1, "x", true, "y")
            end).to.throw()

            expect(function()
                TestWrapped("1", "x", true)
            end).to.throw()
        end)
    end)

    describe("WrapFunctionVariadicParams", function()
        it("should reject non functions as first arg", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams({})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(true)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Number())
            end).never.to.throw()
        end)

        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, 1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, {})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should wrap a function", function()
            local function TestFunction(_X, ...) end

            local TestWrapped = TypeGuard.WrapFunctionVariadicParams(TestFunction, TypeGuard.Number())
            expect(TestWrapped).to.be.a("function")

            expect(function()
                TestWrapped(1)
            end).never.to.throw()

            expect(function()
                TestWrapped(1, "x")
            end).to.throw()

            expect(function()
                TestWrapped(1, "x", true)
            end).to.throw()

            expect(function()
                TestWrapped(9, 8, 7, 6, 5, 4, 3, 2, 1)
            end).never.to.throw()
        end)
    end)

    -- These behaviors extend to all TypeChecker implementations
    describe("TypeChecker", function()
        describe("Optional", function()
            it("should accept nil as a checked value", function()
                expect(TypeGuard.Number():Optional():Check(nil)).to.equal(true)
            end)

            it("should accept the target constraint as a checked value if not nil", function()
                expect(TypeGuard.Number():Optional():Check(1)).to.equal(true)
                expect(TypeGuard.Number():Optional():Check("Test")).to.equal(false)
            end)
        end)

        describe("Alias", function()
            it("should reject non-string args", function()
                expect(function()
                    TypeGuard.Number():Alias(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Alias({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Alias(true)
                end).to.throw()
            end)

            it("should accept string args", function()
                expect(function()
                    TypeGuard.Number():Alias("Test")
                end).never.to.throw()
            end)

            it("should give a fail string with the alias", function()
                local _, Result = TypeGuard.Number():Or(TypeGuard.Array()):Alias("TestAlias"):Check("Test")
                expect(Result).to.be.a("string")
                expect(Result:match("TestAlias")).to.be.ok()
            end)
        end)

        describe("Or", function()
            it("should reject non-TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():Or(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Or({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Or(true)
                end).to.throw()
            end)

            it("should accept TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():Or(TypeGuard.Number())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():Or(TypeGuard.String())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():Or(TypeGuard.Array())
                end).never.to.throw()
            end)

            it("should accept function args", function()
                expect(function()
                    TypeGuard.Number():Or(function() end)
                end).never.to.throw()
            end)

            it("should accept inputs if they satisfy a TypeChecker in the or chain", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Boolean())
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(true)).to.equal(true)
                expect(Check:Check(false)).to.equal(true)
            end)

            it("should reject inputs if they do not satisfy a TypeChecker in the or chain", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Boolean())
                expect(Check:Check("Test")).to.equal(false)
                expect(Check:Check({})).to.equal(false)
            end)

            it("should accept functional inputs if they return a TypeChecker which satisfies the or chain", function()
                local Check = TypeGuard.Number():Or(function() return TypeGuard.Boolean() end)
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(true)).to.equal(true)
                expect(Check:Check(false)).to.equal(true)
            end)

            it("should reject functional inputs if they return a TypeChecker which does not satisfy the or chain", function()
                local Check = TypeGuard.Number():Or(function() return TypeGuard.Boolean() end)
                expect(Check:Check("Test")).to.equal(false)
                expect(Check:Check({})).to.equal(false)
            end)
        end)

        describe("And", function()
            it("should reject non-TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():And(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():And({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():And(true)
                end).to.throw()
            end)

            it("should accept TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():And(TypeGuard.Number())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():And(TypeGuard.String())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():And(TypeGuard.Array())
                end).never.to.throw()
            end)

            it("should reject inputs if they do not satisfy at least one TypeChecker in the and chain", function()
                local Check = TypeGuard.Number():And(TypeGuard.Boolean())
                expect(Check:Check(1)).to.equal(false)
                expect(Check:Check(true)).to.equal(false)
                expect(Check:Check(false)).to.equal(false)
            end)

            it("should accept inputs if they satisfy all TypeCheckers in the and chain and reject if they do not (for objects)", function()
                local Check = TypeGuard.Object():OfStructure({X = TypeGuard.Number()})
                                :And(TypeGuard.Object():OfStructure({Y = TypeGuard.String()}))
                                :And(TypeGuard.Object():OfStructure({Z = TypeGuard.Boolean()}))

                expect(Check:Check({X = 1, Y = "A", Z = false})).to.equal(true)
                expect(Check:Check({X = 1})).to.equal(false)
                expect(Check:Check({X = 1, Y = "A", Z = {}})).to.equal(false)
            end)

            it("should accept inputs if they satisfy all TypeCheckers in the and chain and reject if they do not (for Instances)", function()
                local Check = TypeGuard.Instance():OfStructure({Name = TypeGuard.String()})
                              :And(TypeGuard.Instance():OfStructure({
                                  SomeChild = TypeGuard.Instance();
                              }))

                local TestInstance = Instance.new("Folder")
                    local SomeChild = Instance.new("Folder")
                    SomeChild.Name = "SomeChild"
                    SomeChild.Parent = TestInstance

                local TestInstance2 = Instance.new("Folder")
                    local SomeChild2 = Instance.new("Folder")
                    SomeChild2.Name = "SomeChild2"
                    SomeChild2.Parent = TestInstance2

                expect(Check:Check(TestInstance)).to.equal(true)
                expect(Check:Check(TestInstance2)).to.equal(false)
            end)
        end)

        describe("Check", function()
            it("should return a true boolean and an empty string on success", function()
                local Check = TypeGuard.Number()
                local Result, Error = Check:Check(1)
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(true)
                expect(Error).to.be.a("string")
                expect(Error).to.equal("")
            end)

            it("should return a false boolean and a fail string on failure", function()
                local Check = TypeGuard.Number()
                local Result, Error = Check:Check("Test")
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(false)
                expect(Error).to.be.a("string")
                expect(Error).never.to.equal("")
            end)
        end)

        describe("Cached", function()
            it("should cache results if Cached is used on simple types", function()
                local Check = TypeGuard.Number():Cached()
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(1)).to.equal(true)
            end)

            it("should cache results if Cached is used on complex types", function()
                local Check = TypeGuard.Object():StructuralEquals({X = TypeGuard.Number()}):Cached()
                local Test = {X = 1}
                expect(Check:Check(Test)).to.equal(true)
                Test.Y = 2
                expect(Check:Check(Test)).to.equal(true) -- Technically incorrect but that's the cost of caching: performance increase for temporal correctness
                expect(Check:Check({X = 1})).to.equal(true)
            end)
        end)

        describe("WrapCheck", function()
            it("should return a function", function()
                expect(TypeGuard.Number():WrapCheck()).to.be.a("function")
            end)

            it("should call Check directly and pass a boolean & status string", function()
                local Check = TypeGuard.Number():WrapCheck()
                local Result, Error = Check(1)
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(true)
                expect(Error).to.be.a("string")
                expect(Error).to.equal("")

                local Result2, Error2 = Check("Test")
                expect(Result2).to.be.a("boolean")
                expect(Result2).to.equal(false)
                expect(Error2).to.be.a("string")
                expect(Error2).never.to.equal("")
            end)
        end)

        describe("Assert", function()
            it("should not throw when the type is satisfied", function()
                expect(function()
                    TypeGuard.Number():Assert(1)
                end).never.to.throw()
            end)

            it("should throw when the type is unsatisfied, giving the status string", function()
                local Input = "Test"
                local _, CheckResult = TypeGuard.Number():Check(Input)

                expect(function()
                    TypeGuard.Number():Assert(Input)
                end).to.throw(CheckResult)
            end)
        end)

        describe("WrapAssert", function()
            it("should return a function", function()
                expect(TypeGuard.Number():WrapAssert()).to.be.a("function")
            end)

            it("should call Assert directly and pass a boolean & status string", function()
                local Input = 1

                local _, CheckResult = TypeGuard.Number():Check(Input)
                local AssertFunction = TypeGuard.Number():WrapAssert()

                expect(function()
                    AssertFunction(Input)
                end).never.to.throw()

                expect(function()
                    AssertFunction("Test")
                end).to.throw(CheckResult)
            end)
        end)

        describe("Negate", function()
            it("should throw an exception if there are no constraints", function()
                expect(function()
                    TypeGuard.Number():Negate()
                end).to.throw()
            end)

            it("should invert the result of the TypeChecker", function()
                local Check = TypeGuard.Number():Equals(5):Negate()
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(5)).to.equal(false)
                expect(Check:Check(10)).to.equal(true)
            end)

            it("should invert only the last constraint", function()
                local Check = TypeGuard.Number():GreaterThan(1):Equals(10):Negate()
                expect(Check:Check(2)).to.equal(true)
                expect(Check:Check(10)).to.equal(false)
                expect(Check:Check(20)).to.equal(true)
            end)
        end)

        describe("WithContext", function()
            it("should accept any value", function()
                expect(function()
                    TypeGuard.Number():WithContext("Test")
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(1)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(true)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(false)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(nil)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(Instance.new("Folder"))
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext({X = 1, Y = 2})
                end).never.to.throw()
            end)

            it("should pass the context to constraints", function()
                local DidRun = false
                local Check = TypeGuard.Number():WithContext("Test"):Equals(function(Context)
                    DidRun = true
                    expect(Context).to.equal("Test")
                    return 1
                end)

                expect(Check:Check(1)).to.equal(true)
                expect(DidRun).to.equal(true)
            end)

            it("should pass the root context down even if a new context is given mid-way", function()
                local DidRun = false
                local Check = TypeGuard.Object():WithContext("Test0"):OfStructure({
                    X = TypeGuard.Object():WithContext("Test1"):OfStructure({
                        Y = TypeGuard.Number():WithContext("Test2"):Equals(function(Context)
                            DidRun = true
                            expect(Context).to.equal("Test0")
                            return 1
                        end)
                    });
                })

                expect(Check:Check({
                    X = {
                        Y = 1;
                    }
                })).to.equal(true)
                expect(DidRun).to.equal(true)
            end)
        end)

        describe("FailMessage", function()
            it("should reject non-string args", function()
                expect(function()
                    TypeGuard.Number():FailMessage(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage(true)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage(false)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage(nil)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage({})
                end).to.throw()
            end)

            it("should accept string args", function()
                expect(function()
                    TypeGuard.Number():FailMessage("Test")
                end).never.to.throw()
            end)

            it("should enforce a custom fail message on failure", function()
                local Check = TypeGuard.Number():FailMessage("0123456789")
                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")
            end)

            it("should work with Or calls", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Array()):FailMessage("0123456789")
                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")
            end)

            it("should work with And calls", function()
                local Check = TypeGuard.Number():And(TypeGuard.Array()):FailMessage("0123456789")
                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")
            end)

            it("should work with Cached calls", function()
                local Check = TypeGuard.Number():Cached():FailMessage("0123456789")

                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")

                local _, Again = Check:Check("Test")
                expect(Again).to.equal("0123456789")
            end)

            it("should still exist with subsequent constraint calls", function()
                local Check = TypeGuard.Number():FailMessage("0123456789"):RangeInclusive(0, 10):Decimal()
                local _, Error = Check:Check(1000)
                expect(Error).to.equal("0123456789")
            end)
        end)
    end)

    describe("Number", function()
        local Base = TypeGuard.Number()

        describe("Init", function()
            it("should reject non-numbers", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(true)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept numbers", function()
                expect(Base:Check(1)).to.equal(true)
                expect(Base:Check(1.1)).to.equal(true)
                expect(Base:Check(0)).to.equal(true)
                expect(Base:Check(-1)).to.equal(true)
                expect(Base:Check(-1.1)).to.equal(true)
            end)
        end)

        describe("Integer", function()
            it("should reject non-integers", function()
                expect(Base:Integer():Check(1.1)).to.equal(false)
            end)

            it("should accept integers", function()
                expect(Base:Integer():Check(1)).to.equal(true)
            end)

            it("should accept negative integers", function()
                expect(Base:Integer():Check(-1)).to.equal(true)
            end)

            it("should reject non-numbers", function()
                expect(Base:Integer():Check("Test")).to.equal(false)
            end)
        end)

        describe("Decimal", function()
            it("should reject non-decimals", function()
                expect(Base:Decimal():Check(1)).to.equal(false)
            end)

            it("should accept decimals", function()
                expect(Base:Decimal():Check(1.1)).to.equal(true)
            end)

            it("should accept negative decimals", function()
                expect(Base:Decimal():Check(-1.1)).to.equal(true)
            end)

            it("should reject non-numbers", function()
                expect(Base:Decimal():Check("Test")).to.equal(false)
            end)
        end)

        describe("RangeInclusive", function()
            it("should reject non-numbers", function()
                expect(Base:RangeInclusive(1, 2):Check("Test")).to.equal(false)
            end)

            it("should reject numbers outside of range", function()
                local Range = Base:RangeInclusive(1, 2)
                expect(Range:Check(0)).to.equal(false)
                expect(Range:Check(3)).to.equal(false)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(0)).to.equal(false)
                expect(FuncRange:Check(3)).to.equal(false)
            end)

            it("should accept numbers inside of range", function()
                local Range = Base:RangeInclusive(1, 2)
                expect(Range:Check(1)).to.equal(true)
                expect(Range:Check(2)).to.equal(true)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(2)).to.equal(true)
            end)

            it("should accept numbers equal to the range bounds", function()
                expect(Base:RangeInclusive(1, 2):Check(1)).to.equal(true)
                expect(Base:RangeInclusive(1, 2):Check(2)).to.equal(true)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1)).to.equal(true)
                expect(FuncRange:Check(2)).to.equal(true)
            end)
        end)

        describe("RangeExclusive", function()
            it("should reject non-numbers", function()
                expect(Base:RangeExclusive(1, 2):Check("Test")).to.equal(false)
            end)

            it("should reject numbers outside of range", function()
                expect(Base:RangeExclusive(1, 2):Check(0)).to.equal(false)
                expect(Base:RangeExclusive(1, 2):Check(3)).to.equal(false)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(0)).to.equal(false)
                expect(FuncRange:Check(3)).to.equal(false)
            end)

            it("should accept numbers inside of range", function()
                expect(Base:RangeExclusive(1, 2):Check(1.1)).to.equal(true)
                expect(Base:RangeExclusive(1, 2):Check(1.9)).to.equal(true)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1.1)).to.equal(true)
                expect(FuncRange:Check(1.9)).to.equal(true)
            end)

            it("should reject numbers equal to the range bounds", function()
                expect(Base:RangeExclusive(1, 2):Check(1)).to.equal(false)
                expect(Base:RangeExclusive(1, 2):Check(2)).to.equal(false)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1)).to.equal(false)
                expect(FuncRange:Check(2)).to.equal(false)
            end)
        end)

        describe("Positive", function()
            it("should reject non-numbers", function()
                expect(Base:Positive():Check("Test")).to.equal(false)
            end)

            it("should reject negative numbers", function()
                expect(Base:Positive():Check(-1)).to.equal(false)
            end)

            it("should accept positive numbers", function()
                expect(Base:Positive():Check(0)).to.equal(true)
                expect(Base:Positive():Check(1)).to.equal(true)
            end)
        end)

        describe("Negative", function()
            it("should reject non-numbers", function()
                expect(Base:Negative():Check("Test")).to.equal(false)
            end)

            it("should reject positive numbers", function()
                expect(Base:Negative():Check(0)).to.equal(false)
                expect(Base:Negative():Check(1)).to.equal(false)
            end)

            it("should accept negative numbers", function()
                expect(Base:Negative():Check(-1)).to.equal(true)
            end)
        end)

        describe("Equals", function()
            it("should reject non equal inputs", function()
                expect(Base:Equals(1):Check(2)).to.equal(false)
                expect(Base:Equals(function()
                    return 1
                end):Check(2)).to.equal(false)
            end)

            it("should accept equal inputs", function()
                expect(Base:Equals(1):Check(1)).to.equal(true)
                expect(Base:Equals(function()
                    return 1
                end):Check(1)).to.equal(true)
            end)
        end)

        describe("GreaterThan", function()
            it("should reject numbers less than the first arg", function()
                expect(Base:GreaterThan(1):Check(0)).to.equal(false)
                expect(Base:GreaterThan(function()
                    return 1
                end):Check(1)).to.equal(false)
            end)

            it("should accept numbers greater than the first arg", function()
                expect(Base:GreaterThan(1):Check(2)).to.equal(true)
                expect(Base:GreaterThan(function()
                    return 1
                end):Check(2)).to.equal(true)
            end)
        end)

        describe("IsAKeyIn", function()
            it("should reject a non table as first arg", function()
                expect(function()
                    Base:IsAKeyIn(1)
                end).to.throw()

                expect(function()
                    Base:IsAKeyIn("Test")
                end).to.throw()

                expect(function()
                    Base:IsAKeyIn(true)
                end).to.throw()
            end)

            it("should accept a table or function as first arg", function()
                expect(function()
                    Base:IsAKeyIn({})
                end).never.to.throw()

                expect(function()
                    Base:IsAKeyIn(function() end)
                end).never.to.throw()
            end)

            it("should reject when the value does not exist as a key", function()
                expect(Base:IsAKeyIn({}):Check(123)).to.equal(false)
                expect(Base:IsAKeyIn(function()
                    return {}
                end):Check(123)).to.equal(false)
            end)

            it("should accept when the value does exist as a key", function()
                expect(Base:IsAKeyIn({[123] = true}):Check(123)).to.equal(true)
                expect(Base:IsAKeyIn(function()
                    return {[123] = true}
                end):Check(123)).to.equal(true)
            end)
        end)

        describe("IsAValueIn", function()
            it("should reject a non table as first arg", function()
                expect(function()
                    Base:IsAValueIn(1)
                end).to.throw()

                expect(function()
                    Base:IsAValueIn("Test")
                end).to.throw()

                expect(function()
                    Base:IsAValueIn(true)
                end).to.throw()
            end)

            it("should accept a table or function as first arg", function()
                expect(function()
                    Base:IsAValueIn({})
                end).never.to.throw()

                expect(function()
                    Base:IsAValueIn(function() end)
                end).never.to.throw()
            end)

            it("should reject when the value does not exist in an array", function()
                expect(Base:IsAValueIn({}):Check(123)).to.equal(false)
                expect(Base:IsAValueIn(function()
                    return {}
                end):Check(123)).to.equal(false)
            end)

            it("should accept when the value exists in an array", function()
                expect(Base:IsAValueIn({123}):Check(123)).to.equal(true)
                expect(Base:IsAValueIn(function()
                    return {123}
                end):Check(123)).to.equal(true)
            end)
        end)

        describe("IsNaN", function()
            it("should reject normal numbers", function()
                expect(Base:IsNaN():Check(1)).to.equal(false)
            end)

            it("should accept NaN", function()
                expect(Base:IsNaN():Check(math.sqrt(-1))).to.equal(true)
            end)
        end)

        describe("IsInfinite", function()
            it("should reject finite numbers", function()
                expect(Base:IsInfinite():Check(1)).to.equal(false)
            end)

            it("should accept infinite numbers", function()
                expect(Base:IsInfinite():Check(math.huge)).to.equal(true)
                expect(Base:IsInfinite():Check(-math.huge)).to.equal(true)
            end)
        end)

        describe("IsClose", function()
            it("should reject non-numbers", function()
                expect(Base:IsClose(1):Check("Test")).to.equal(false)
            end)

            it("should reject numbers that are not close", function()
                expect(Base:IsClose(1):Check(2)).to.equal(false)
                expect(Base:IsClose(function()
                    return 1
                end):Check(2)).to.equal(false)
            end)

            it("should accept numbers in the default tolerance (0.00001)", function()
                expect(Base:IsClose(1):Check(1 + 0.000001)).to.equal(true)
                expect(Base:IsClose(function()
                    return 1
                end):Check(1 + 0.000001)).to.equal(true)
            end)

            it("should accept a custom tolerance", function()
                expect(Base:IsClose(1, 0.5):Check(1 + 0.4)).to.equal(true)
                expect(Base:IsClose(function()
                    return 1
                end, 0.5):Check(1 + 0.4)).to.equal(true)
            end)
        end)
    end)

    describe("Boolean", function()
        local Base = TypeGuard.Boolean()

        describe("Init", function()
            it("should reject non-booleans", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept booleans", function()
                expect(Base:Check(true)).to.equal(true)
                expect(Base:Check(false)).to.equal(true)
            end)
        end)
    end)

    describe("Instance", function()
        local Base = TypeGuard.Instance()

        describe("Init", function()
            it("should reject non-Instances", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept Instances", function()
                expect(Base:Check(Instance.new("Model"))).to.equal(true)
            end)

            it("should use the IsA constraint as the initial constraint", function()
                local Test = TypeGuard.Instance("Model")

                expect(Test:Check(Instance.new("Model"))).to.equal(true)
                expect(Test:Check(Instance.new("Part"))).to.equal(false)
            end)

            it("should use the IsA constraint + the OfStructure constraint if two values are passed", function()
                local Test = TypeGuard.Instance("Model", {
                    Name = TypeGuard.String():Equals("TestName");
                })

                expect(Test:Check(Instance.new("Model"))).to.equal(false)

                local Sample = Instance.new("Model")
                Sample.Name = "TestName"

                expect(Test:Check(Sample)).to.equal(true)
            end)
        end)

        describe("IsA", function()
            it("should reject non-Instances", function()
                expect(Base:IsA("Folder"):Check("Folder")).to.equal(false)
                expect(Base:IsA("Folder"):Check(1)).to.equal(false)
                expect(Base:IsA("Folder"):Check(function() end)).to.equal(false)
                expect(Base:IsA("Folder"):Check(nil)).to.equal(false)
                expect(Base:IsA("Folder"):Check({})).to.equal(false)
            end)

            it("should accept Instances of the specified type string (or function returning type string)", function()
                expect(Base:IsA("Folder"):Check(Instance.new("Folder"))).to.equal(true)
                expect(Base:IsA(function()
                    return "Folder"
                end):Check(Instance.new("Folder"))).to.equal(true)
            end)

            it("should reject Instances of other classes", function()
                expect(Base:IsA("Folder"):Check(Instance.new("Part"))).to.equal(false)
                expect(Base:IsA(function()
                    return "Folder"
                end):Check(Instance.new("Part"))).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should reject non-Instances", function()
                expect(function()
                    Base:OfStructure({Test = "Test"})
                end).to.throw()

                expect(function()
                    Base:OfStructure({Test = 1})
                end).to.throw()

                expect(function()
                    Base:OfStructure({Test = function() end})
                end).to.throw()
            end)

            it("should accept a map of children and/or properties", function()
                expect(function()
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    })
                end).to.never.throw()
            end)

            it("should reject Instances that do not match the structure", function()
                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    }):Check(Instance.new("Folder"))
                ).to.equal(false)
            end)

            it("should accept Instances that match the structure", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    }):Check(SampleTree)
                ).to.equal(true)
            end)

            it("should reject Instances that do not match the structure recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Part", Test)
                        Test2.Name = "Test2"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder"):OfStructure({
                            Test2 = TypeGuard.Instance():OfStructure({
                                Name = TypeGuard.String():Equals("Incorrect Name");
                            });
                            Name = TypeGuard.String():Equals("Test");
                        });
                        Name = TypeGuard.String():Equals("Folder");
                    }):Check(Test)
                ).to.equal(false)
            end)

            it("should accept Instances that match the structure recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Part", Test)
                        Test2.Name = "Test2"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder"):OfStructure({
                            Test2 = TypeGuard.Instance():OfStructure({
                                Name = TypeGuard.String():Equals("Test2");
                            });
                            Name = TypeGuard.String():Equals("Test");
                        });
                        Name = TypeGuard.String():Equals("Folder");
                    }):Check(Test)
                ).to.equal(false)
            end)
        end)

        describe("StructuralEquals (Strict + OfStructure)", function()
            it("should reject extra flat children", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                    local Test2 = Instance.new("Folder", SampleTree)
                    Test2.Name = "Test2"

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder");
                    }):Check(SampleTree)
                ).to.equal(false)

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder");
                        Test2 = TypeGuard.Instance("Folder");
                    }):Check(SampleTree)
                ).to.equal(true)
            end)

            it("should reject extra children recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Folder", Test)
                        Test2.Name = "Test2"
                        local Test22 = Instance.new("Folder", Test)
                        Test22.Name = "Test22"

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder"):StructuralEquals({
                            Test2 = TypeGuard.Instance("Folder");
                            -- No Test22, should reject
                        });
                    }):Check(SampleTree)
                ).to.equal(false)

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder"):StructuralEquals({
                            Test2 = TypeGuard.Instance("Folder");
                            Test22 = TypeGuard.Instance("Folder");
                        });
                    }):Check(SampleTree)
                ).to.equal(true)
            end)
        end)

        describe("HasTag", function()
            it("should reject non-Instances", function()
                expect(Base:HasTag("Test"):Check("Test")).to.equal(false)
                expect(Base:HasTag("Test"):Check(1)).to.equal(false)
                expect(Base:HasTag("Test"):Check(function() end)).to.equal(false)
                expect(Base:HasTag("Test"):Check(nil)).to.equal(false)
                expect(Base:HasTag("Test"):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified tag", function()
                local Test = Instance.new("Folder")
                CollectionService:AddTag(Test, "TestTag")
                expect(TypeGuard.Instance():HasTag("TestTag"):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasTag(function()
                    return "TestTag"
                end):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified tag", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasTag("TestTag"):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasTag(function()
                    return "TestTag"
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("IsAncestorOf", function()
            it("should reject non-Instances", function()
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check("Test")).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(1)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(function() end)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(nil)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check({})).to.equal(false)
            end)

            it("should accept Instances that are ancestors of the specified Instance", function()
                local Test = Instance.new("Folder")
                local Test2 = Instance.new("Folder", Test)
                local Test3 = Instance.new("Folder", Test2)

                expect(TypeGuard.Instance():IsAncestorOf(Test2):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():IsAncestorOf(Test3):Check(Test)).to.equal(true)

                expect(TypeGuard.Instance():IsAncestorOf(function()
                    return Test2
                end):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():IsAncestorOf(function()
                    return Test3
                end):Check(Test)).to.equal(true)
            end)
        end)

        describe("IsDescendantOf", function()
            it("should reject non-Instances", function()
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check("Test")).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(1)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(function() end)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(nil)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check({})).to.equal(false)
            end)

            it("should accept Instances that are descendants of the specified Instance", function()
                local Test = Instance.new("Folder")
                local Test2 = Instance.new("Folder", Test)
                local Test3 = Instance.new("Folder", Test2)

                expect(TypeGuard.Instance():IsDescendantOf(Test):Check(Test2)).to.equal(true)
                expect(TypeGuard.Instance():IsDescendantOf(Test):Check(Test3)).to.equal(true)

                expect(TypeGuard.Instance():IsDescendantOf(function()
                    return Test
                end):Check(Test2)).to.equal(true)
                expect(TypeGuard.Instance():IsDescendantOf(function()
                    return Test
                end):Check(Test3)).to.equal(true)
            end)
        end)

        describe("HasAttribute", function()
            it("should reject non-strings and non-functions as 1st param", function()
                expect(function()
                    Base:HasAttribute(1)
                end).to.throw()

                expect(function()
                    Base:HasAttribute(true)
                end).to.throw()

                expect(function()
                    Base:HasAttribute(nil)
                end).to.throw()
            end)

            it("should accept a string a 1st param", function()
                expect(function()
                    Base:HasAttribute("Test")
                end).never.to.throw()
            end)

            it("should reject non-Instances on check", function()
                expect(Base:HasAttribute("Test"):Check("Test")).to.equal(false)
                expect(Base:HasAttribute("Test"):Check(1)).to.equal(false)
                expect(Base:HasAttribute("Test"):Check(function() end)).to.equal(false)
                expect(Base:HasAttribute("Test"):Check(nil)).to.equal(false)
                expect(Base:HasAttribute("Test"):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified attribute", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("TestAttribute", true)
                expect(TypeGuard.Instance():HasAttribute("TestAttribute"):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasAttribute(function()
                    return "TestAttribute"
                end):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified attribute", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasAttribute("TestAttribute"):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasAttribute(function()
                    return "TestAttribute"
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("CheckAttribute", function()
            it("should reject non-strings and non-functions as 1st param", function()
                expect(function()
                    Base:CheckAttribute(1)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute(true)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute(nil)
                end).to.throw()
            end)

            it("should reject non-TypeCheckers as 2nd param", function()
                expect(function()
                    Base:CheckAttribute("Test", 1)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute("Test", true)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute("Test", function() end)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute("Test", nil)
                end).to.throw()
            end)

            it("should accept a string & TypeChecker as params", function()
                expect(function()
                    Base:CheckAttribute("Test", TypeGuard.Number())
                end).never.to.throw()
            end)

            it("should reject non-Instances on check", function()
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check("Test")).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check(1)).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check(function() end)).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check(nil)).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified attribute", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("TestAttribute", 123)
                expect(TypeGuard.Instance():CheckAttribute("TestAttribute", TypeGuard.Number()):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():CheckAttribute(function()
                    return "TestAttribute"
                end, TypeGuard.Number()):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified attribute", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():CheckAttribute("TestAttribute", TypeGuard.Number()):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():CheckAttribute(function()
                    return "TestAttribute"
                end, TypeGuard.Number()):Check(Test)).to.equal(false)
            end)
        end)

        describe("HasTags", function()
            it("should reject non-string arrays as first arg", function()
                expect(function()
                    Base:HasTags(1)
                end).to.throw()

                expect(function()
                    Base:HasTags(true)
                end).to.throw()

                expect(function()
                    Base:HasTags(nil)
                end).to.throw()
            end)

            it("should accept a string array as first arg", function()
                expect(function()
                    Base:HasTags({"Test"})
                end).never.to.throw()

                expect(function()
                    Base:HasTags({"Test", "Test2"})
                end).never.to.throw()
            end)

            it("should accept if all the tags are present", function()
                local Test = Instance.new("Folder")
                CollectionService:AddTag(Test, "Test")
                CollectionService:AddTag(Test, "Test2")
                expect(TypeGuard.Instance():HasTags({"Test", "Test2"}):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasTags(function()
                    return {"Test", "Test2"}
                end):Check(Test)).to.equal(true)
            end)

            it("should reject if not all the tags are present", function()
                local Test = Instance.new("Folder")
                CollectionService:AddTag(Test, "Test")
                expect(TypeGuard.Instance():HasTags({"Test", "Test2"}):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasTags(function()
                    return {"Test", "Test2"}
                end):Check(Test)).to.equal(false)
            end)

            it("should reject if none of the tags are present", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasTags({"Test", "Test2"}):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasTags(function()
                    return {"Test", "Test2"}
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("HasAttributes", function()
            it("should reject non-string arrays as first arg", function()
                expect(function()
                    Base:HasAttributes(1)
                end).to.throw()

                expect(function()
                    Base:HasAttributes(true)
                end).to.throw()

                expect(function()
                    Base:HasAttributes(nil)
                end).to.throw()
            end)

            it("should accept a string array as first arg", function()
                expect(function()
                    Base:HasAttributes({"Test"})
                end).never.to.throw()

                expect(function()
                    Base:HasAttributes({"Test", "Test2"})
                end).never.to.throw()
            end)

            it("should accept if all the attributes are present", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("Test", true)
                Test:SetAttribute("Test2", false)
                expect(TypeGuard.Instance():HasAttributes({"Test", "Test2"}):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasAttributes(function()
                    return {"Test", "Test2"}
                end):Check(Test)).to.equal(true)
            end)

            it("should reject if not all the attributes are present", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("Test", 123)
                expect(TypeGuard.Instance():HasAttributes({"Test", "Test2"}):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasAttributes(function()
                    return {"Test", "Test2"}
                end):Check(Test)).to.equal(false)
            end)

            it("should reject if none of the attributes are present", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasAttributes({"Test", "Test2"}):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasAttributes(function()
                    return {"Test", "Test2"}
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("CheckAttributes", function()
            it("should reject non-tables as first arg", function()
                expect(function()
                    Base:CheckAttributes(1)
                end).to.throw()

                expect(function()
                    Base:CheckAttributes(true)
                end).to.throw()

                expect(function()
                    Base:CheckAttributes(nil)
                end).to.throw()
            end)

            it("should reject tables with non-TypeCheckers as values or non-strings as keys", function()
                expect(function()
                    Base:CheckAttributes({TypeGuard.String()})
                end).to.throw()

                expect(function()
                    Base:CheckAttributes({Test = "P"})
                end).to.throw()
            end)

            it("should accept tables with TypeCheckers as values and strings as keys", function()
                expect(function()
                    Base:CheckAttributes({Test = TypeGuard.String()})
                end).never.to.throw()

                expect(function()
                    Base:CheckAttributes({
                        P = TypeGuard.String();
                        Q = TypeGuard.Number();
                    })
                end).never.to.throw()
            end)

            it("should correctly check attribute types", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("Test", "Test")
                Test:SetAttribute("Test2", 123)

                expect(Base:CheckAttributes({
                    Test = TypeGuard.String();
                    Test2 = TypeGuard.Number();
                }):Check(Test)).to.equal(true)

                Test:SetAttribute("Test2", "TestString")

                expect(Base:CheckAttributes({
                    Test = TypeGuard.String();
                    Test2 = TypeGuard.Number();
                }):Check(Test)).to.equal(false)

                Test:SetAttribute("Test2", nil)

                expect(Base:CheckAttributes({
                    Test = TypeGuard.String();
                    Test2 = TypeGuard.Number();
                }):Check(Test)).to.equal(false)
            end)
        end)
    end)

    describe("String", function()
        local Base = TypeGuard.String()

        describe("Init", function()
            it("should accept a string", function()
                expect(Base:Check("Test")).to.equal(true)
            end)

            it("should reject non-strings", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)
        end)

        describe("MinLength", function()
            it("should reject strings shorter than the specified length", function()
                expect(Base:MinLength(5):Check("Test")).to.equal(false)
                expect(Base:MinLength(function()
                    return 5
                end):Check("Test")).to.equal(false)
            end)

            it("should accept strings longer than the specified length", function()
                expect(Base:MinLength(5):Check("Test123")).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check("Test123")).to.equal(true)
            end)

            it("should accept strings equal to the specified length", function()
                expect(Base:MinLength(5):Check("12345")).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check("12345")).to.equal(true)
            end)
        end)

        describe("MaxLength", function()
            it("should reject strings longer than the specified length", function()
                expect(Base:MaxLength(5):Check("Test123")).to.equal(false)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("Test123")).to.equal(false)
            end)

            it("should accept strings shorter than the specified length", function()
                expect(Base:MaxLength(5):Check("Test")).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("Test")).to.equal(true)
            end)

            it("should accept strings equal to the specified length", function()
                expect(Base:MaxLength(5):Check("12345")).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("12345")).to.equal(true)
            end)
        end)

        describe("Pattern", function()
            it("should accept strings matching the specified pattern", function()
                expect(Base:Pattern("[0-9]+"):Check("34789275")).to.equal(true)
                expect(Base:Pattern(function()
                    return "[0-9]+"
                end):Check("34789275")).to.equal(true)
            end)

            it("should reject strings not matching the specified pattern", function()
                expect(Base:Pattern("[0-9]+"):Check("123h4")).to.equal(false)
                expect(Base:Pattern(function()
                    return "[0-9]+"
                end):Check("123h4")).to.equal(false)
            end)
        end)

        describe("Contains", function()
            it("should accept strings containing the specified substring", function()
                expect(Base:Contains("Test"):Check("------Test123")).to.equal(true)
                expect(Base:Contains(function()
                    return "Test"
                end):Check("------Test123")).to.equal(true)
            end)

            it("should reject strings not containing the specified substring", function()
                expect(Base:Contains("Test"):Check("asdfghjkl")).to.equal(false)
                expect(Base:Contains(function()
                    return "Test"
                end):Check("asdfghjkl")).to.equal(false)
            end)
        end)
    end)

    describe("Any", function()
        it("should reject nil values", function()
            expect(TypeGuard.Any():Check(nil)).to.equal(false)
        end)

        it("should accept any non-nil type", function()
            expect(TypeGuard.Any():Check(1)).to.equal(true)
            expect(TypeGuard.Any():Check("Test")).to.equal(true)
            expect(TypeGuard.Any():Check(function() end)).to.equal(true)
            expect(TypeGuard.Any():Check({})).to.equal(true)
            expect(TypeGuard.Any():Check(false)).to.equal(true)
        end)
    end)

    describe("Array", function()
        local Base = TypeGuard.Array()

        describe("Init", function()
            it("should accept an array", function()
                expect(Base:Check({})).to.equal(true)
                expect(Base:Check({1})).to.equal(true)
                expect(Base:Check({1, 2})).to.equal(true)
            end)

            it("should reject non-arrays", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({Test = true})).to.equal(false)
            end)
        end)

        describe("OfLength", function()
            it("should reject arrays shorter than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4})).to.equal(false)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(false)
            end)

            it("should accept arrays longer than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should reject arrays greater than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
            end)
        end)

        describe("MinLength", function()
            it("should reject arrays shorter than the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4})).to.equal(false)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(false)
            end)

            it("should accept arrays equal to the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should accept arrays longer than the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(true)
            end)
        end)

        describe("MaxLength", function()
            it("should reject arrays longer than the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
            end)

            it("should accept arrays equal to the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should accept arrays shorter than the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4})).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(true)
            end)
        end)

        describe("Contains", function()
            it("should accept arrays containing the specified element", function()
                expect(Base:Contains(1):Check({1, 2, 3, 4})).to.equal(true)
                expect(Base:Contains(function()
                    return 1
                end):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject arrays not containing the specified element", function()
                expect(Base:Contains(1):Check({2, 3, 4})).to.equal(false)
                expect(Base:Contains(function()
                    return 1
                end):Check({2, 3, 4})).to.equal(false)
            end)
        end)

        describe("OfType", function()
            it("should accept arrays containing only the specified type", function()
                expect(Base:OfType(TypeGuard.Number()):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject arrays containing elements of other types", function()
                expect(Base:OfType(TypeGuard.Number()):Check({1, "Test", 3, 4})).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should throw for non TypeCheckers inside the template array", function()
                expect(function()
                    Base:OfStructure({1})
                end).to.throw()

                expect(function()
                    Base:OfStructure({function() end})
                end).to.throw()

                expect(function()
                    Base:OfStructure({{}})
                end).to.throw()
            end)

            it("should not throw for TypeCheckers inside the template array", function()
                expect(function()
                    Base:OfStructure({TypeGuard.Number()})
                end).never.to.throw()

                expect(function()
                    Base:OfStructure({TypeGuard.String()})
                end).never.to.throw()

                expect(function()
                    Base:OfStructure({TypeGuard.Array()})
                end).never.to.throw()
            end)

            it("should accept arrays with additional contents", function()
                expect(Base:OfStructure({TypeGuard.Number(), TypeGuard.Number()}):Check({1, 2, 3})).to.equal(true)
            end)

            it("should accept an array of a correct type (numerical)", function()
                expect(Base:OfStructure({
                    TypeGuard.Number(), TypeGuard.Number(),
                    TypeGuard.Number(), TypeGuard.Number()
                }):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject an array of a incorrect type (numerical)", function()
                expect(Base:OfStructure({
                    TypeGuard.Number(), TypeGuard.Number(),
                    TypeGuard.Number(), TypeGuard.Number()
                }):Check({1, 2, "Test", 4})).to.equal(false)
            end)

            it("should check recursively", function()
                expect(Base:OfStructure({
                    [1] = Base:OfStructure({TypeGuard.String()});
                    [2] = Base:OfStructure({TypeGuard.Boolean()});
                }):Check({ {"Test"}, {true} })).to.equal(true)
            end)
        end)

        describe("StructuralEquals (Strict + OfStructure)", function()
            it("should reject arrays with additional contents", function()
                local Checker = Base:StructuralEquals({TypeGuard.Number(), TypeGuard.Number()})
                expect(Checker:Check({1, 2})).to.equal(true)
                expect(Checker:Check({1, 2, 3})).to.equal(false)
            end)
        end)

        describe("IsFrozen", function()
            it("should accept frozen arrays", function()
                local Test = {1, 2, 3}
                table.freeze(Test)
                expect(Base:IsFrozen():Check(Test)).to.equal(true)
            end)

            it("should reject non-frozen arrays", function()
                local Test = {1, 2, 3}
                expect(Base:IsFrozen():Check(Test)).to.equal(false)
            end)
        end)

        describe("IsOrdered", function()
            it("should allow nil params", function()
                expect(function()
                    Base:IsOrdered()
                end).never.to.throw()
            end)

            it("should accept params which are booleans only if not nil (for ascending & descending)", function()
                expect(function()
                    Base:IsOrdered(true)
                    Base:IsOrdered(false)
                end).never.to.throw()

                expect(function()
                    Base:IsOrdered(1)
                end).to.throw()

                expect(function()
                    Base:IsOrdered({})
                end).to.throw()
            end)

            it("should accept single-item arrays", function()
                expect(Base:IsOrdered():Check({1})).to.equal(true)
            end)

            it("should check if an array is ordered as descending", function()
                expect(Base:IsOrdered(true):Check({3, 2, 1})).to.equal(true)
                expect(Base:IsOrdered(true):Check({1, 2, 3})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return true
                end):Check({3, 2, 1})).to.equal(true)
                expect(Base:IsOrdered(function()
                    return true
                end):Check({1, 2, 3})).to.equal(false)
            end)

            it("should check if an array is ordered as ascending", function()
                expect(Base:IsOrdered(false):Check({1, 2, 3})).to.equal(true)
                expect(Base:IsOrdered(false):Check({3, 2, 1})).to.equal(false)
                expect(Base:IsOrdered():Check({1, 2, 3})).to.equal(true)
                expect(Base:IsOrdered():Check({3, 2, 1})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return false
                end):Check({1, 2, 3})).to.equal(true)
                expect(Base:IsOrdered(function()
                    return false
                end):Check({3, 2, 1})).to.equal(false)
            end)

            it("should reject non ordered arrays", function()
                expect(Base:IsOrdered(false):Check({1, 2, 4, 3})).to.equal(false)
                expect(Base:IsOrdered(true):Check({1, 2, 4, 3})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return false
                end):Check({1, 2, 4, 3})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return true
                end):Check({1, 2, 4, 3})).to.equal(false)
            end)
        end)
    end)

    describe("Nil", function()
        describe("Init", function()
            it("should accept nil", function()
                expect(TypeGuard.Nil():Check(nil)).to.equal(true)
            end)

            it("should reject non-nil", function()
                expect(TypeGuard.Nil():Check(1)).to.equal(false)
                expect(TypeGuard.Nil():Check(function() end)).to.equal(false)
                expect(TypeGuard.Nil():Check({})).to.equal(false)
                expect(TypeGuard.Nil():Check(false)).to.equal(false)
            end)
        end)
    end)

    describe("Enum", function()
        describe("Init", function()
            it("should throw given non-EnumItem, non-Enum values", function()
                expect(function()
                    TypeGuard.Enum(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Enum(true)
                end).to.throw()

                expect(function()
                    TypeGuard.Enum({})
                end).to.throw()
            end)

            it("should not throw given EnumItem or Enum (or function) values", function()
                expect(function()
                    TypeGuard.Enum(Enum.AccessoryType)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Enum(Enum.AccessoryType.Shirt)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Enum(function()
                        return Enum.AccessoryType.Shirt
                    end)
                end).never.to.throw()
            end)
        end)

        describe("IsA", function()
            it("should accept an Enum item if the respective EnumItem is a sub-item", function()
                expect(TypeGuard.Enum(Enum.AccessoryType):Check(Enum.AccessoryType.Shirt)).to.equal(true)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType
                end):Check(Enum.AccessoryType.Shirt)).to.equal(true)
            end)

            it("should reject EnumItems which are not part of the Enum class", function()
                expect(TypeGuard.Enum(Enum.AccessoryType):Check(Enum.AlphaMode.Overlay)).to.equal(false)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType
                end):Check(Enum.AlphaMode.Overlay)).to.equal(false)
            end)

            it("should accept EnumItems which are equal", function()
                expect(TypeGuard.Enum(Enum.AccessoryType.Face):Check(Enum.AccessoryType.Face)).to.equal(true)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType.Face
                end):Check(Enum.AccessoryType.Face)).to.equal(true)
            end)
        end)
    end)

    describe("Thread", function()
        local Base = TypeGuard.Thread()

        describe("Init", function()
            it("should reject non-thread values", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept thread values", function()
                expect(Base:Check(coroutine.create(function() end))).to.equal(true)
            end)
        end)

        describe("HasStatus", function()
            it("should accept running threads given 'running'", function()
                local Thread = coroutine.running()

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(true)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(true)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
            end)

            it("should accept suspended threads given 'suspended'", function()
                local Thread = task.spawn(function()
                    task.wait(1)
                end)

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(true)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(true)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
            end)

            it("should accept threads given 'dead'", function()
                local Thread = task.spawn(function() end)

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(true)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(true)
            end)

            it("should accept threads given 'normal'", function()
                local DidRun = false
                local TestCoroutine = coroutine.create(function(Callback)
                    Callback()
                end)

                task.spawn(function()
                    local Thread = coroutine.running()

                    task.spawn(TestCoroutine, function()
                        expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus("normal"):Check(Thread)).to.equal(true)
                        expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                        expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(true)
                        expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
                        DidRun = true
                    end)
                end)

                expect(DidRun).to.equal(true)
            end)
        end)
    end)

    describe("Object", function()
        local Base = TypeGuard.Object()

        describe("Init", function()
            it("should reject non-object values", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check({1})).to.equal(false)
            end)

            it("should accept object values", function()
                expect(Base:Check({})).to.equal(true)
                expect(Base:Check({Test = 123})).to.equal(true)
                expect(Base:Check({Test = false})).to.equal(true)
            end)
        end)

        describe("OfValueType", function()
            it("should accept an object with the given value type", function()
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = 123})).to.equal(true)
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = 123, Another = 987})).to.equal(true)
            end)

            it("should reject an object with a different value type", function()
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test1 = 123, Test2 = "123"})).to.equal(false)
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = "123", Another = "987"})).to.equal(false)
            end)
        end)

        describe("OfKeyType", function()
            it("should accept an object with the given key type", function()
                expect(Base:OfKeyType(TypeGuard.String()):Check({Test = 123})).to.equal(true)
                expect(Base:OfKeyType(TypeGuard.String()):Check({Test = 123, Another = 987})).to.equal(true)
            end)

            it("should reject an object with a different key type", function()
                expect(Base:OfKeyType(TypeGuard.String()):Check({[{}] = true})).to.equal(false)
                expect(Base:OfKeyType(TypeGuard.String()):Check({[Instance.new("Part")] = true})).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should accept an object with the given structure", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true})).to.equal(true)
            end)

            it("should reject an object with a different structure", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = "true"})).to.equal(false)
            end)

            it("should accept additional fields when not in strict mode", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true, Test2 = "123"})).to.equal(true)
            end)

            it("should recurse given sub object TypeCheckers", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Object({
                        Test = TypeGuard.Number(),
                        Another = TypeGuard.Boolean()
                    })
                }):Check({Test = {Test = 123, Another = true}})).to.equal(true)
            end)
        end)

        describe("StructuralEquals (OfStructure + Strict)", function()
            it("should accept an object with the given structure", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true})).to.equal(true)
            end)

            it("should reject an object with a different structure", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = "true"})).to.equal(false)
            end)

            it("should reject additional fields when not in strict mode", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true, Test2 = "123"})).to.equal(false)
            end)

            it("should recurse given sub object TypeCheckers but not enforce strict recursively", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Object({
                        Test = TypeGuard.Number(),
                        Another = TypeGuard.Boolean()
                    })
                }):Check({Test = {Test = 123, Another = true, Final = {}}})).to.equal(true)
            end)
        end)

        describe("IsFrozen", function()
            it("should accept frozen objects", function()
                local Test = {X = 1, Y = 2, Z = 3}
                table.freeze(Test)
                expect(Base:IsFrozen():Check(Test)).to.equal(true)
            end)

            it("should reject non-frozen objects", function()
                local Test = {X = 1, Y = 2, Z = 3}
                expect(Base:IsFrozen():Check(Test)).to.equal(false)
            end)
        end)

        describe("CheckMetatable", function()
            it("should reject non-TypeCheckers", function()
                expect(function()
                    Base:CheckMetatable(1)
                end).to.throw()

                expect(function()
                    Base:CheckMetatable(function() end)
                end).to.throw()

                expect(function()
                    Base:CheckMetatable({})
                end).to.throw()

                expect(function()
                    Base:CheckMetatable(Instance.new("Part"))
                end).to.throw()
            end)

            it("should run the provided TypeChecker on the metatable", function()
                local Test = {}
                local MT = {__index = Test}
                setmetatable(Test, MT)

                expect(Base:CheckMetatable(Base:Equals(MT)):Check(Test)).to.equal(true)
                expect(Base:CheckMetatable(TypeGuard.Number()):Check(Test)).to.equal(false)
            end)
        end)

        describe("OfClass", function()
            it("should reject non-tables", function()
                expect(function()
                    Base:CheckMetatable(1)
                end).to.throw()

                expect(function()
                    Base:CheckMetatable(function() end)
                end).to.throw()

                expect(function()
                    Base:CheckMetatable(Instance.new("Part"))
                end).to.throw()
            end)

            it("should reject tables which are not intended to be an __index metatable", function()
                local Test = {}

                expect(function()
                    Base:OfClass(Test)
                end).to.throw()
            end)

            it("should accept tables which are intended to be an __index metatable", function()
                local Test = {__index = {}}

                expect(function()
                    Base:OfClass(Test)
                end).never.to.throw()
            end)

            it("should accept tables with the metatable equivalent to the provided class", function()
                local Test = {}
                Test.__index = Test

                local Object = setmetatable({}, Test)
                expect(Base:OfClass(Test):Check(Object)).to.equal(true)
            end)

            it("should reject tables with the metatable not equivalent to the provided class", function()
                local Test = {}
                Test.__index = Test

                local Test2 = {}
                Test2.__index = Test2

                local Object = setmetatable({}, Test)
                expect(Base:OfClass(Test2):Check(Object)).to.equal(false)
            end)

            it("should reject tables with no metatable", function()
                local Test = {}
                Test.__index = Test

                local Test2 = {}
                Test2.__index = Test2

                local Object = setmetatable({}, Test)
                expect(Base:OfClass(Test2):Check(Object)).to.equal(false)
            end)
        end)
    end)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f57c</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="74">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tpc9000_xsignal@0.1.0</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f57d</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="75">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TypeGuard</string>
						<string name="ScriptGuid">{560D56B0-FFFB-499F-9D98-4817CE0CD336}</string>
						<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["tpc9000_typeguard@2.3.0"]["typeguard"])
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f57e</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="76">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">xsignal</string>
						<string name="ScriptGuid">{F966DE93-E183-4875-A4CB-7F56F78E8F19}</string>
						<ProtectedString name="Source"><![CDATA[local Connection = require(script.Connection)
local TypeGuard = require(script.Parent:WaitForChild("TypeGuard"))

local function BLANK_FUNCTION() end

local CHECK_TYPES = true

local DEFAULT_AWAIT_FIRST_TIMEOUT_SECONDS = 60
local DEFAULT_AWAIT_ALL_TIMEOUT_SECONDS = 60
local DEFAULT_WAIT_TIMEOUT_SECONDS = 60

local ERR_CONNECTION_ALREADY_CREATED = "Connection already created in slot %d"
local ERR_WAIT_TIMEOUT = "Wait call timed out (time elapsed: %d)"

local EMPTY_TABLE = {}

local GenericSignalTypeChecker = TypeGuard.Object({
    Connect = TypeGuard.Function();
    Wait = TypeGuard.Function();
    Fire = TypeGuard.Function();
}):Or(TypeGuard.RBXScriptSignal())

export type XSignal<T...> = {
    WaitNoTimeout: ((XSignal<T...>) -> (T...));
    Connect: ((XSignal<T...>, ((T...) -> ())) -> (Connection.Connection));
    Once: ((XSignal<T...>, ((T...) -> ())) -> (Connection.Connection));
    Fire: ((XSignal<T...>, T...) -> ());
    Wait: ((XSignal<T...>, number?, boolean?) -> (T...));
}

type GenericConnection = RBXScriptConnection | {
    Disconnect: (GenericConnection) -> ();
}
type GenericSignal = RBXScriptSignal | {
    Connect: (GenericSignal, any...) -> GenericConnection;
    Wait: (GenericSignal, any...) -> any...;
    Fire: (GenericSignal, any...) -> ();
}

local XSignal = {}
XSignal.__index = XSignal

local NewParams = TypeGuard.Params(TypeGuard.Function():Optional())
--- Constructs a new XSignal.
function XSignal.new(ImmediateFire: () -> (...any))
    if (CHECK_TYPES) then
        NewParams(ImmediateFire)
    end

    local self = setmetatable({
        _ConnectionCount = 0;

        _HeadConnection = nil;
        _ImmediateFire = ImmediateFire;

        _OnConnectionsEmpty = BLANK_FUNCTION;
        _OnConnectionsPresent = BLANK_FUNCTION;
    }, XSignal)

    self.Event = self -- Easy to port BindableEvents over in existing codebases

    return self
end

local ConnectParams = TypeGuard.Params(TypeGuard.Function():Optional())
--- Creates a new connection object given a callback function, which is called when the XSignal is fired.
function XSignal:Connect(Callback)
    if (CHECK_TYPES) then
        ConnectParams(Callback)
    end

    local NewConnection = Connection.new(self, Callback)
    NewConnection:Reconnect()

    local ImmediateFire = self._ImmediateFire

    if (ImmediateFire) then
        ImmediateFire(function(...)
            task.spawn(Callback, ...)
        end)
    end

    return NewConnection
end
XSignal.connect = XSignal.Connect

local OnceParams = TypeGuard.Params(TypeGuard.Function():Optional())
--- Connects the XSignal once and then disconnects
function XSignal:Once(Callback)
    if (CHECK_TYPES) then
        OnceParams(Callback)
    end

    local NewConnection; NewConnection = self:Connect(function(...)
        NewConnection:Disconnect()
        Callback(...)
    end)

    return NewConnection
end

--- Fires the XSignal, calling all connected callbacks in their own coroutine.
function XSignal:Fire(...)
    debug.profilebegin("XSignal.Fire")

    -- Resume all of the connections
    local Head = self._HeadConnection

    while (Head) do
        task.spawn(Head.Callback, ...)
        Head = Head._Next
    end

    debug.profileend()
end
XSignal.fire = XSignal.Fire

local WaitParams = TypeGuard.Params(TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())
--- Yields the current coroutine until the XSignal is fired, returning all data passed when the XSignal was fired.
function XSignal:Wait(Timeout, ThrowErrorOnTimeout)
    if (CHECK_TYPES) then
        WaitParams(Timeout, ThrowErrorOnTimeout)
    end

    Timeout = Timeout or DEFAULT_WAIT_TIMEOUT_SECONDS

    local ActiveCoroutine = coroutine.running()
    local Temp; Temp = self:Connect(function(...)
        -- Could return immediately from ImmediateFire, which would cause coroutine library error, so we check here
        local Args = {...}

        if (self._ImmediateFire) then

            task.defer(function()
                task.spawn(ActiveCoroutine, Args)
                Temp:Disconnect()
            end)

            return
        end

        task.spawn(ActiveCoroutine, Args)
        Temp:Disconnect()
    end)

    local DidTimeout = false
    local DidResume = false

    task.delay(Timeout, function()
        -- Could time out at a later point, so once we resume we know it is only yielding for this & can reject in future
        if (DidResume) then
            return
        end

        DidTimeout = true
        Temp:Disconnect() -- Safe for coroutine.close to be called
        task.spawn(ActiveCoroutine, EMPTY_TABLE)
    end)

    local Result = coroutine.yield()
    DidResume = true

    if (DidTimeout and ThrowErrorOnTimeout) then
        error(ERR_WAIT_TIMEOUT:format(Timeout))
    end

    return unpack(Result)
end
XSignal.wait = XSignal.Wait

-- Yields the XSignal indefinitely until it fires
function XSignal:WaitNoTimeout()
    local ActiveCoroutine = coroutine.running()
    local Temp; Temp = self:Connect(function(...)
        local Args = {...}

        if (self._ImmediateFire) then

            task.defer(function()
                task.spawn(ActiveCoroutine, Args)
                Temp:Disconnect()
            end)

            return
        end

        task.spawn(ActiveCoroutine, Args)
        Temp:Disconnect()
    end)

    return unpack(coroutine.yield())
end
XSignal.waitNoTimeout = XSignal.WaitNoTimeout

--- Flushes all connections from the Signal.
function XSignal:Destroy()
    self._HeadConnection = nil
    self._ConnectionCount = 0
    self._OnConnectionsEmpty()
end
XSignal.destroy = XSignal.Destroy
XSignal.DisconnectAll = XSignal.Destroy
XSignal.disconnectAll = XSignal.Destroy

local AwaitLikeParams = TypeGuard.Params(TypeGuard.Array(GenericSignalTypeChecker):MinLength(1), TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())
--- Awaits the completion of the first XSignal object and returns its fired data.
function XSignal.AwaitFirst(Signals: {GenericSignal}, Timeout: number?, ThrowErrorOnTimeout: boolean?): ...any
    if (CHECK_TYPES) then
        AwaitLikeParams(Signals, Timeout, ThrowErrorOnTimeout)
    end

    Timeout = Timeout or DEFAULT_AWAIT_FIRST_TIMEOUT_SECONDS

    local ActiveCoroutine = coroutine.running()
    local Connections = table.create(#Signals)

    for Index, Value in Signals do
        Connections[Index] = Value:Connect(function(...)
            task.spawn(ActiveCoroutine, ...)
        end)
    end

    local DidTimeout = false
    local DidResume = false

    task.delay(Timeout, function()
        if (DidResume) then
            return
        end

        DidTimeout = true

        for _, SubConnection in Connections do
            SubConnection:Disconnect()
        end

        task.spawn(ActiveCoroutine)
    end)

    local Result = {coroutine.yield()}
    DidResume = true

    for _, SubConnection in Connections do
        SubConnection:Disconnect()
    end

    if (DidTimeout and ThrowErrorOnTimeout) then
        error(ERR_WAIT_TIMEOUT:format(Timeout))
    end

    return unpack(Result)
end
XSignal.awaitFirst = XSignal.AwaitFirst

--- Awaits the completion of all Signal objects and returns their fired data in sub-arrays (for multiple arguments).
--- Return order is maintained for the Signals passed in.
function XSignal.AwaitAll(Signals: {GenericSignal}, Timeout: number?, ThrowErrorOnTimeout: boolean?): {{any}}
    if (CHECK_TYPES) then
        AwaitLikeParams(Signals, Timeout, ThrowErrorOnTimeout)
    end

    Timeout = Timeout or DEFAULT_AWAIT_ALL_TIMEOUT_SECONDS

    local TargetCount = #Signals
    local Result = table.create(TargetCount)
    local Connections = table.create(TargetCount)
    local ActiveCoroutine = coroutine.running()
    local Count = 0

    local DidTimeout = false
    local DidResume = false

    task.delay(Timeout, function()
        if (DidResume) then
            return
        end

        DidTimeout = true

        for _, SubConnection in Connections do
            SubConnection:Disconnect()
        end

        task.spawn(ActiveCoroutine)
    end)

    for Index, Value in Signals do
        local TempConnection; TempConnection = Value:Connect(function(...)
            TempConnection:Disconnect()
            Result[Index] = {...}
            Count += 1

            if (Count == TargetCount) then
                task.spawn(ActiveCoroutine)
            end
        end)

        table.insert(Connections, TempConnection)
    end

    coroutine.yield()
    DidResume = true

    if (DidTimeout and ThrowErrorOnTimeout) then
        error(ERR_WAIT_TIMEOUT:format(Timeout))
    end

    return Result
end
XSignal.awaitAll = XSignal.AwaitAll

--- Awaits the completion of all Signal objects and returns the first item of each of their arguments in an array.
--- Return order is maintained for the Signals passed in.
function XSignal.AwaitAllFirstArg(Signals: {GenericSignal}, Timeout: number?, ThrowErrorOnTimeout: boolean?): {any}
    if (CHECK_TYPES) then
        AwaitLikeParams(Signals, Timeout, ThrowErrorOnTimeout)
    end

    local Result = XSignal.AwaitAll(Signals, Timeout, ThrowErrorOnTimeout)
    local Reformatted = table.create(#Result)

    for Index, Value in Result do
        Reformatted[Index] = Value[1]
    end

    return Reformatted
end
XSignal.awaitAllFirstArg = XSignal.AwaitAllFirstArg

local ExtendParams = TypeGuard.Params(TypeGuard.Array(GenericSignalTypeChecker):MinLength(1))
--- Watches multiple other Signal objects and replicates firing through any of them.
function XSignal.Extend(Signals: {GenericSignal}, ...)
    if (CHECK_TYPES) then
        ExtendParams(Signals)
    end

    local NewSignal = XSignal.new(...)
    local ConnectionsList = table.create(#Signals)

    -- Unhook provided signals on object destruction
    NewSignal._OnConnectionsEmpty = function()
        for Index, SubConnection in ConnectionsList do
            SubConnection:Disconnect()
            ConnectionsList[Index] = nil
        end
    end

    -- Hook into all provided signals
    NewSignal._OnConnectionsPresent = function()
        for Index, SubSignal in Signals do
            assert(ConnectionsList[Index] == nil, ERR_CONNECTION_ALREADY_CREATED:format(Index))

            ConnectionsList[Index] = SubSignal:Connect(function(...)
                NewSignal:Fire(...)
            end)
        end
    end

    return NewSignal
end
XSignal.extend = XSignal.Extend

return XSignal]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f57f</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="77">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Connection</string>
							<string name="ScriptGuid">{649836AF-48F2-47A5-976A-634C3A9E17EA}</string>
							<ProtectedString name="Source"><![CDATA[export type Connection = {
    Connected: boolean,

    Disconnect: ((Connection) -> ()),
    Reconnect: ((Connection) -> ()),
}

local Connection = {}
Connection.__index = Connection

function Connection.new(SignalObject, Callback)
    return setmetatable({
        Connected = false;
        Callback = Callback;

        _Signal = SignalObject;
        _Next = nil;
    }, Connection)
end

function Connection:Disconnect()
    if (not self.Connected) then
        return
    end

    local SignalRef = self._Signal
    local Temp = SignalRef._HeadConnection

    if (Temp == nil) then
        return
    end

    if (Temp == self) then
        SignalRef._HeadConnection = self._Next
    else
        while (Temp._Next ~= self) do
            Temp = Temp._Next
        end

        Temp._Next = self._Next
    end

    ---------------------------------------------

    SignalRef._ConnectionCount -= 1

    if (SignalRef._ConnectionCount == 0) then
        SignalRef._HeadConnection = nil
        SignalRef._OnConnectionsEmpty()
    end

    self.Connected = false
end

function Connection:Reconnect()
    if (self.Connected) then
        return
    end

    local SignalRef = self._Signal
    local Head = SignalRef._HeadConnection

    if (Head) then
        self._Next = Head
        SignalRef._HeadConnection = self
    else
        SignalRef._HeadConnection = self
    end

    ---------------------------------------------

    SignalRef._ConnectionCount += 1

    if (SignalRef._ConnectionCount == 1) then
        SignalRef._OnConnectionsPresent()
    end

    self.Connected = true
end

return Connection]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f580</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="78">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">init.spec</string>
							<string name="ScriptGuid">{B4F0252F-85CF-4553-BAC3-A2C83572C436}</string>
							<ProtectedString name="Source"><![CDATA[return function()
    local XSignal = require(script.Parent)

    describe("XSignal.new", function()
        it("should construct", function()
            expect(function()
                XSignal.new()
            end).never.to.throw()
        end)

        it("should reject non-function types as first arg", function()
            expect(function()
                XSignal.new(1)
            end).to.throw()
        end)

        it("should accept a function as first arg", function()
            expect(function()
                XSignal.new(function() end)
            end).never.to.throw()
        end)
    end)

    describe("XSignal.Connect", function()
        it("should throw when not given a function", function()
            expect(function()
                XSignal.new():Connect(1)
            end).to.throw()
        end)

        it("should accept a callback", function()
            expect(function()
                XSignal.new():Connect(function() end)
            end).never.to.throw()
        end)

        it("should accept multiple callbacks", function()
            expect(function()
                local Test = XSignal.new()
                Test:Connect(function() end)
                Test:Connect(function() end)
                Test:Connect(function() end)
            end).never.to.throw()
        end)

        it("should allow disconnection", function()
            local Test = XSignal.new()

            local X = Test:Connect(function() end)
            local Y = Test:Connect(function() end)
            local Z = Test:Connect(function() end)

            expect(X.Disconnect).to.be.a("function")
            expect(Y.Disconnect).to.be.a("function")
            expect(Z.Disconnect).to.be.a("function")

            expect(function()
                X:Disconnect()
                Y:Disconnect()
                Z:Disconnect()
            end).never.to.throw()
        end)
    end)

    describe("XSignal.Connect(ImmediateFire)", function()
        it("should immediately fire for new connections using callback (in order)", function()
            local Test = XSignal.new(function(Callback)
                Callback(1, 2)
                Callback(3, 4)
                Callback(5, 6)
            end)

            local Results = {}

            Test:Connect(function(Num1, Num2)
                table.insert(Results, Num1)
                table.insert(Results, Num2)
            end)

            expect(table.concat(Results)).to.equal("123456")
        end)
    end)

    describe("XSignal.Once", function()
        -- TODO
    end)

    describe("XSignal.Fire", function()
        it("should execute a connection", function()
            local Test = XSignal.new()
            local FiredCount = 0

            Test:Connect(function()
                FiredCount += 1
            end)

            expect(FiredCount).to.equal(0)
            Test:Fire()
            expect(FiredCount).to.equal(1)
        end)

        it("should execute multiple connections", function()
            local Test = XSignal.new()
            local FiredCount = 0

            Test:Connect(function()
                FiredCount += 1
            end)

            Test:Connect(function()
                FiredCount += 1
            end)

            Test:Connect(function()
                FiredCount += 1
            end)

            expect(FiredCount).to.equal(0)
            Test:Fire()
            expect(FiredCount).to.equal(3)
        end)

        it("should execute multiple connections async", function()
            local Test = XSignal.new()
            local FiredCount = 0

            Test:Connect(function()
                task.wait(0.1)
                FiredCount += 1
            end)

            Test:Connect(function()
                task.wait(0.1)
                FiredCount += 1
            end)

            expect(FiredCount).to.equal(0)
            Test:Fire()
            expect(FiredCount).to.equal(0)
            task.wait(0.1)
            expect(FiredCount).to.equal(2)
        end)

        it("should pass primitive data types", function()
            local Test = XSignal.new()

            Test:Connect(function(X, Y, Z)
                expect(X).to.equal(1)
                expect(Y).to.equal("s")
                expect(Z).to.equal(true)
            end)

            Test:Fire(1, "s", true)
        end)

        it("should pass objects", function()
            local Test = XSignal.new()
            local Pass1 = {}
            local Pass2 = {}

            Test:Connect(function(X, Y)
                expect(X).to.equal(Pass1)
                expect(Y).to.equal(Pass2)
            end)

            Test:Fire(Pass1, Pass2)
        end)

        it("should not execute disconnected connections", function()
            local Test = XSignal.new()
            local RunCount = 0

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end):Disconnect()

            Test:Fire()
            expect(RunCount).to.equal(2)
        end)
    end)

    describe("XSignal.Wait", function()
        it("should yield until the XSignal is fired", function()
            local Test = XSignal.new()

            task.delay(0.1, function()
                Test:Fire()
            end)

            Test:Wait()
        end)

        it("should timeout and pass nil if no error is desired", function()
            local Test = XSignal.new()
            expect(Test:Wait(0.1)).to.equal(nil)
        end)

        it("should timeout and throw if an error is desired", function()
            local Test = XSignal.new()

            expect(pcall(function()
                Test:Wait(0.1, true)
            end)).to.equal(false)
        end)

        it("should return the data passed to the XSignal", function()
            local Test = XSignal.new()
            local TestObject = {}

            task.defer(function()
                Test:Fire(1, TestObject)
            end)

            local Primitive, Object = Test:Wait()
            expect(Primitive).to.equal(1)
            expect(Object).to.equal(TestObject)
        end)

        it("should return immediately with ImmediateFire", function()
            local TestObject = {}
            local Test = XSignal.new(function(Callback)
                Callback(3210, TestObject)
            end)

            local Primitive, Object = Test:Wait(0.1, true)
            expect(Primitive).to.equal(3210)
            expect(Object).to.equal(TestObject)
        end)
    end)

    describe("XSignal.WaitNoTimeout", function()
        it("should yield until the XSignal is fired", function()
            local Test = XSignal.new()

            task.delay(0.1, function()
                Test:Fire()
            end)

            Test:WaitNoTimeout()
        end)

        it("should return the data passed to the XSignal", function()
            local Test = XSignal.new()
            local TestObject = {}

            task.defer(function()
                Test:Fire(1, TestObject)
            end)

            local Primitive, Object = Test:WaitNoTimeout()
            expect(Primitive).to.equal(1)
            expect(Object).to.equal(TestObject)
        end)
    end)

    describe("XSignal.DisconnectAll", function()
        it("should wipe all connections", function()
            local Test = XSignal.new()
            local RunCount = 0

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end)

            expect(RunCount).to.equal(0)
            Test:DisconnectAll()
            Test:Fire()
            expect(RunCount).to.equal(0)
        end)
    end)

    describe("XSignal.Extend", function()
        it("should throw when no XSignals to extend are passed", function()
            expect(function()
                XSignal.Extend()
            end).to.throw()

            expect(function()
                XSignal.Extend({})
            end).to.throw()
        end)

        it("should create a new XSignal which replicates firing from a single XSignal", function()
            local TestObject = {}
            local SubSignal = XSignal.new()
            local Test = XSignal.Extend({SubSignal})

            local Data

            Test:Connect(function(...)
                Data = {...}
            end)

            SubSignal:Fire(1, TestObject)

            expect(Data).to.be.ok()
            expect(Data).to.be.a("table")
            expect(Data[1]).to.equal(1)
            expect(Data[2]).to.equal(TestObject)
        end)

        it("should create a new XSignal which replicates firing from multiple XSignals", function()
            local TestObject1 = {}
            local TestObject2 = {}

            local SubSignal1 = XSignal.new()
            local SubSignal2 = XSignal.new()

            local Test = XSignal.Extend({SubSignal1, SubSignal2})

            local Data

            Test:Connect(function(...)
                Data = {...}
            end)

            SubSignal1:Fire(1, TestObject1)
            expect(Data).to.be.ok()
            expect(Data).to.be.a("table")
            expect(Data[1]).to.equal(1)
            expect(Data[2]).to.equal(TestObject1)

            SubSignal1:Fire(2, TestObject2)
            expect(Data).to.be.ok()
            expect(Data).to.be.a("table")
            expect(Data[1]).to.equal(2)
            expect(Data[2]).to.equal(TestObject2)
        end)
    end)

    describe("XSignal.AwaitFirst", function()
        it("should throw for incorrect args", function()
            expect(function()
                XSignal.AwaitFirst()
            end).to.throw()

            expect(function()
                XSignal.AwaitFirst({})
            end).to.throw()

            expect(function()
                XSignal.AwaitFirst({XSignal.new()}, "")
            end).to.throw()

            expect(function()
                XSignal.AwaitFirst({XSignal.new()}, 0.1, "")
            end).to.throw()
        end)

        it("should timeout and pass nil if no error is desired", function()
            expect(XSignal.AwaitFirst({XSignal.new()}, 0.1)).to.equal(nil)
        end)

        it("should timeout and throw if an error is desired", function()
            expect(function()
                XSignal.AwaitFirst({XSignal.new()}, 0.1, true)
            end).to.throw()
        end)

        it("should resume a coroutine with the first XSignal to fire", function()
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()

            task.delay(0.1, function()
                Signal1:Fire()
            end)

            XSignal.AwaitFirst({Signal1, Signal2})

            task.delay(0.1, function()
                Signal2:Fire()
            end)

            XSignal.AwaitFirst({Signal1, Signal2})
        end)

        it("should return the standard 'Wait' data passed from the wrapped XSignal", function()
            local TestObject = {}
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()

            task.delay(0.1, function()
                Signal1:Fire(1, TestObject)
            end)

            local X, Y = XSignal.AwaitFirst({Signal1, Signal2})
            expect(X).to.equal(1)
            expect(Y).to.equal(TestObject)
        end)
    end)

    describe("XSignal.AwaitAll", function()
        it("should throw for incorrect args", function()
            expect(function()
                XSignal.AwaitAll()
            end).to.throw()

            expect(function()
                XSignal.AwaitAll({})
            end).to.throw()

            expect(function()
                XSignal.AwaitAll({XSignal.new()}, "")
            end).to.throw()

            expect(function()
                XSignal.AwaitAll({XSignal.new()}, 0.1, "")
            end).to.throw()
        end)

        it("should timeout and pass a blank array if no error is desired", function()
            expect(next(XSignal.AwaitAll({XSignal.new()}, 0.1))).to.equal(nil)
        end)

        it("should timeout and throw if an error is desired", function()
            expect(function()
                XSignal.AwaitAll({XSignal.new()}, 0.1, true)
            end).to.throw()
        end)

        it("should await all XSignals, not just one", function()
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()
            local Running = coroutine.running()

            task.delay(0.1, function()
                Signal1:Fire()
                expect(coroutine.status(Running)).to.equal("suspended")

                task.wait(0.1)
                Signal2:Fire()
            end)

            XSignal.AwaitAll({Signal1, Signal2})
        end)

        it("should return the standard 'Wait' data passed from the wrapped XSignals, in a two-dimensional array format, in the order they were passed into the function", function()
            local TestObject = {}
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()
            local Running = coroutine.running()

            task.delay(0.1, function()
                Signal1:Fire(1, TestObject)
                expect(coroutine.status(Running)).to.equal("suspended")

                task.wait(0.1)
                Signal2:Fire(2, TestObject)
            end)

            local Results = XSignal.AwaitAll({Signal1, Signal2})
            expect(Results).to.be.ok()
            expect(Results).to.be.a("table")
            expect(Results[1]).to.be.ok()
            expect(Results[1]).to.be.a("table")
            expect(Results[1][1]).to.equal(1)
            expect(Results[1][2]).to.equal(TestObject)
            expect(Results[2]).to.be.ok()
            expect(Results[2]).to.be.a("table")
            expect(Results[2][1]).to.equal(2)
            expect(Results[2][2]).to.equal(TestObject)
        end)
    end)

    describe("XSignal.AwaitAllFirstArg", function()
        it("should return the standard 'Wait' data passed from the wrapped XSignals, in a one-dimensional array format, in the order they were passed into the function", function()
            local TestObject = {}
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()
            local Running = coroutine.running()

            task.delay(0.1, function()
                Signal1:Fire(1, TestObject)
                expect(coroutine.status(Running)).to.equal("suspended")

                task.wait(0.1)
                Signal2:Fire(2, TestObject)
            end)

            local Results = XSignal.AwaitAllFirstArg({Signal1, Signal2})
            expect(Results).to.be.ok()
            expect(Results).to.be.a("table")
            expect(Results[1]).to.be.ok()
            expect(Results[1]).to.be.a("number")
            expect(Results[1]).to.equal(1)
            expect(Results[2]).to.be.ok()
            expect(Results[2]).to.be.a("number")
            expect(Results[2]).to.equal(2)
        end)
    end)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f581</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXA27E53878689471393A3A178314667FC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Vapor</string>
				<string name="ScriptGuid">{C99A56AC-18C8-44FC-A96A-F2E5879401FE}</string>
				<ProtectedString name="Source"><![CDATA[return {
    GeneralStore = require(script:WaitForChild("GeneralStore"));
    StoreInterface = require(script:WaitForChild("StoreInterface"));
    ReplicatedStore = require(script:WaitForChild("ReplicatedStore"));
    InstanceReplication = require(script:WaitForChild("InstanceReplication"));
};]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6f4</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX9801DCF9EA104CE99E59F2A1408BEEAE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GeneralStore</string>
					<string name="ScriptGuid">{BD047D12-5C7A-476A-887A-4990BED43178}</string>
					<ProtectedString name="Source"><![CDATA[local script = script

-- Allows easy command bar paste
if (not script) then
    script = game:GetService("ReplicatedFirst").Vapor.GeneralStore
end

local TypeGuard = require(script.Parent.Parent:WaitForChild("TypeGuard"))
local Cleaner = require(script.Parent.Parent:WaitForChild("Cleaner"))
local XSignal = require(script.Parent.Parent:WaitForChild("XSignal"))

local Shared = require(script.Parent:WaitForChild("Shared"))

type StoreKey = Shared.StoreKey
type StorePath = Shared.StorePath

local ValidStorePath = Shared.ValidStorePath
local GetPathString = Shared.GetPathString
local BuildFromPath = Shared.BuildFromPath
local PathTraverse = Shared.PathTraverse
local RemoveNode = Shared.RemoveNode

local WEAK_KEY_MT = {__mode = "k"}

local FLAT_PATH_DELIMITER = Shared.FlatPathDelimiter
local EMPTY_PATH_ARRAY = {}
local EMPTY_STRING = ""

-- Types
local TYPE_NUMBER = "number"
local TYPE_TABLE = "table"

-- Logs, warnings & errors
local NAME_PREFIX = "[GeneralStore] "

local WARN_INFINITE_WAIT = NAME_PREFIX .. "Potentially infinite wait on '%s'.\n%s"
local LOG_CHANGE = NAME_PREFIX .. "Change %s = %s"

local ERR_STORE_TIMEOUT_REACHED = NAME_PREFIX .. "Store timeout reached on path: %s (%ds)"
local ERR_MIXED_VALUES = NAME_PREFIX .. "Attempted to insert using mixed values with value homogeneity enabled"
local ERR_MIXED_KEYS = NAME_PREFIX .. "Attempted to insert using mixed keys with key homogeneity enabled"

-- Settings
local VALIDATE_PARAMS = true -- Check the types for various functions? (Worse performance but better debugging if true)
local DEFAULT_TIMEOUT = 120 -- Await timeout, prevents memory leaks
local TIMEOUT_WARN = 10 -- When to warn user in possible timeout case

-----------------------------------------------------------------------------------

-- @todo GeneralStore.Move(PathA, PathB)
-- @todo GeneralStore.Swap(PathA, PathB)
-- @todo GeneralStore.MergeUsingPathArray(PathArray, Value)
-- @todo GeneralStore.ClearUsingPathString(PathString)

--- A store which wraps a normal Lua table, allowing for changed signals,
--- child-parent associations, and more. Note: all mutation of the store
--- MUST be achieved through GeneralStore methods, or it will become
--- desynced.
local GeneralStore = {}
GeneralStore.__index = GeneralStore
GeneralStore.Type = "GeneralStore"

local ConstructorParams = TypeGuard.Params(TypeGuard.Function():Optional(), TypeGuard.Object():Optional())
--- Creates a new GeneralStore object.
function GeneralStore.new(DeferFunction, DefaultStructure: any?)
    ConstructorParams(DeferFunction, DefaultStructure)

    local StoreStructure = {}
    local FlatRefs = {[EMPTY_STRING] = StoreStructure}

    local self = {
        _Store = StoreStructure; -- The main table root
        _Awaiting = setmetatable({}, WEAK_KEY_MT); -- For association of path strings to XSignals which fire for changes on that respective path
        _NodeToPath = setmetatable({}, WEAK_KEY_MT); -- For associations of nodes to their path strings
        _PathToValue = FlatRefs; -- For O(1) access on known paths using their strings
        _PathToParentPath = {}; -- For associations of child nodes to their parent node

        _Deferring = false;
        _DeferFunction = DeferFunction;
        _DeferredEvents = {}; -- Caches the latest data on changed events and fires at a defer point

        _DebugLog = false; -- Log any changes to output
        _EnforceHomogeneousKeys = true; -- For all keys in a node, they must be the same type
        _EnforceHomogeneousAtoms = true; -- For all non-table values in a node, they must be the same type
    };

    local Object = setmetatable(self, GeneralStore)

    if (DefaultStructure) then
        -- Not possible to hook into changed events using this, since it occurs in construction
        Object:Merge(DefaultStructure)
    end

    return Object
end

local SetHomogeneousKeysEnforcedParams = TypeGuard.Params(TypeGuard.Boolean())
--- Enabled homogeneous key checking (two keys in a node cannot differ in type).
function GeneralStore:SetHomogeneousKeysEnforced(Enabled: boolean)
    SetHomogeneousKeysEnforcedParams(Enabled)
    self._EnforceHomogeneousKeys = Enabled
end

local SetHomogeneousValuesEnforcementParams = TypeGuard.Params(TypeGuard.Boolean())
--- Enabled homogeneous value checking (two different value types cannot co-exist in a node, except for tables).
function GeneralStore:SetHomogeneousValuesEnforcement(Enabled: boolean)
    SetHomogeneousValuesEnforcementParams(Enabled)
    self._EnforceHomogeneousValues = Enabled
end

--- Clears the whole store, releasing all the awaiting events.
function GeneralStore:Destroy()
    self:ClearUsingPathArray(EMPTY_PATH_ARRAY)
end

local ClearUsingPathArrayParams = TypeGuard.Params(ValidStorePath)
--- Clears a node from the store at a path.
function GeneralStore:ClearUsingPathArray(Path: StorePath?)
    Path = Path or EMPTY_PATH_ARRAY

    if (VALIDATE_PARAMS) then
        ClearUsingPathArrayParams(Path)
    end

    local ValuePath = GetPathString(Path)
    local Value = self:GetUsingPathString(ValuePath)
    assert(typeof(Value) == TYPE_TABLE, "Path was not a node: " .. tostring(ValuePath))

    local FinalMerge = BuildFromPath(Path, {})

    for Key in Value do
        FinalMerge[Key] = RemoveNode
    end

    self:Merge(FinalMerge)
end
GeneralStore.clearUsingPathArray = GeneralStore.ClearUsingPathArray

local GetUsingPathStringParams = TypeGuard.Params(TypeGuard.String():Optional())
--- Finds a value from the store corresponding to the given path defined by a string.
function GeneralStore:GetUsingPathString(PathString: string?, DefaultValue: any?): any?
    PathString = PathString or EMPTY_STRING

    if (VALIDATE_PARAMS) then
        GetUsingPathStringParams(PathString)
    end

    local Found = self._PathToValue[PathString]

    if (Found == nil) then
        Found = DefaultValue
    end

    return Found
end
GeneralStore.GetUsingPathString = GeneralStore.GetUsingPathString

local GetUsingPathArrayParams = TypeGuard.Params(ValidStorePath:Optional())
--- Finds a value from the store corresponding to the given path defined by an array.
function GeneralStore:GetUsingPathArray(Path: StorePath?, DefaultValue: any?): any?
    Path = Path or EMPTY_PATH_ARRAY

    if (VALIDATE_PARAMS) then
        GetUsingPathArrayParams(Path)
    end

    return self:GetUsingPathString(GetPathString(Path), DefaultValue)
end
GeneralStore.getUsingPathArray = GeneralStore.GetUsingPathArray

local SetUsingPathArrayParams = TypeGuard.Params(ValidStorePath:Optional())
--- Sets down a path; constructs tables if none are present along the way.
function GeneralStore:SetUsingPathArray(Path: StorePath, Value: any?, DoMerge: boolean?)
    Path = Path or EMPTY_PATH_ARRAY

    if (VALIDATE_PARAMS) then
        SetUsingPathArrayParams(Path)
    end

    -- Set on root path -> error
    -- TODO: calling set on the root path and passing a table as the value should clear the store & set the new values
    local ExistingValue = self:GetUsingPathString(GetPathString(Path))
    assert(ExistingValue ~= self._Store, "Cannot overwrite root table")

    -- Set using table -> remove previous value and overwrite (we don't want to merge 'set' tables in - unintuitive)
    if (type(Value) == TYPE_TABLE and ExistingValue and not DoMerge) then
        self:Merge(BuildFromPath(Path, RemoveNode))
    end

    self:Merge(BuildFromPath(Path, Value == nil and RemoveNode or Value))
end
GeneralStore.setUsingPathArray = GeneralStore.SetUsingPathArray

local AwaitUsingPathArrayParams = TypeGuard.Params(ValidStorePath, TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())
--- Waits until a value is not nil at the given path defined by an array. The default timeout is 120 seconds.
function GeneralStore:AwaitUsingPathArray(Path: StorePath?, Timeout: number?, BypassError: boolean?): any?
    Path = Path or EMPTY_PATH_ARRAY

    if (VALIDATE_PARAMS) then
        AwaitUsingPathArrayParams(Path, Timeout, BypassError)
    end

    return self:AwaitUsingPathString(GetPathString(Path), Timeout, BypassError)
end
GeneralStore.awaitUsingPathArray = GeneralStore.AwaitUsingPathArray

local AwaitUsingPathStringParams = TypeGuard.Params(TypeGuard.String(), TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())
--- Waits until a value is not nil at the given path defined by a string. The default timeout is 120 seconds.
function GeneralStore:AwaitUsingPathString(PathString: string, Timeout: number?, BypassError: boolean?)
    if (VALIDATE_PARAMS) then
        AwaitUsingPathStringParams(PathString, Timeout, BypassError)
    end

    local CorrectedTimeout = Timeout or DEFAULT_TIMEOUT
    local Got = self:GetUsingPathString(PathString)

    -- ~= nil as it could be false
    if (Got ~= nil) then
        return Got
    end

    -- Timeout warning
    local TimeoutCoroutine = task.delay(TIMEOUT_WARN, function()
        warn(WARN_INFINITE_WAIT:format(PathString, debug.traceback()))
    end)

    local Result = self:GetValueChangedSignalUsingPathString(PathString):Wait(CorrectedTimeout, false)
    task.cancel(TimeoutCoroutine)

    if (Result == nil and not BypassError) then
        error(ERR_STORE_TIMEOUT_REACHED:format(PathString, CorrectedTimeout))
    end

    return Result
end
GeneralStore.awaitUsingPathString = GeneralStore.AwaitUsingPathString

local GetValueChangedSignalUsingPathArrayParams = TypeGuard.Params(ValidStorePath:Optional())
-- Finds or creates a Signal which fires whenever the value at the given path defined by an array changes or is up-propagated.
function GeneralStore:GetValueChangedSignalUsingPathArray(Path: StorePath?): typeof(XSignal)
    Path = Path or EMPTY_PATH_ARRAY

    if (VALIDATE_PARAMS) then
        GetValueChangedSignalUsingPathArrayParams(Path)
    end

    return self:GetValueChangedSignalUsingPathString(GetPathString(Path))
end
GeneralStore.getValueChangedSignalUsingPathArray = GeneralStore.GetValueChangedSignalUsingPathArray
GeneralStore.GetValueChangedSignal = GeneralStore.GetValueChangedSignalUsingPathArray
GeneralStore.getValueChangedSignal = GeneralStore.GetValueChangedSignalUsingPathArray

local GetValueChangedSignalUsingPathStringParams = TypeGuard.Params(TypeGuard.String():Optional())
-- Finds or creates a Signal which fires whenever the value at the given path defined by a string changes or is up-propagated.
function GeneralStore:GetValueChangedSignalUsingPathString(Path: string?): typeof(XSignal)
    Path = Path or EMPTY_STRING

    if (VALIDATE_PARAMS) then
        GetValueChangedSignalUsingPathStringParams(Path)
    end

    local Awaiting = self._Awaiting
    local Found = Awaiting[Path]

    if (Found) then
        return Found
    end

    Found = XSignal.new()
    Awaiting[Path] = Found
    return Found
end
GeneralStore.getValueChangedSignalUsingPathString = GeneralStore.GetValueChangedSignalUsingPathString

local SetMergeUsingPathArrayParams = TypeGuard.Params(ValidStorePath)
--- Merges a value into the store at the given path defined by an array. This will not overwrite existing tables, but will merge into them instead.
function GeneralStore:SetMergeUsingPathArray(Path: StorePath, Value: any?)
    if (VALIDATE_PARAMS) then
        SetMergeUsingPathArrayParams(Path)
    end

    self:Merge(BuildFromPath(Path, Value == nil and RemoveNode or Value))
end
GeneralStore.setMergeUsingPathArray = GeneralStore.SetMergeUsingPathArray

local MergeParams = TypeGuard.Params(TypeGuard.Object():Or(TypeGuard.Array()))
--- Merges a data structure into the existing store's structure.
function GeneralStore:Merge(Data: any)
    if (VALIDATE_PARAMS) then
        MergeParams(Data)
    end

    local StoreData = self._Store
    self:_Merge(EMPTY_STRING, Data, StoreData)
    self:_PathWasChanged(EMPTY_STRING, StoreData)
end
GeneralStore.merge = GeneralStore.Merge

--- Defers value changed events for paths to the next
--- defer point. Useful for not rapidly updating non
--- leaf nodes for many changes on those leaf nodes
--- before a conceptual defer point (like beginning of
--- Heartbeat). Will only fire once with the latest value.
function GeneralStore:_DeferEventFlat(PathString: string, New: any?)
    local Awaiting = self._Awaiting

    if (not Awaiting[PathString]) then
        return
    end

    local DeferredEvents = self._DeferredEvents -- TODO: we might want to fire these in order
    DeferredEvents[PathString] = New

    if (not self._Deferring) then
        self._Deferring = true

        self._DeferFunction(function()
            if (table.isfrozen(self)) then
                return
            end

            for PathName, Change in DeferredEvents do
                local Event = Awaiting[PathName]

                if (Event) then
                    Event:Fire(Change)
                end
            end

            self._DeferredEvents = {}
            self._Deferring = false
        end)
    end
end

-- Fires a signal when an atom or table was changed in a merge.
function GeneralStore:_PathWasChanged(PathName: string, Value: any?, ParentPath: string)
    self._PathToValue[PathName] = Value -- This has to be set first so coroutines resumed after see the correct state, otherwise weird issues with consecutive Awaits

    if (Value == nil) then
        self._PathToParentPath[PathName] = nil
    elseif (PathName ~= EMPTY_STRING) then
        self._PathToParentPath[PathName] = ParentPath
    end

    if (typeof(Value) == TYPE_TABLE) then
        self._NodeToPath[Value] = PathName
    end

    if (self._DeferFunction) then
        self:_DeferEventFlat(PathName, Value)
    else
        local Event = self._Awaiting[PathName]

        if (Event) then
            Event:Fire(Value)
        end
    end

    if (self._DebugLog) then
        print(LOG_CHANGE:format(PathName == EMPTY_STRING and "ROOT" or PathName, tostring(Value)))
    end
end

-- Separate merge procedure since recursion is necessary and params would be inconvenient to the user.
function GeneralStore:_Merge(ParentPath, Data, Into)
    local LastKeyType, LastValueType
    local EnforceHomogeneousKeys = self._EnforceHomogeneousKeys
    local EnforceHomogeneousValues = self._EnforceHomogeneousValues

    if (EnforceHomogeneousKeys) then
        local ExistingKey = next(Into)

        if (ExistingKey) then
            LastKeyType = typeof(ExistingKey)
        end
    end

    if (EnforceHomogeneousValues) then
        for _, Value in Data do
            local ValueType = typeof(Value)

            if (ValueType == TYPE_TABLE) then
                continue
            end

            LastValueType = ValueType
            break
        end
    end

    for Key, Value in Data do
        local ValuePath = ParentPath .. tostring(Key) .. FLAT_PATH_DELIMITER
        local ExistingValue = Into[Key]
        local ExistingValueType = typeof(ExistingValue)

        -- Only one key type can exist in a node
        if (EnforceHomogeneousKeys) then
            local KeyType = typeof(Key)

            if (not LastKeyType) then
                LastKeyType = KeyType
            end

            -- Mixed key types bad bad bad bad bad
            assert(KeyType == LastKeyType, ERR_MIXED_KEYS)
        end

        -- Only one value type can co-exist with table value types in a node
        if (EnforceHomogeneousValues and LastValueType) then
            assert(ExistingValueType == TYPE_TABLE or ExistingValueType == LastValueType, ERR_MIXED_VALUES)
        end

        -- No change, so no need to fire off any events (which would otherwise happen)
        if (Value == ExistingValue) then
            continue
        end

        -- REMOVE_NODE is used in place of 'nil' in tables (since obviously
        -- nil-ed values won't exist, so this acts as a signifier to remove)
        if (Value == RemoveNode) then
            if (ExistingValue == nil) then
                continue
            end

            -- "Remove table" -> all awaiting events on sub-paths should be fired
            if (ExistingValueType == TYPE_TABLE) then
                Into[Key] = nil

                PathTraverse(ExistingValue, ValuePath, function(NewPath, _, NewPathParent)
                    self:_PathWasChanged(NewPath, nil, NewPathParent)
                end)

                self:_PathWasChanged(ValuePath, nil, ParentPath)
                continue
            end

            -- "Remove atom" -> nullify, then signify path was changed to nil
            Into[Key] = nil
            self:_PathWasChanged(ValuePath, nil, ParentPath)
            continue
        end

        -- Item is a sub-table -> recurse and then activate changed event (up-propagated)
        if (typeof(Value) == TYPE_TABLE) then
            if (ExistingValue == nil) then
                ExistingValue = {}
                Into[Key] = ExistingValue
            end

            self:_Merge(ValuePath, Value, ExistingValue)
            self:_PathWasChanged(ValuePath, ExistingValue, ParentPath)
            continue
        end

        -- Replacing a table -> fire all sub-paths with nil
        if (ExistingValueType == TYPE_TABLE) then
            PathTraverse(ExistingValue, ValuePath, function(NewPath, _, NewPathParent)
                self:_PathWasChanged(NewPath, nil, NewPathParent)
            end)
        end

        -- Existing value is nil or not equal to new value -> put in new value
        Into[Key] = Value
        self:_PathWasChanged(ValuePath, Value, ParentPath)
    end
end

local ArrayInsertUsingPathArrayParams = TypeGuard.Params(ValidStorePath, TypeGuard.Any(), TypeGuard.Number():Optional())
--- Inserts a value into an array node with an optional index.
function GeneralStore:ArrayInsertUsingPathArray(Path: StorePath, Value: any, At: number?): number
    if (VALIDATE_PARAMS) then
        ArrayInsertUsingPathArrayParams(Path, Value, At)
    end

    return self:ArrayInsertUsingPathString(GetPathString(Path), Value, At)
end
GeneralStore.arrayInsertUsingPathArray = GeneralStore.ArrayInsertUsingPathArray

local ArrayInsertUsingPathStringParams = TypeGuard.Params(TypeGuard.String(), TypeGuard.Any(), TypeGuard.Number():Optional())
--- Inserts a value into an array node with an optional index given a specifc path string to an array.
function GeneralStore:ArrayInsertUsingPathString(PathString: string, Value: any, At: number?): number
    if (VALIDATE_PARAMS) then
        ArrayInsertUsingPathStringParams(PathString, Value, At)
    end

    local Found = self:GetUsingPathString(PathString)

    local First = next(Found)
    assert(First == nil or typeof(First) == TYPE_NUMBER, "Cannot insert into non-array")

    At = At or #Found + 1
    table.insert(Found, At, Value)

    for Index = #Found, At, -1 do
        local ChangedPathString = PathString .. tostring(Index) .. FLAT_PATH_DELIMITER
        local NewValue = Found[Index]

        self:_PathWasChanged(ChangedPathString, NewValue, PathString)

        if (typeof(NewValue) == TYPE_TABLE) then
            PathTraverse(NewValue, ChangedPathString, function(NewPath, SubValue, NewPathParent)
                self:_PathWasChanged(NewPath, SubValue, NewPathParent)
            end)
        end
    end

    self:_UpPropagate(PathString)

    return At
end
GeneralStore.arrayInsertUsingPathString = GeneralStore.ArrayInsertUsingPathString

local ArrayRemoveUsingPathArrayParams = TypeGuard.Params(ValidStorePath, TypeGuard.Number():Optional())
--- Removes an element from an array node with an optional specific index.
function GeneralStore:ArrayRemoveUsingPathArray(Path: StorePath, At: number?): (any?, number)
    if (VALIDATE_PARAMS) then
        ArrayRemoveUsingPathArrayParams(Path, At)
    end

    return self:ArrayRemoveUsingPathString(GetPathString(Path), At)
end
GeneralStore.arrayRemoveUsingPathArray = GeneralStore.ArrayRemoveUsingPathArray

local ArrayRemoveUsingPathStringParams = TypeGuard.Params(TypeGuard.String(), TypeGuard.Number():Optional())
--- Removes an element from an array node with an optional specific index given a specifc path string to an array.
function GeneralStore:ArrayRemoveUsingPathString(PathString: string, At: number?): (any?, number)
    if (VALIDATE_PARAMS) then
        ArrayRemoveUsingPathStringParams(PathString, At)
    end

    local Found = self:GetUsingPathString(PathString)

    local First = next(Found)
    assert(First == nil or typeof(First) == TYPE_NUMBER, "Cannot insert into non-array")

    local OriginalSize = #Found

    if (OriginalSize == 0) then
        return nil, 0
    end

    At = At or OriginalSize

    local RemovingValue = Found[At]
    local RemovingPath = PathString .. tostring(At) .. FLAT_PATH_DELIMITER

    if (typeof(RemovingValue) == TYPE_TABLE) then
        PathTraverse(RemovingValue, RemovingPath, function(NewPath, _, NewPathParent)
            self:_PathWasChanged(NewPath, nil, NewPathParent)
        end)
    end

    table.remove(Found, At)

    for Index = OriginalSize, At, -1 do
        local ChangedPathString = PathString .. tostring(Index) .. FLAT_PATH_DELIMITER
        local NewValue = Found[Index]

        self:_PathWasChanged(ChangedPathString, NewValue, PathString)

        if (typeof(NewValue) == TYPE_TABLE) then
            PathTraverse(NewValue, ChangedPathString, function(NewPath, SubValue, NewPathParent)
                self:_PathWasChanged(NewPath, SubValue, NewPathParent)
            end)
        end
    end

    self:_UpPropagate(PathString)

    return RemovingValue, At
end
GeneralStore.arrayRemoveUsingPathString = GeneralStore.ArrayRemoveUsingPathString

local IncrementUsingPathArrayParams = TypeGuard.Params(ValidStorePath, TypeGuard.Number():Optional(), TypeGuard.Number():Optional())
--- Increments a numerical value at a given path.
function GeneralStore:IncrementUsingPathArray(Path: StorePath, By: number?, Default: number?): number
    if (VALIDATE_PARAMS) then
        IncrementUsingPathArrayParams(Path, By, Default)
    end

    By = By or 1

    local RootPath = GetPathString(Path)
    local Found = self:GetUsingPathString(RootPath)

    if (Found == nil) then
        if (Default == nil) then
            error("Found no parent for path: " .. RootPath)
        end

        Found = Default
    end

    local Result = Found + By
    local FoundType = typeof(Found)

    if (FoundType ~= TYPE_NUMBER) then
        error(("Cannot increment non-number at path '%s' (got %s)"):format(RootPath, FoundType))
    end

    self:SetUsingPathArray(Path, Result)
    return Result
end
GeneralStore.incrementUsingPathArray = GeneralStore.IncrementUsingPathArray

local GetPathFromNodeParams = TypeGuard.Params(TypeGuard.Object())
--- Returns the path string of a given node - works for nodes but not atoms.
function GeneralStore:GetPathFromNode(Node: any): string?
    if (VALIDATE_PARAMS) then
        GetPathFromNodeParams(Node)
    end

    return self._NodeToPath[Node]
end

local GetParentPathFromPathStringParams = TypeGuard.Params(TypeGuard.String())
--- Attempts to find the parent of a given path - works for nodes & atoms.
function GeneralStore:GetParentPathFromPathString(Path: string): any?
    if (VALIDATE_PARAMS) then
        GetParentPathFromPathStringParams(Path)
    end

    return self._PathToParentPath[Path]
end

local GetParentFromNodeParams = TypeGuard.Params(TypeGuard.Object())
--- Attempts to find the parent of a given node - works for nodes but not atoms.
function GeneralStore:GetParentFromNode(Node: any): any?
    if (VALIDATE_PARAMS) then
        GetParentFromNodeParams(Node)
    end

    local NodePath = self:GetPathFromNode(Node)

    if (not NodePath) then
        return nil
    end

    local NodeParentPath = self:GetParentPathFromPathString(NodePath)

    if (not NodeParentPath) then
        return nil
    end

    return self:GetUsingPathString(NodeParentPath)
end
GeneralStore.getParentFromNode = GeneralStore.GetParentFromNode

local IsNodeAncestorOfParams = TypeGuard.Params(TypeGuard.Object(), TypeGuard.Object())
--- Checks if node A is an ancestor of node B.
function GeneralStore:IsNodeAncestorOf(A: any, B: any): boolean
    if (VALIDATE_PARAMS) then
        IsNodeAncestorOfParams(A, B)
    end

    local Parent = self:GetParentFromNode(B)

    while (Parent) do
        if (Parent == A) then
            return true
        end

        Parent = self:GetParentFromNode(Parent)
    end

    return false
end
GeneralStore.isNodeAncestorOf = GeneralStore.IsNodeAncestorOf

--- Checks if node A is a descendant of node B.
function GeneralStore:IsNodeDescendantOf(A: any, B: any): boolean
    return self:IsNodeAncestorOf(B, A)
end
GeneralStore.isNodeDescendantOf = GeneralStore.IsNodeDescendantOf

local IsPathStringAncestorOfPathParamsString = TypeGuard.Params(TypeGuard.String(), TypeGuard.String())
--- Checks if path A is an ancestor of path B.
function GeneralStore:IsPathStringAncestorOfPathString(A: string, B: string): boolean
    if (VALIDATE_PARAMS) then
        IsPathStringAncestorOfPathParamsString(A, B)
    end

    local Parent = self:GetParentPathFromPathString(B)

    while (Parent) do
        if (Parent == A) then
            return true
        end

        Parent = self:GetParentPathFromPathString(Parent)
    end

    return false
end
GeneralStore.isPathStringAncestorOfPathString = GeneralStore.IsPathStringAncestorOfPathString

--- Checks if path A is a descendant of path B.
function GeneralStore:IsPathStringDescendantOfPathString(A: string, B: string): boolean
    return self:IsPathStringAncestorOfPathString(B, A)
end
GeneralStore.isPathStringDescendantOfPathString = GeneralStore.IsPathStringDescendantOfPathString

--- Fires changed connections for all ascendant nodes of a given path.
function GeneralStore:_UpPropagate(FromPath: string)
    local Path = FromPath

    while (Path) do
        local ParentPath = self:GetParentPathFromPathString(Path)
        self:_PathWasChanged(Path, self:GetUsingPathString(Path), ParentPath)
        Path = ParentPath
    end
end

local DebugLogParams = TypeGuard.Params(TypeGuard.Boolean())
-- Turns debug logging on or off, i.e. when DebugLog is on, it will log any data changes to the console.
function GeneralStore:SetDebugLog(DebugLog: boolean)
    if (VALIDATE_PARAMS) then
        DebugLogParams(DebugLog)
    end

    self._DebugLog = DebugLog
end
GeneralStore.setDebugLog = GeneralStore.SetDebugLog

Cleaner.Wrap(GeneralStore)

return GeneralStore]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6f6</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXFEB81D4512524418B66ED089AF8FD038">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GeneralStore.spec</string>
					<string name="ScriptGuid">{FBA85DA2-B885-42D6-9EB4-6C2B09211F20}</string>
					<ProtectedString name="Source"><![CDATA[return function()
    local GeneralStore = require(script.Parent:WaitForChild("GeneralStore"))
    local Shared = require(script.Parent:WaitForChild("Shared"))

    local function GetTestObject()
        local Result = GeneralStore.new()
        return Result, Result
    end

    -- Checks if two tables are equal
    local function Equivalent(Initial, Other)
        if (Initial == nil or Other == nil) then
            return false
        end

        for Key, Value in Initial do
            local OtherValue = Other[Key]

            if (OtherValue == nil) then
                return false
            end

            if (type(Value) ~= type(OtherValue)) then
                return false
            end

            if (type(Value) == "table") then
                if (not Equivalent(Value, OtherValue)) then
                    return false
                end
            elseif (Value ~= OtherValue) then
                return false
            end
        end

        return true
    end

    describe("new", function()
        it("should construct", function()
            expect(function()
                GetTestObject()
            end).never.to.throw()
        end)
    end)

    describe("SetUsingPathArray", function()
        it("should set flat values", function()
            local TestStore = GetTestObject()
            TestStore:SetUsingPathArray({"A"}, true)
            expect(TestStore._Store.A).to.equal(true)
        end)

        it("should set flat value 'false'", function()
            local TestStore = GetTestObject()
            TestStore:SetUsingPathArray({"A"}, false)
            expect(TestStore._Store.A).to.equal(false)
        end)

        it("should set deep values", function()
            local TestStore = GetTestObject()
            TestStore:SetUsingPathArray({"A", "B", "C"}, 100)
            expect(TestStore._Store.A.B.C).to.equal(100)
        end)

        it("should throw on empty path i.e. root overwrite", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:SetUsingPathArray({}, 100)
            end).to.throw()
        end)

        it("should set flat values in order", function()
            local TestStore = GetTestObject()
            TestStore:SetUsingPathArray({"A"}, true)
            TestStore:SetUsingPathArray({"A"}, 9000)

            TestStore:SetUsingPathArray({"B"}, true)
            TestStore:SetUsingPathArray({"B"}, 1000)

            expect(TestStore._Store.A).to.equal(9000)
            expect(TestStore._Store.B).to.equal(1000)
        end)

        it("should set deep values in order", function()
            local TestStore = GetTestObject()
            TestStore:SetUsingPathArray({"A", "B", "C"}, 100)
            expect(TestStore._Store.A.B.C).to.equal(100)
        end)

        it("should not allow mixed keys", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:SetUsingPathArray({1}, true)
                TestStore:SetUsingPathArray({"a"}, true)
            end).to.throw()

            expect(function()
                TestStore:SetUsingPathArray({"a"}, true)
                TestStore:SetUsingPathArray({1}, true)
            end).to.throw()
        end)

        it("should trigger await events for tables being overwritten by atoms", function()
            local TestStore = GetTestObject()

            TestStore:SetUsingPathArray({"One", "Two", "Three"}, true)

            local Fired1 = false
            local Fired2 = false
            local Fired3 = false

            TestStore:GetValueChangedSignal({"One", "Two", "Three", "Four"}):Connect(function(Value)
                -- Shouldn't fire for non-existent nodes
                Fired3 = true
            end)

            TestStore:GetValueChangedSignal({"One", "Two", "Three"}):Connect(function(Value)
                expect(Value).to.equal(nil)
                Fired1 = true
            end)

            TestStore:GetValueChangedSignal({"One"}):Connect(function(Value)
                expect(Value).to.equal(200)
                Fired2 = true
            end)

            expect(Fired1).to.equal(false)
            expect(Fired2).to.equal(false)
            expect(Fired3).to.equal(false)
            TestStore:SetUsingPathArray({"One"}, 200)
            expect(Fired1).to.equal(true)
            expect(Fired2).to.equal(true)
            expect(Fired3).to.equal(false)
        end)

        it("should overwrite instead of merge table values", function()
            local TestStore = GetTestObject()

            TestStore:Merge({
                A = {
                    B = {
                        C = 2
                    }
                }
            })

            TestStore:SetUsingPathArray({"A"}, {
                B = {};
            })

            expect(next(TestStore:GetUsingPathArray().A.B)).to.equal(nil)
        end)
    end)

    describe("Merge", function()
        it("should change nothing given an empty table", function()
            local TestStore = GetTestObject()
            expect(next(TestStore:GetUsingPathArray())).to.equal(nil)
        end)

        it("should merge a flat value", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = 123;
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A).to.equal(123)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = 123;
            })).to.equal(true)
        end)

        it("should merge multiple flat values", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = 123;
                B = 456;
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A).to.equal(123)

            expect(TestStore:GetUsingPathArray().B).to.be.ok()
            expect(TestStore:GetUsingPathArray().B).to.equal(456)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = 123;
                B = 456;
            })).to.equal(true)
        end)

        it("should merge flat multiple times", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = 123;
            })
            TestStore:Merge({
                B = 456;
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A).to.equal(123)

            expect(TestStore:GetUsingPathArray().B).to.be.ok()
            expect(TestStore:GetUsingPathArray().B).to.equal(456)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = 123;
                B = 456;
            })).to.equal(true)
        end)

        it("should merge flat multiple times with overwrites", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = 123;
            })
            TestStore:Merge({
                A = 789;
                B = 456;
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A).to.equal(789)

            expect(TestStore:GetUsingPathArray().B).to.be.ok()
            expect(TestStore:GetUsingPathArray().B).to.equal(456)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = 789;
                B = 456;
            })).to.equal(true)
        end)

        it("should merge a deep value", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = {
                    B = {
                        C = 10;
                    };
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.equal(10)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = {
                    B = {
                        C = 10;
                    };
                };
            })).to.equal(true)
        end)

        it("should merge multiple deep values", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = {
                    B = {
                        C = 10;
                    };
                };
            })

            TestStore:Merge({
                A = {
                    B = {
                        D = 20;
                    };
                    E = 30;
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.equal(10)
            expect(TestStore:GetUsingPathArray().A.E).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.E).to.equal(30)
            expect(TestStore:GetUsingPathArray().A.B.D).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.D).to.equal(20)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = {
                    B = {
                        C = 10;
                        D = 20;
                    };
                    E = 30;
                };
            })).to.equal(true)
        end)

        it("should merge multiple deep values with overwrites", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = {
                    B = {
                        C = 10;
                    };
                };
            })

            TestStore:Merge({
                A = {
                    B = {
                        D = 20;
                        C = 40;
                    };
                    E = 30;
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.equal(40)
            expect(TestStore:GetUsingPathArray().A.E).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.E).to.equal(30)
            expect(TestStore:GetUsingPathArray().A.B.D).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.D).to.equal(20)

            expect(Equivalent(TestStore:GetUsingPathArray(), {
                A = {
                    B = {
                        C = 40;
                        D = 20;
                    };
                    E = 30;
                };
            })).to.equal(true)
        end)

        it("should remove a flat atom", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = 20;
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()

            TestStore:Merge({
                A = Shared.RemoveNode;
            })

            expect(TestStore:GetUsingPathArray().A).never.to.be.ok()
        end)

        it("should remove a structure on a flat level", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = {
                    B = 10;
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()

            TestStore:Merge({
                A = Shared.RemoveNode;
            })

            expect(TestStore:GetUsingPathArray().A).never.to.be.ok()
        end)

        it("should remove a nested atom", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = {
                    B = 10;
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()

            TestStore:Merge({
                A = {
                    B = Shared.RemoveNode;
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B).never.to.be.ok()
        end)

        it("should remove a nested structure", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                A = {
                    B = {
                        C = 10;
                    };
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B.C).to.be.ok()

            TestStore:Merge({
                A = {
                    B = Shared.RemoveNode;
                };
            })

            expect(TestStore:GetUsingPathArray().A).to.be.ok()
            expect(TestStore:GetUsingPathArray().A.B).never.to.be.ok()
        end)
    end)

    describe("GetUsingPathString", function()
        it("should reject non-string paths", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:GetUsingPathString({})
            end).to.throw()

            expect(function()
                TestStore:GetUsingPathString({"X"})
            end).to.throw()

            expect(function()
                TestStore:GetUsingPathString(1)
            end).to.throw()

            expect(function()
                TestStore:GetUsingPathString("Test")
            end).never.to.throw()
        end)

        it("should accept nil as the path", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:GetUsingPathString(nil)
            end).never.to.throw()
        end)

        it("should obtain correct values after a flat merge & delete", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = 3;
            })

            expect(TestStore:GetUsingPathString("X^")).to.equal(1)
            expect(TestStore:GetUsingPathString("Y^")).to.equal(2)
            expect(TestStore:GetUsingPathString("Z^")).to.equal(3)
            expect(TestStore:GetUsingPathString("")).to.equal(TestStore._Store)

            TestStore:Merge({
                X = Shared.RemoveNode;
                Y = Shared.RemoveNode;
                Z = Shared.RemoveNode;
            })

            expect(TestStore:GetUsingPathString("X^")).never.to.be.ok()
            expect(TestStore:GetUsingPathString("Y^")).never.to.be.ok()
            expect(TestStore:GetUsingPathString("Z^")).never.to.be.ok()
            expect(TestStore:GetUsingPathString("")).to.equal(TestStore._Store)
        end)

        it("should obtain correct values after a deep merge & delete", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = {
                    P = 123;
                    Q = 456;
                };
            })

            expect(TestStore:GetUsingPathString("X^")).to.equal(1)
            expect(TestStore:GetUsingPathString("Y^")).to.equal(2)
            expect(TestStore:GetUsingPathString("Z^")).to.equal(TestStore:GetUsingPathString().Z)
            expect(TestStore:GetUsingPathString("Z^P^")).to.equal(123)
            expect(TestStore:GetUsingPathString("Z^Q^")).to.equal(456)
            expect(TestStore:GetUsingPathString("")).to.equal(TestStore._Store)

            TestStore:Merge({
                Z = {P = Shared.RemoveNode};
            })

            expect(TestStore:GetUsingPathString("X^")).to.equal(1)
            expect(TestStore:GetUsingPathString("Y^")).to.equal(2)
            expect(TestStore:GetUsingPathString("Z^")).to.equal(TestStore:GetUsingPathString().Z)
            expect(TestStore:GetUsingPathString("Z^P^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Z^Q^")).to.equal(456)
            expect(TestStore:GetUsingPathString("")).to.equal(TestStore._Store)

            TestStore:Merge({
                Z = Shared.RemoveNode;
            })

            expect(TestStore:GetUsingPathString("X^")).to.equal(1)
            expect(TestStore:GetUsingPathString("Y^")).to.equal(2)
            expect(TestStore:GetUsingPathString("Z^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Z^P^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Z^Q^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("")).to.equal(TestStore._Store)

            TestStore:Merge({
                X = Shared.RemoveNode;
                Y = Shared.RemoveNode;
            })

            expect(TestStore:GetUsingPathString("X^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Y^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Z^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Z^P^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("Z^Q^")).to.equal(nil)
            expect(TestStore:GetUsingPathString("")).to.equal(TestStore._Store)
        end)
    end)

    describe("GetPathFromNode", function()
        it("should reject non-table values for path param", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:GetPathFromNode(nil)
            end).to.throw()

            expect(function()
                TestStore:GetPathFromNode(1)
            end).to.throw()

            expect(function()
                TestStore:GetPathFromNode("X")
            end).to.throw()
        end)

        it("should obtain paths for shallow & deep nodes", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Z = {
                    P = {};
                    Q = {
                        R = {};
                    };
                };
            })

            expect(TestStore:GetPathFromNode(TestStore:GetUsingPathString().Z)).to.equal("Z^")
            expect(TestStore:GetPathFromNode(TestStore:GetUsingPathString().Z.P)).to.equal("Z^P^")
            expect(TestStore:GetPathFromNode(TestStore:GetUsingPathString().Z.Q)).to.equal("Z^Q^")
            expect(TestStore:GetPathFromNode(TestStore:GetUsingPathString().Z.Q.R)).to.equal("Z^Q^R^")
            expect(TestStore:GetPathFromNode(TestStore:GetUsingPathString())).to.equal("")
        end)
    end)

    describe("GetParentPathFromPathString", function()
        it("should reject non-string paths & accept string paths", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:GetParentPathFromPathString()
            end).to.throw()

            expect(function()
                TestStore:GetParentPathFromPathString({})
            end).to.throw()

            expect(function()
                TestStore:GetParentPathFromPathString({"X"})
            end).to.throw()

            expect(function()
                TestStore:GetParentPathFromPathString(1)
            end).to.throw()

            expect(function()
                TestStore:GetParentPathFromPathString("Test")
            end).never.to.throw()
        end)

        it("should give the parent of shallow paths (the root path / empty string)", function()
            local TestStore = GetTestObject()

            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = 3;
            })

            expect(TestStore:GetParentPathFromPathString("X^")).to.equal("")
            expect(TestStore:GetParentPathFromPathString("Y^")).to.equal("")
            expect(TestStore:GetParentPathFromPathString("Z^")).to.equal("")
        end)

        it("should give the parent of deep paths", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = {
                    P = 123;
                    Q = 456;
                    R = {
                        Test = false;
                    };
                };
            })

            expect(TestStore:GetParentPathFromPathString("X^")).to.equal("")
            expect(TestStore:GetParentPathFromPathString("Y^")).to.equal("")
            expect(TestStore:GetParentPathFromPathString("Z^")).to.equal("")
            expect(TestStore:GetParentPathFromPathString("Z^P^")).to.equal("Z^")
            expect(TestStore:GetParentPathFromPathString("Z^Q^")).to.equal("Z^")
            expect(TestStore:GetParentPathFromPathString("Z^R^")).to.equal("Z^")
            expect(TestStore:GetParentPathFromPathString("Z^R^Test^")).to.equal("Z^R^")
        end)

        it("should de-associate parent paths for removed values at given paths", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = {
                    P = 123;
                    Q = 456;
                    R = {
                        Test = false;
                    };
                };
            })

            TestStore:Merge({
                X = Shared.RemoveNode;
                Y = Shared.RemoveNode;
                Z = Shared.RemoveNode;
            })

            expect(TestStore:GetParentPathFromPathString("X^")).to.equal(nil)
            expect(TestStore:GetParentPathFromPathString("Y^")).to.equal(nil)
            expect(TestStore:GetParentPathFromPathString("Z^")).to.equal(nil)
            expect(TestStore:GetParentPathFromPathString("Z^P^")).to.equal(nil)
            expect(TestStore:GetParentPathFromPathString("Z^Q^")).to.equal(nil)
            expect(TestStore:GetParentPathFromPathString("Z^R^")).to.equal(nil)
            expect(TestStore:GetParentPathFromPathString("Z^R^Test^")).to.equal(nil)
        end)
    end)

    describe("IsPathStringAncestorOfPathString", function()
        it("should reject non-string paths & accept 2 string paths", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:IsPathStringAncestorOfPathString()
            end).to.throw()

            expect(function()
                TestStore:IsPathStringAncestorOfPathString({})
            end).to.throw()

            expect(function()
                TestStore:IsPathStringAncestorOfPathString({"X"})
            end).to.throw()

            expect(function()
                TestStore:IsPathStringAncestorOfPathString(1)
            end).to.throw()

            expect(function()
                TestStore:IsPathStringAncestorOfPathString("Test")
            end).to.throw()

            expect(function()
                TestStore:IsPathStringAncestorOfPathString("Test", "Test")
            end).never.to.throw()
        end)

        it("should return true for correct ancestors (flat)", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = 3;
            })

            expect(TestStore:IsPathStringAncestorOfPathString("", "")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "X^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("X^", "X^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Y^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Y^", "Y^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Z^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^", "Z^")).to.equal(false)
        end)

        it("should return true for correct ancestors (deep)", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = 1;
                Y = 2;
                Z = {
                    P = 123;
                    Q = 456;
                    R = {
                        Test = false;
                    };
                };
            })

            expect(TestStore:IsPathStringAncestorOfPathString("", "")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "X^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("X^", "X^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Y^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Y^", "Y^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Z^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^", "Z^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Z^P^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^P^", "Z^P^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^", "Z^P^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Z^Q^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^", "Z^Q^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^Q^", "Z^Q^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Z^R^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^", "Z^R^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^R^", "Z^R^")).to.equal(false)
            expect(TestStore:IsPathStringAncestorOfPathString("", "Z^R^Test^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^", "Z^R^Test^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^R^", "Z^R^Test^")).to.equal(true)
            expect(TestStore:IsPathStringAncestorOfPathString("Z^R^Test^", "Z^R^Test^")).to.equal(false)
        end)
    end)

    describe("IsNodeAncestorOf", function()
        it("should reject non-table nodes & accept 2 table nodes", function()
            local TestStore = GetTestObject()

            expect(function()
                TestStore:IsNodeAncestorOf()
            end).to.throw()

            expect(function()
                TestStore:IsNodeAncestorOf({})
            end).to.throw()

            expect(function()
                TestStore:IsNodeAncestorOf(1)
            end).to.throw()

            expect(function()
                TestStore:IsNodeAncestorOf("Test")
            end).to.throw()

            expect(function()
                TestStore:IsNodeAncestorOf({}, {})
            end).never.to.throw()
        end)

        it("should return true for correct ancestors (flat)", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                X = {};
                Y = {};
                Z = {};
            })

            local Root = TestStore:GetUsingPathString()

            expect(TestStore:IsNodeAncestorOf(Root, Root)).to.equal(false)
            expect(TestStore:IsNodeAncestorOf(Root, Root.X)).to.equal(true)
            expect(TestStore:IsNodeAncestorOf(Root.X, Root.X)).to.equal(false)
            expect(TestStore:IsNodeAncestorOf(Root, Root.Y)).to.equal(true)
            expect(TestStore:IsNodeAncestorOf(Root.Y, Root.Y)).to.equal(false)
            expect(TestStore:IsNodeAncestorOf(Root, Root.Z)).to.equal(true)
            expect(TestStore:IsNodeAncestorOf(Root.Z, Root.Z)).to.equal(false)
        end)
    end)

    describe("ArrayInsertUsingPathArray", function()
        it("should validate that the node at the target path is an array", function()
            local TestStore = GetTestObject()

            -- Inserting into a nil value is undefined
            expect(function()
                TestStore:ArrayInsertUsingPathArray({"X"}, 1)
            end).to.throw()

            -- Inserting into a string value is undefined
            TestStore:Merge({
                X = "AHHHH";
            })

            expect(function()
                TestStore:ArrayInsertUsingPathArray({"X"}, 1)
            end).to.throw()

            -- Inserting into an object is undefined
            TestStore:SetUsingPathArray({"X"}, nil)
            TestStore:SetUsingPathArray({"X"}, {Y = true})

            expect(function()
                TestStore:ArrayInsertUsingPathArray({"X"}, 1)
            end).to.throw()

            TestStore:SetUsingPathArray({"X"}, nil)

            -- Now it's an array, so it should work
            TestStore:Merge({
                X = {};
            })

            expect(function()
                TestStore:ArrayInsertUsingPathArray({"X"}, 1)
                TestStore:ArrayInsertUsingPathArray({"X"}, 2)
                TestStore:ArrayInsertUsingPathArray({"X"}, 3)
            end).never.to.throw()
        end)

        it("should insert values into the last position given no index", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {};
            })

            local Array = TestStore:GetUsingPathArray().Array

            TestStore:ArrayInsertUsingPathArray({"Array"}, 1)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(nil)

            TestStore:ArrayInsertUsingPathArray({"Array"}, 2)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(2)
            expect(Array[3]).to.equal(nil)

            TestStore:ArrayInsertUsingPathArray({"Array"}, 3)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(2)
            expect(Array[3]).to.equal(3)
            expect(Array[4]).to.equal(nil)
        end)

        it("should fire changed signals for inserted values", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {};
            })

            local ArrayChanged = 0
            local ArrayConnection = TestStore:GetValueChangedSignal({"Array"}):Connect(function()
                ArrayChanged += 1
            end)

            local LastValue = ""
            local XCount = 0
            local XYCount = 0
            local GotX, GotY
            local ArrayConnection1 = TestStore:GetValueChangedSignal({"Array", 1}):Connect(function(Value)
                LastValue = Value
            end)
            local ArrayConnection2 = TestStore:GetValueChangedSignal({"Array", 2}):Connect(function(Value)
                LastValue = Value
            end)
            local ArrayConnection3 = TestStore:GetValueChangedSignal({"Array", 3}):Connect(function(Value)
                LastValue = Value
            end)
            local ArrayConnection3X = TestStore:GetValueChangedSignal({"Array", 3, "X"}):Connect(function(Value)
                XCount += 1
                GotX = Value
            end)
            local ArrayConnection3XY = TestStore:GetValueChangedSignal({"Array", 3, "X", "Y"}):Connect(function(Value)
                XYCount += 1
                GotY = Value
            end)
            local ArrayConnection4X = TestStore:GetValueChangedSignal({"Array", 4, "X"}):Connect(function(Value)
                XCount += 1
            end)
            local ArrayConnection4XY = TestStore:GetValueChangedSignal({"Array", 4, "X", "Y"}):Connect(function(Value)
                XYCount += 1
            end)

            expect(ArrayChanged).to.equal(0)

            TestStore:ArrayInsertUsingPathArray({"Array"}, "X")
            expect(ArrayChanged).to.equal(1)
            expect(LastValue).to.equal("X")

            TestStore:ArrayInsertUsingPathArray({"Array"}, "Y")
            expect(ArrayChanged).to.equal(2)
            expect(LastValue).to.equal("Y")

            local Object = {X = {Y = {}}}
            expect(XCount).to.equal(0)
            expect(XYCount).to.equal(0)
            expect(GotX).never.to.be.ok()
            expect(GotY).never.to.be.ok()
            TestStore:ArrayInsertUsingPathArray({"Array"}, Object)
            expect(ArrayChanged).to.equal(3)
            expect(LastValue).to.equal(Object)
            expect(XCount).to.equal(1)
            expect(XYCount).to.equal(1)
            expect(GotX).to.equal(Object.X)
            expect(GotY).to.equal(Object.X.Y)

            TestStore:ArrayInsertUsingPathArray({"Array"}, "Z", 2)
            expect(ArrayChanged).to.equal(4)
            expect(LastValue).to.equal("Z")
            expect(XCount).to.equal(2)
            expect(XYCount).to.equal(2)

            local Array = TestStore:GetUsingPathArray({"Array"})
            expect(Array[1]).to.equal("X")
            expect(Array[2]).to.equal("Z")
            expect(Array[3]).to.equal("Y")
            expect(Array[4]).to.equal(Object)

            ArrayConnection:Disconnect()
            ArrayConnection1:Disconnect()
            ArrayConnection2:Disconnect()
            ArrayConnection3:Disconnect()
            ArrayConnection3X:Disconnect()
            ArrayConnection3XY:Disconnect()
            ArrayConnection4X:Disconnect()
            ArrayConnection4XY:Disconnect()
        end)

        it("should up-propagate", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {};
            })

            local RootChanged = 0
            local Connection = TestStore:GetValueChangedSignal({}):Connect(function()
                RootChanged += 1
            end)

            expect(RootChanged).to.equal(0)
            TestStore:ArrayInsertUsingPathArray({"Array"}, "Test")
            expect(RootChanged).to.equal(1)

            Connection:Disconnect()
        end)

        it("should insert values into an arbitrary position in the array given an index", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {};
            })

            local Array = TestStore:GetUsingPathArray().Array

            TestStore:ArrayInsertUsingPathArray({"Array"}, 1)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(nil)

            TestStore:ArrayInsertUsingPathArray({"Array"}, 2, 1)
            expect(Array[1]).to.equal(2)
            expect(Array[2]).to.equal(1)
            expect(Array[3]).to.equal(nil)

            TestStore:ArrayInsertUsingPathArray({"Array"}, 3, 1)
            expect(Array[1]).to.equal(3)
            expect(Array[2]).to.equal(2)
            expect(Array[3]).to.equal(1)
            expect(Array[4]).to.equal(nil)

            TestStore:ArrayInsertUsingPathArray({"Array"}, 1000, 2)
            expect(Array[1]).to.equal(3)
            expect(Array[2]).to.equal(1000)
            expect(Array[3]).to.equal(2)
            expect(Array[4]).to.equal(1)
            expect(Array[5]).to.equal(nil)
        end)
    end)

    describe("ArrayRemoveUsingPathArray", function()
        it("should validate that the node corresponding to a given path is an array", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Map = {X = true};
                String = "";
                Number = 123;
            })

            expect(function()
                TestStore:ArrayRemoveUsingPathArray({"String"}, 1)
            end).to.throw()

            expect(function()
                TestStore:ArrayRemoveUsingPathArray({"Number"}, 1)
            end).to.throw()

            expect(function()
                TestStore:ArrayRemoveUsingPathArray({"Map"}, 1)
            end).to.throw()
        end)

        it("should accept an array node", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {};
            })

            expect(function()
                TestStore:ArrayRemoveUsingPathArray({"Array"})
            end).never.to.throw()

            TestStore:Merge({
                Array = {1, 2, 3};
            })

            expect(function()
                TestStore:ArrayRemoveUsingPathArray({"Array"})
            end).never.to.throw()
        end)

        it("should remove the last value from an array", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {1, 2, 3, 4};
            })

            local ArrayChanged = 0
            local ArrayConnection = TestStore:GetValueChangedSignal({"Array"}):Connect(function()
                ArrayChanged += 1
            end)

            local Count = {0, 0, 0, 0}
            local ConnectionPos1 = TestStore:GetValueChangedSignal({"Array", 1}):Connect(function()
                Count[1] += 1
            end)
            local ConnectionPos2 = TestStore:GetValueChangedSignal({"Array", 2}):Connect(function()
                Count[2] += 1
            end)
            local ConnectionPos3 = TestStore:GetValueChangedSignal({"Array", 3}):Connect(function()
                Count[3] += 1
            end)
            local ConnectionPos4 = TestStore:GetValueChangedSignal({"Array", 4}):Connect(function()
                Count[4] += 1
            end)

            local Array = TestStore:GetUsingPathArray({"Array"})
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(2)
            expect(Array[3]).to.equal(3)
            expect(Array[4]).to.equal(4)
            expect(ArrayChanged).to.equal(0)

            expect(Count[1]).to.equal(0)
            expect(Count[2]).to.equal(0)
            expect(Count[3]).to.equal(0)
            expect(Count[4]).to.equal(0)

            TestStore:ArrayRemoveUsingPathArray({"Array"})
            expect(ArrayChanged).to.equal(1)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(2)
            expect(Array[3]).to.equal(3)
            expect(Array[4]).to.equal(nil)

            expect(Count[1]).to.equal(0)
            expect(Count[2]).to.equal(0)
            expect(Count[3]).to.equal(0)
            expect(Count[4]).to.equal(1)

            TestStore:ArrayRemoveUsingPathArray({"Array"})
            expect(ArrayChanged).to.equal(2)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(2)
            expect(Array[3]).to.equal(nil)

            expect(Count[1]).to.equal(0)
            expect(Count[2]).to.equal(0)
            expect(Count[3]).to.equal(1)
            expect(Count[4]).to.equal(1)

            TestStore:ArrayRemoveUsingPathArray({"Array"})
            expect(ArrayChanged).to.equal(3)
            expect(Array[1]).to.equal(1)
            expect(Array[2]).to.equal(nil)

            expect(Count[1]).to.equal(0)
            expect(Count[2]).to.equal(1)
            expect(Count[3]).to.equal(1)
            expect(Count[4]).to.equal(1)

            TestStore:ArrayRemoveUsingPathArray({"Array"})
            expect(ArrayChanged).to.equal(4)
            expect(Array[1]).to.equal(nil)

            expect(Count[1]).to.equal(1)
            expect(Count[2]).to.equal(1)
            expect(Count[3]).to.equal(1)
            expect(Count[4]).to.equal(1)

            -- Removals on empty arrays should not register any changes
            TestStore:ArrayRemoveUsingPathArray({"Array"})
            expect(ArrayChanged).to.equal(4)

            ArrayConnection:Disconnect()
            ConnectionPos1:Disconnect()
            ConnectionPos2:Disconnect()
            ConnectionPos3:Disconnect()
            ConnectionPos4:Disconnect()
        end)

        it("should allow removals from a specific index & fire changed for all successor elements", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {1, 2, 3, 4};
            })

            local Count = {0, 0, 0, 0}
            local Last = {}
            local ConnectionPos1 = TestStore:GetValueChangedSignal({"Array", 1}):Connect(function(Value)
                Count[1] += 1
                Last[1] = Value
            end)
            local ConnectionPos2 = TestStore:GetValueChangedSignal({"Array", 2}):Connect(function(Value)
                Count[2] += 1
                Last[2] = Value
            end)
            local ConnectionPos3 = TestStore:GetValueChangedSignal({"Array", 3}):Connect(function(Value)
                Count[3] += 1
                Last[3] = Value
            end)
            local ConnectionPos4 = TestStore:GetValueChangedSignal({"Array", 4}):Connect(function(Value)
                Count[4] += 1
                Last[4] = Value
            end)

            TestStore:ArrayRemoveUsingPathArray({"Array"}, 1)
            expect(Count[1]).to.equal(1)
            expect(Count[2]).to.equal(1)
            expect(Count[3]).to.equal(1)
            expect(Count[4]).to.equal(1)
            expect(Last[1]).to.equal(2)
            expect(Last[2]).to.equal(3)
            expect(Last[3]).to.equal(4)
            expect(Last[4]).to.equal(nil)

            TestStore:ArrayRemoveUsingPathArray({"Array"}, 2)
            expect(Count[1]).to.equal(1)
            expect(Count[2]).to.equal(2)
            expect(Count[3]).to.equal(2)
            expect(Count[4]).to.equal(1)
            expect(Last[1]).to.equal(2)
            expect(Last[2]).to.equal(4)
            expect(Last[3]).to.equal(nil)
            expect(Last[4]).to.equal(nil)

            ConnectionPos1:Disconnect()
            ConnectionPos2:Disconnect()
            ConnectionPos3:Disconnect()
            ConnectionPos4:Disconnect()
        end)

        it("should up-propagate for removed tables", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Array = {1, 2, {X = true}, 4};
            })

            local ArrayChanged = 0
            local RootChanged = 0
            local XChanged = 0

            local ArrayConnection = TestStore:GetValueChangedSignal({"Array"}):Connect(function()
                ArrayChanged += 1
            end)
            local RootConnection = TestStore:GetValueChangedSignal({}):Connect(function()
                RootChanged += 1
            end)
            local XConnection = TestStore:GetValueChangedSignal({"Array", 3, "X"}):Connect(function()
                XChanged += 1
            end)

            expect(ArrayChanged).to.equal(0)
            expect(RootChanged).to.equal(0)
            expect(XChanged).to.equal(0)

            TestStore:ArrayRemoveUsingPathArray({"Array"}, 3)
            expect(ArrayChanged).to.equal(1)
            expect(RootChanged).to.equal(1)
            expect(XChanged).to.equal(1)

            ArrayConnection:Disconnect()
            RootConnection:Disconnect()
            XConnection:Disconnect()
        end)
    end)

    describe("IncrementUsingPathArray", function()
        it("should reject non-numeric values from corresponding paths", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Test = {};
                Str = "";
            })

            expect(function()
                TestStore:IncrementUsingPathArray({"Test"})
            end).to.throw()

            expect(function()
                TestStore:IncrementUsingPathArray({"Test", "X", "Y"})
            end).to.throw()

            expect(function()
                TestStore:IncrementUsingPathArray({"Str"})
            end).to.throw()
        end)

        it("should accept paths which correspond to numeric values", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Test = 1;
            })

            expect(function()
                TestStore:IncrementUsingPathArray({"Test"})
            end).never.to.throw()
        end)

        it("should increment the value at the given path with 1 by default", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Test = 1;
            })

            TestStore:IncrementUsingPathArray({"Test"})
            expect(TestStore:GetUsingPathArray().Test).to.equal(2)

            TestStore:IncrementUsingPathArray({"Test"})
            expect(TestStore:GetUsingPathArray().Test).to.equal(3)

            TestStore:IncrementUsingPathArray({"Test"})
            expect(TestStore:GetUsingPathArray().Test).to.equal(4)
        end)

        it("should increment the value at a given path by a custom amount if specified", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Test = 1;
            })

            TestStore:IncrementUsingPathArray({"Test"}, 2)
            expect(TestStore:GetUsingPathArray().Test).to.equal(3)

            TestStore:IncrementUsingPathArray({"Test"}, 3)
            expect(TestStore:GetUsingPathArray().Test).to.equal(6)

            TestStore:IncrementUsingPathArray({"Test"}, -1)
            expect(TestStore:GetUsingPathArray().Test).to.equal(5)

            TestStore:IncrementUsingPathArray({"Test"}, 0)
            expect(TestStore:GetUsingPathArray().Test).to.equal(5)
        end)

        it("should return the new value at the given path", function()
            local TestStore = GetTestObject()
            TestStore:Merge({
                Test = 1;
            })

            expect(TestStore:IncrementUsingPathArray({"Test"})).to.equal(2)
            expect(TestStore:IncrementUsingPathArray({"Test"})).to.equal(3)
            expect(TestStore:IncrementUsingPathArray({"Test"})).to.equal(4)
            expect(TestStore:IncrementUsingPathArray({"Test"}, -3)).to.equal(1)
        end)

        it("should set a default value if no value exists", function()
            local TestStore = GetTestObject()
            TestStore:IncrementUsingPathArray({"X", "Y", "Z"}, 1, 5)

            local InnerStore = TestStore:GetUsingPathArray()
            expect(InnerStore.X).to.be.ok()
            expect(InnerStore.X.Y).to.be.ok()
            expect(InnerStore.X.Y.Z).to.equal(6)

            TestStore:IncrementUsingPathArray({"X", "Y", "Z"}, 1, 5)
            expect(TestStore:GetUsingPathArray().X.Y.Z).to.equal(7)
        end)
    end)

    describe("GetUsingPathArray", function()
        it("should return the main table with no arguments", function()
            local TestStore = GetTestObject()
            expect(TestStore:GetUsingPathArray()).to.equal(TestStore._Store)
        end)

        it("should return nil for paths which do not exist", function()
            local TestStore = GetTestObject()
            expect(TestStore:GetUsingPathArray({"A", "B"})).never.to.be.ok()
            expect(TestStore:GetUsingPathArray({"A", "B"})).never.to.be.ok()
        end)
    end)

    describe("AwaitUsingPathArray", function()
        it("should return if value is already present", function()
            local TestStore = GetTestObject()
            TestStore:SetUsingPathArray({"A"}, 1)
            expect(TestStore:AwaitUsingPathArray({"A"})).to.equal(1)
        end)

        it("should await a flat value", function()
            local WAIT_TIME = 0.1
            local TestStore = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                TestStore:SetUsingPathArray({"A"}, 1)
            end)

            local Time = os.clock()
            expect(TestStore:AwaitUsingPathArray({"A"})).to.equal(1)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a deep value", function()
            local WAIT_TIME = 0.1
            local TestStore = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                TestStore:SetUsingPathArray({"A", "B", "C"}, 1)
            end)

            local Time = os.clock()
            expect(TestStore:AwaitUsingPathArray({"A", "B", "C"})).to.equal(1)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a values in sub-tables", function()
            local WAIT_TIME = 0.1
            local TestStore = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                TestStore:SetUsingPathArray({"A", "B"}, {
                    TEST = 1;
                })
                TestStore:SetUsingPathArray({"C"}, {
                    D = 2;
                })
            end)

            local Time = os.clock()

            task.spawn(function()
                expect(TestStore:AwaitUsingPathArray({"A", "B", "TEST"})).to.equal(1)
            end)

            expect(TestStore:AwaitUsingPathArray({"C", "D"})).to.equal(2)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should timeout", function()
            local TIMEOUT = 0.1
            local TestStore = GetTestObject()

            local Time = os.clock()

            expect(pcall(function()
                TestStore:AwaitUsingPathArray({"A"}, TIMEOUT)
            end)).to.equal(false)

            expect(os.clock() - Time >= TIMEOUT).to.equal(true)
        end)
    end)

    describe("GetValueChangedSignal", function()
        it("should fire correctly", function()
            local TestStore = GetTestObject()
            local Value

            TestStore:GetValueChangedSignal({"A"}):Connect(function(NewValue)
                Value = NewValue
            end)

            expect(Value).never.to.be.ok()
            TestStore:SetUsingPathArray({"A"}, 20)
            expect(Value).to.equal(20)
        end)

        it("should implement Wait() correctly", function()
            local TestStore = GetTestObject()
            local Value

            task.spawn(function()
                Value = TestStore:GetValueChangedSignal({"A"}):Wait()
            end)

            expect(Value).never.to.be.ok()
            TestStore:SetUsingPathArray({"A"}, 20)
            expect(Value).to.equal(20)
        end)
    end)

    describe("Merge", function()
        it("should set a flat value", function()
            local TestStore = GetTestObject()

            TestStore:Merge({
                A = 1;
            })

            expect(TestStore:GetUsingPathArray({"A"})).to.equal(1)
        end)

        it("should overwrite a flat value", function()
            local TestStore = GetTestObject()

            TestStore:Merge({
                A = 1;
            })

            TestStore:Merge({
                A = 5;
            })

            expect(TestStore:GetUsingPathArray({"A"})).to.equal(5)
        end)
    end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6f7</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEA4829E447B8440CA146BE02A2FDED84">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">InstanceReplication</string>
					<string name="ScriptGuid">{2702DABC-4885-49C9-AB2E-C17F08B3DDE3}</string>
					<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local IsClient = RunService:IsClient()

local Cleaner = require(script.Parent.Parent:WaitForChild("Cleaner"))
local TypeGuard = require(script.Parent.Parent:WaitForChild("TypeGuard"))
local StoreInterface = require(script.Parent:WaitForChild("StoreInterface"))
local ReplicatedStore = require(script.Parent:WaitForChild("ReplicatedStore"))

local VALIDATE_PARAMS = true
local REMOTE_WAIT_TIMEOUT = 60

local TYPE_INSTANCE = "Instance"
local TYPE_REMOTE_EVENT = "RemoteEvent"

local CLIENT_PARTITION_TAG = "ClientPartition"

local ERR_ROOT_TYPE = "Instance expected, got %s"
local ERR_REMOTE_TIME_OUT = "Wait for partition timed out: %s"
local ERR_ROOT_DEPARENTED = "Instance was already deparented"
local ERR_PARTITION_ALREADY_TAKEN = "Partition already taken: %s"
local ERR_PARTITION_ALREADY_ACTIVE = "Partition already active: %s"

local InstanceReplication = {}
InstanceReplication.__index = InstanceReplication
InstanceReplication.ReplicatedStoreCache = {}

local ClientParams = TypeGuard.Params(TypeGuard.Instance():IsDescendantOf(game), TypeGuard.String(), TypeGuard.Boolean():Optional())

local function Client(Root: Instance, PartitionName: string, ShouldYieldOnRemove: boolean?)
    if (VALIDATE_PARAMS) then
        ClientParams(Root, PartitionName, ShouldYieldOnRemove)
    end

    local Remote = Root:WaitForChild(PartitionName, REMOTE_WAIT_TIMEOUT)

    if (not Remote) then
        error(ERR_REMOTE_TIME_OUT:format(PartitionName))
    end

    if (Remote:GetAttribute(CLIENT_PARTITION_TAG)) then
        error(ERR_PARTITION_ALREADY_ACTIVE:format(PartitionName))
    end

    local CleanerObject = Cleaner.new()

    local ReplicationObject = ReplicatedStore.new(Remote, false)
    ReplicationObject:InitClient()
    CleanerObject:Add(ReplicationObject)

    local Interface = StoreInterface.new(ReplicationObject)
    CleanerObject:Add(Interface)

    local CurrentLocation = Remote:GetFullName()

    CleanerObject:Add(Remote.AncestryChanged:Connect(function(_, NewParent)
        if (ShouldYieldOnRemove) then
            task.wait()
        end

        if (NewParent == nil) then
            print("[InstanceReplication] Remote deparented: " .. CurrentLocation)
            CleanerObject:Clean()
        else
            CurrentLocation = Remote:GetFullName()
        end
    end))

    Remote:SetAttribute(CLIENT_PARTITION_TAG, true)

    return Interface, ReplicationObject
end

local ServerParams = TypeGuard.Params(TypeGuard.Instance():IsDescendantOf(game), TypeGuard.String(), TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())

local function Server(Root: Instance, PartitionName: string, Interval: number?, ShouldYieldOnRemove: boolean?)
    if (VALIDATE_PARAMS) then
        ServerParams(Root, PartitionName, Interval, ShouldYieldOnRemove)
    end

    assert(typeof(Root) == TYPE_INSTANCE, ERR_ROOT_TYPE:format(typeof(Root)))
    assert(Root.Parent ~= nil, ERR_ROOT_DEPARENTED)
    assert(Root:FindFirstChild(PartitionName) == nil, ERR_PARTITION_ALREADY_TAKEN:format(PartitionName))

    local Remote = Instance.new(TYPE_REMOTE_EVENT)
    Remote.Name = PartitionName

    local CleanerObject = Cleaner.new()
    local ReplicationObject = ReplicatedStore.new(Remote, true)

    if (Interval and Interval > 0) then
        ReplicationObject.DeferFunction = function(Callback)
            task.delay(Interval, Callback)
        end
    end

    ReplicationObject:InitServer()
    CleanerObject:Add(ReplicationObject)

    local Interface = StoreInterface.new(ReplicationObject)
    CleanerObject:Add(Interface)

    local CurrentLocation = Remote:GetFullName()

    CleanerObject:Add(Remote.AncestryChanged:Connect(function(_, NewParent)
        if (NewParent == nil) then
            if (ShouldYieldOnRemove) then
                task.wait()
            end

            print("[InstanceReplication] Remote deparented: " .. CurrentLocation)
            CleanerObject:Clean()
        else
            CurrentLocation = Remote:GetFullName()
        end
    end))

    Remote.Parent = Root

    return Interface, ReplicationObject
end

local function Auto(...)
    return IsClient and Client(...) or Server(...)
end

return Auto]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6f8</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6C20E1A41F2B4E03AC6B5746EA236C52">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MockRemoteEvent</string>
					<string name="ScriptGuid">{BEDF4647-9869-4F50-A2A0-348014829950}</string>
					<ProtectedString name="Source"><![CDATA[local MockRemoteEvent = {}
MockRemoteEvent.__index = MockRemoteEvent

function MockRemoteEvent.new()
    local Bind = Instance.new("BindableEvent")

    local self = {
        Bind = Bind;
        OnClientEvent = Bind.Event;
        OnServerEvent = Bind.Event;
    };

    return setmetatable(self, MockRemoteEvent)
end

function MockRemoteEvent:FireServer(...)
    if (self.OnFire) then
        self.OnFire(...)
    end
end

function MockRemoteEvent:FireClient(_Player, ...)
    if (self.OnFire) then
        self.OnFire(...)
    end
end

function MockRemoteEvent:FireAllClients(...)
    if (self.OnFire) then
        self.OnFire(...)
    end
end

return MockRemoteEvent]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6f9</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4219D04787F04B269D51708043DA1080">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ReplicatedStore</string>
					<string name="ScriptGuid">{D8763D48-83F9-4298-AFE6-1B98C624EA5D}</string>
					<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local GeneralStore = require(script.Parent:WaitForChild("GeneralStore"))
local TypeGuard = require(script.Parent.Parent:WaitForChild("TypeGuard"))
local Cleaner = require(script.Parent.Parent:WaitForChild("Cleaner"))
local XSignal = require(script.Parent.Parent:WaitForChild("XSignal"))
local Shared = require(script.Parent:WaitForChild("Shared"))

local BuildFromPath = Shared.BuildFromPath
local InternalMerge = Shared.InternalMerge
local RemoveNode = Shared.RemoveNode

type StorePath = Shared.StorePath

local EMPTY_PATH = {}

local REPLICATE_PROCESS_TAG = "ReplicatedStore.Incoming"
local DEFAULT_SEND_TO_CATEGORY = "*"
local EMPTY_STRING = ""
local TYPE_TABLE = "table"

local METHOD_SHORTENINGS = { -- Sent over network, so gotta save space!
    ArrayInsertUsingPathArray = "1";
    ArrayRemoveUsingPathArray = "2";
    IncrementUsingPathArray = "3";
    Merge = "4";

    ArrayInsertUsingPathString = "5";
    ArrayRemoveUsingPathString = "6";
}

-- Settings
local MERGE_LIST_DEFAULT_SIZE = Players.MaxPlayers
local DEBUG_WARN_PATH_CONVERT = true
local VALIDATE_PARAMS = true

-----------------------------------------------------------------------------------

--- Deep copies a table such that:
--- - All string keys are converted to numbers if they can be converted.
--- - All sub-tables marked 'RemoveNode' are substituted with a reference to the real RemoveNode, used in the merging process to remove values at paths.
--- @todo: test performance of mutable versions.
local function SerializeIncomingData(Data: any): any
    local Result = {}

    for Key, Value in Data do
        if (type(Value) == TYPE_TABLE) then
            if (Value._REMOVE_NODE) then
                Value = RemoveNode
            else
                Value = SerializeIncomingData(Value)
            end
        end

        Result[tonumber(Key) or Key] = Value
    end

    return Result
end

--- Deep copies a table such that:
--- - All numerical keys are converted to strings if they can be.
local function ConvertToStringIndices(Data: any): any
    local Result = {}

    for Key, Value in Data do
        if (type(Value) == TYPE_TABLE) then
            Value = ConvertToStringIndices(Value)
        end

        Result[tostring(Key)] = Value
    end

    return Result
end

local ConvertPathToNumericCache = setmetatable({}, {__mode = "k"})
--- Mutably converts a path array's values to numeric where possible.
local function ConvertPathToNumeric(Path: StorePath)
    if (ConvertPathToNumericCache[Path]) then
        return
    end

    for Index, Value in Path do
        local AsNumber = tonumber(Value)
        Path[Index] = AsNumber or Value

        if (DEBUG_WARN_PATH_CONVERT and AsNumber ~= Value and AsNumber) then
            warn("Key was converted to number: " .. tostring(Value))
        end
    end

    ConvertPathToNumericCache[Path] = true
end

-----------------------------------------------------------------------------------

--- An extension of GeneralStore, allowing for optimized & batched replication of arbitrary data to particular clients.
local ReplicatedStore = {}
ReplicatedStore.__index = ReplicatedStore
ReplicatedStore.Type = "ReplicatedStore"

local ConstructorParams = TypeGuard.Params(TypeGuard.Instance("RemoteEvent"):Or(TypeGuard.Object()), TypeGuard.Boolean())
--- Creates a new ReplicatedStore object.
function ReplicatedStore.new(RemoteEvent: any, IsServer: boolean): typeof(ReplicatedStore)
    if (VALIDATE_PARAMS) then
        ConstructorParams(RemoteEvent, IsServer)
    end

    local self = {
        _Store = GeneralStore.new();

        _SyncedPlayers = {};
        _BlockedPlayers = {};
        _DeferredInstructions = {};

        --[[ DeferFunction = function(Callback: () -> ())
            -- Immediate defer by default, but easy to
            -- switch to task.defer or some task.delay
            -- fixed duration function
            Callback()
        end; ]]

        _Synced = false;
        _IsServer = IsServer;
        _TestMode = false;
        _Deferring = false;
        _Initialized = false;

        _RemoteEvent = RemoteEvent;

        OnDefer = XSignal.new();
    };

    return setmetatable(self, ReplicatedStore)
end

-- Client method; syncs the store
function ReplicatedStore:InitClient()
    assert(not self._Initialized, "Already initialized on client!")

    local RemoteEvent = self._RemoteEvent
    local StoreObject = self._Store

    self._EventConnection = RemoteEvent.OnClientEvent:Connect(function(Data: any?, InitialSync: boolean)
        debug.profilebegin(REPLICATE_PROCESS_TAG)

            if (Data == nil) then
                StoreObject:Clear()
                debug.profileend()
                return
            end

            Data = SerializeIncomingData(Data)

            -- No need to merge data which comes in after we send off the initial sync request and wait for it to pass back
            if (not InitialSync and not self._Synced) then
                debug.profileend()
                return
            end

            -- Initial sync will be up to date and the whole structure so we can stop rejecting after we receive it
            if (InitialSync) then
                self._Synced = true
            end

            for _, Call in Data do
                self[Call.Method](self, unpack(Call.Args))
            end
        debug.profileend()
    end)

    RemoteEvent:FireServer()
    self._Initialized = true
end

--- Server method - receives client requests.
function ReplicatedStore:InitServer()
    assert(not self._Initialized, "Already initialized on server!")

    local RemoteEvent = self._RemoteEvent

    -- Client requests initial sync -> replicate whole state to client
    self._EventConnection = RemoteEvent.OnServerEvent:Connect(function(Player: Player)
        self:_FullSync(Player, true)
    end)

    self._Initialized = true
end

function ReplicatedStore:Destroy()
    self._EventConnection:Disconnect()
    self._Store:Destroy()
end

--- See `GeneralStore.GetUsingPathArray`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:GetUsingPathArray(Path: StorePath?, DefaultValue: any?): any?
    Path = Path or EMPTY_PATH
    ConvertPathToNumeric(Path)

    return self._Store:GetUsingPathArray(Path, DefaultValue)
end
ReplicatedStore.getUsingPathArray = ReplicatedStore.GetUsingPathArray

--- See `GeneralStore.GetUsingPathString`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:GetUsingPathString(...): any?
    return self._Store:GetUsingPathString(...)
end
ReplicatedStore.getUsingPathString = ReplicatedStore.GetUsingPathString

--- See `GeneralStore.ArrayInsertUsingPathArray`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:ArrayInsertUsingPathArray(Path: StorePath?, Value: any, At: number?, SendTo: {Player}?): number
    Path = Path or EMPTY_PATH
    ConvertPathToNumeric(Path)

    -- Keep our core store up to date
    local Result = self._Store:ArrayInsertUsingPathArray(Path, Value, At)
    self:_QueueMethod(METHOD_SHORTENINGS.ArrayInsertUsingPathArray, SendTo, Path, Value, At)
    return Result
end
ReplicatedStore.arrayInsertUsingPathArray = ReplicatedStore.ArrayInsertUsingPathArray

--- See `GeneralStore.ArrayInsertUsingPathString`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:ArrayInsertUsingPathString(PathString: string, Value: any, At: number?, SendTo: {Player}?): number
    local Result = self._Store:ArrayInsertUsingPathString(PathString, Value, At)
    self:_QueueMethod(METHOD_SHORTENINGS.ArrayInsertUsingPathString, SendTo, PathString, Value, At)
    return Result
end
ReplicatedStore.arrayInsertUsingPathString = ReplicatedStore.ArrayInsertUsingPathString

--- See `GeneralStore.ArrayRemoveUsingPathArray`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:ArrayRemoveUsingPathArray(Path: StorePath, At: number?, SendTo: {Player}?): (any?, number)
    Path = Path or EMPTY_PATH
    ConvertPathToNumeric(Path)

    local RemovedValue, RemovedIndex = self._Store:ArrayRemoveUsingPathArray(Path, At)
    self:_QueueMethod(METHOD_SHORTENINGS.ArrayRemoveUsingPathArray, SendTo, Path, At)
    return RemovedValue, RemovedIndex
end
ReplicatedStore.arrayRemoveUsingPathArray = ReplicatedStore.ArrayRemoveUsingPathArray

--- See `GeneralStore.ArrayRemoveUsingPathString`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:ArrayRemoveUsingPathString(PathString: string, Value: any, At: number?, SendTo: {Player}?): number
    local RemovedValue, RemovedIndex = self._Store:ArrayRemoveUsingPathString(PathString, Value, At)
    self:_QueueMethod(METHOD_SHORTENINGS.ArrayRemoveUsingPathString, SendTo, PathString, Value, At)
    return RemovedValue, RemovedIndex
end
ReplicatedStore.arrayRemoveUsingPathString = ReplicatedStore.ArrayRemoveUsingPathString

--- See `GeneralStore.Merge`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:Merge(Data: any, SendTo: {Player}?)
    -- Keep our core store up to date
    self._Store:Merge(Data)
    self:_QueueMethod(METHOD_SHORTENINGS.Merge, SendTo, Data)
end
ReplicatedStore.merge = ReplicatedStore.Merge

--- See `GeneralStore.IncrementUsingPathArray`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:IncrementUsingPathArray(Path: StorePath, By: number?, Default: number?, SendTo: {Player}?): number
    ConvertPathToNumeric(Path)

    local NewValue = self._Store:IncrementUsingPathArray(Path, By, Default)
    self:_QueueMethod(METHOD_SHORTENINGS.IncrementUsingPathArray, SendTo, Path, By, Default)
    return NewValue
end
ReplicatedStore.incrementUsingPathArray = ReplicatedStore.IncrementUsingPathArray

--- See `GeneralStore.SetUsingPathArray`. Has an optional SendTo array which can contain a list of players (or no players) to selectively
--- replicate this to.
function ReplicatedStore:SetUsingPathArray(Path: StorePath, Value: any?, SendTo: {Player}?)
    Path = Path or EMPTY_PATH
    ConvertPathToNumeric(Path)

    if (type(Value) == TYPE_TABLE and self:GetUsingPathArray(Path)) then
        -- Set using table -> remove previous value and overwrite (we don't want to merge 'set' tables in - unintuitive)
        self:Merge(BuildFromPath(Path, RemoveNode), SendTo)
    end

    self:Merge(BuildFromPath(Path, Value == nil and RemoveNode or Value), SendTo)
end
ReplicatedStore.setUsingPathArray = ReplicatedStore.SetUsingPathArray

--- See `GeneralStore.GetValueChangedSignalUsingPathArray`.
function ReplicatedStore:GetValueChangedSignalUsingPathArray(Path: StorePath): typeof(XSignal)
    Path = Path or EMPTY_PATH
    ConvertPathToNumeric(Path)

    return self._Store:GetValueChangedSignalUsingPathArray(Path)
end
ReplicatedStore.GetValueChangedSignalUsingPathArray = ReplicatedStore.GetValueChangedSignalUsingPathArray

--- See `GeneralStore.AwaitUsingPathArray`.
function ReplicatedStore:AwaitUsingPathArray(Path: StorePath, ...): any?
    Path = Path or EMPTY_PATH
    ConvertPathToNumeric(Path)

    return self._Store:AwaitUsingPathArray(Path, ...)
end
ReplicatedStore.awaitUsingPathArray = ReplicatedStore.AwaitUsingPathArray

--- See `GeneralStore.AwaitUsingPathString`.
function ReplicatedStore:AwaitUsingPathString(...): any?
    return self._Store:AwaitUsingPathString(...)
end
ReplicatedStore.awaitUsingPathString = ReplicatedStore.AwaitUsingPathString

--- See `GeneralStore.SetDebugLog`.
function ReplicatedStore:SetDebugLog(DebugLog: boolean)
    self._Store:SetDebugLog(DebugLog)
end
ReplicatedStore.setDebugLog = ReplicatedStore.SetDebugLog

--- Untested - do not use.
--- Note: likely will require erasure of player's merge / call batches too.
--- Blocks a player from receiving updates from this store and optionally nullifies the store on their client.
function ReplicatedStore:Block(Player: Player, Clear: boolean?)
    error("Unimplemented")

    local PlayerName = Player.Name
    local BlockedPlayers = self._BlockedPlayers
    assert(not BlockedPlayers[PlayerName])

    -- We'll want to clean up the connection & connection ref if player leaves
    local Connection; Connection = PlayerName.AncestryChanged:Connect(function(_, Parent)
        if (Parent == nil) then
            self:Unblock(Player, false)
        end
    end)

    BlockedPlayers[PlayerName] = Connection

    if (Clear) then
        self._RemoteEvent:FireClient(Player)
    end
end
ReplicatedStore.block = ReplicatedStore.Block

--- Untested - do not use. This will likely be used for an upcoming world streaming system.
--- Unblocks a player from receiving updates from this store and optionally re-sends the store.
function ReplicatedStore:Unblock(Player: Player, Renew: boolean?)
    error("Unimplemented")

    local PlayerName = Player.Name
    local BlockedPlayers = self._BlockedPlayers
    local Connection = BlockedPlayers[PlayerName]

    if (not Connection) then
        return
    end

    Connection:Disconnect()
    BlockedPlayers[PlayerName] = nil

    if (Renew) then
        self._SyncedPlayers[Player.UserId] = nil
        self:_FullSync(Player, false)
    end
end
ReplicatedStore.unblock = ReplicatedStore.Unblock

--- Shaft off sending changes to clients to next defer function cycle (if server). See _PrepareDefer and _DeferProcess
--- for the subsequent data preparation steps.
function ReplicatedStore:_QueueMethod(Name: string, SendTo: {Player}?, ...)
    if (self._IsServer) then
        if (SendTo) then
            for _, Player in SendTo do
                self:_PrepareDefer(Player.Name, Name, ...)
            end
        else
            self:_PrepareDefer(DEFAULT_SEND_TO_CATEGORY, Name, ...)
        end
    end
end

local ShortenedMergeName = METHOD_SHORTENINGS.Merge
--- Enqueues fundamental mutation method calls (Merge, ArrayInsert, ArrayRemove, Increment, etc.) to be sent to clients,
--- attempts to optimize them, and initiates a defer point after which the batch will be sent.
--- @todo Condense down consecutive non-merge-optimizable method args into {Method = "Test", Args = { {1}, {2, 3}, {4} }}
function ReplicatedStore:_PrepareDefer(SendToCategory: string, Method: string, ...)
    debug.profilebegin("PrepareDefer(" .. Method .. ")")

    -- Find or setup _instruction list for that player
    local DeferredInstructions = self._DeferredInstructions
    local InstructionList = DeferredInstructions[SendToCategory]

    if (not InstructionList) then
        InstructionList = table.create(MERGE_LIST_DEFAULT_SIZE)
        DeferredInstructions[SendToCategory] = InstructionList
    end

    -- Record the call
    if (Method == ShortenedMergeName) then
        -- Condense down consecutive merge calls into a single merge call to send to the client
        -- Otherwise begin by just creating a new merge on the list
        -- Note: any theoretical GeneralStore mutation operation that can be *fully* implemented with Merge / Set calls should do so as this is optimised by the following mechanism
        local MergeIn = select(1, ...)
        local LastCall = InstructionList[#InstructionList]
        local LastMerge

        if (LastCall and LastCall.Method == ShortenedMergeName) then
            LastMerge = LastCall.Args[1]
        end

        if (LastMerge) then
            InternalMerge(MergeIn, LastMerge, true)
        else
            table.insert(InstructionList, {
                Method = Method;
                Args = {MergeIn};
            })
        end
    else
        -- Non-merge calls deoptimize the above, but it has to happen to avoid desync
        table.insert(InstructionList, {
            Method = Method;
            Args = {...};
        })
    end

    -- Activate next defer function
    if (not self._Deferring) then
        self._Deferring = true

        local DeferFunction = self.DeferFunction

        if (DeferFunction) then
            DeferFunction(function()
                -- Since this may yield for a later frame, check if ReplicatedStore was Destroyed & reject defer if so
                if (table.isfrozen(self)) then
                    return
                end

                self._Deferring = false
                self:_DeferProcess()
            end)
        else
            self._Deferring = false
            self:_DeferProcess()
        end
    end

    debug.profileend()
end

--- Extension of _PrepareDefer. Initiates a defer point for sending data to the client, during which
--- specific calls will be optimised into a compressed structure.
function ReplicatedStore:_DeferProcess()
    local DeferredInstructions = self._DeferredInstructions
    local BlockedPlayers = self._BlockedPlayers
    local RemoteEvent = self._RemoteEvent

    for PlayerName, Data in DeferredInstructions do
        -- Default category -> send this data to all players except ones in the block list
        if (PlayerName == DEFAULT_SEND_TO_CATEGORY) then
            if (next(BlockedPlayers) == nil) then
                -- No blocked players -> FireAllClients broadcast (more efficient)
                RemoteEvent:FireAllClients(Data, false)
            else
                for _, Player in Players:GetChildren() do
                    if (BlockedPlayers[Player.Name]) then
                        continue
                    end

                    RemoteEvent:FireClient(Player, Data, false)
                end
            end

            continue
        end

        -- Player-specific -> send to that player
        local GotPlayer = Players:FindFirstChild(PlayerName)

        if (not GotPlayer or BlockedPlayers[PlayerName]) then
            continue
        end

        RemoteEvent:FireClient(GotPlayer, Data, false)
    end

    table.clear(self._DeferredInstructions)
    self.OnDefer:Fire()
end

--- Fully syncs this store's data down to a specific client who requests it.
--- Blocks subsequent calls to ensure exploiters cannot overload the server.
function ReplicatedStore:_FullSync(Player: Player, InitialSync: boolean)
    if (self._TestMode) then
        local Package = {{
            Method = "Merge";
            Args = {ConvertToStringIndices(self:GetUsingPathString())};
        }}
        self._RemoteEvent:FireClient(Player, Package, InitialSync)
        return
    end

    local SyncedPlayers = self._SyncedPlayers
    local UserID = Player.UserId

    if (SyncedPlayers[UserID]) then
        print("[ReplicatedStore] Reject sync request from " .. Player.Name)
        return
    end

    SyncedPlayers[UserID] = true

    local Connection; Connection = Player.AncestryChanged:Connect(function(_, NewParent)
        if (NewParent ~= nil) then
            return
        end

        Connection:Disconnect()
        SyncedPlayers[UserID] = nil
    end)

    local Package = {{
        Method = "Merge";
        Args = {ConvertToStringIndices(self:GetUsingPathString())};
    }}
    self._RemoteEvent:FireClient(Player, Package, InitialSync)
end

for OriginalName, ShortenedName in METHOD_SHORTENINGS do
    ReplicatedStore[ShortenedName] = ReplicatedStore[OriginalName]
end

Cleaner.Wrap(ReplicatedStore)

export type ReplicatedStore = typeof(ReplicatedStore)

return ReplicatedStore]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6fb</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF194E4EF2A6946EAB4A2394B1B2755A9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Shared</string>
					<string name="ScriptGuid">{6234D98A-A7D9-46F8-8B95-73094C5D9314}</string>
					<ProtectedString name="Source"><![CDATA[local TypeGuard = require(script.Parent.Parent:WaitForChild("TypeGuard"))

export type StoreKey = string | number
export type StorePath = {StoreKey}

local CachedPathTables = setmetatable({}, {__mode = "k"})

local TYPE_TABLE = "table"

local FLAT_PATH_DELIMITER = "^"
local EMPTY_STRING = ""

local ERR_NO_ITEMS_IN_PATH = "No items in path (no ascendants derivable)"
local ERR_NO_VALUE_GIVEN = "No value given!"
local ERR_NO_PATH_GIVEN = "No path given!"

local REMOVE_NODE = {_REMOVE_NODE = true}

-----------------------------------------------------------------------------------

-- Traverses each item in the table recursively, creating a path string for each
-- Not inclusive of root
local function PathTraverse(Root: any, Path: string, Callback: (string, any, string) -> ())
    for Key, Value in Root do
        local NewPath = Path .. tostring(Key) .. FLAT_PATH_DELIMITER

        if (type(Value) == TYPE_TABLE) then
            PathTraverse(Value, NewPath, Callback)
        end

        -- Pass: new path, value, parent path
        Callback(NewPath, Value, Path)
    end
end

local function GetPathString(Path: StorePath): string
    local PathString = CachedPathTables[Path]

    if (PathString) then
        return PathString
    end

    local Result = EMPTY_STRING

    for _, Value in Path do
        Result ..= tostring(Value) .. FLAT_PATH_DELIMITER
    end

    CachedPathTables[Path] = Result

    return Result
end

local function InternalMerge(Data: any, Into: any, BypassRemoveNode: boolean?)
    for Key, Value in Data do
        if ((not BypassRemoveNode) and Value == REMOVE_NODE) then
            Into[Key] = nil
            continue
        end

        if (typeof(Value) == TYPE_TABLE) then
            local Got = Into[Key]

            if (Got == nil) then
                Got = {}
                Into[Key] = Got
            end

            InternalMerge(Value, Got, BypassRemoveNode)
            continue
        end

        Into[Key] = Value
    end
end

local function BuildFromPath(Path: StorePath, Value: any): any
    assert(Path, ERR_NO_PATH_GIVEN)
    assert(Value ~= nil, ERR_NO_VALUE_GIVEN)

    local Length = #Path

    if (Length == 0) then
        return Value
    end

    local Built = {}
    local Last = Built

    for Index = 1, Length - 1 do
        local Key = Path[Index]
        local Temp = {}
        Last[Key] = Temp
        Last = Temp
    end

    Last[Path[Length]] = Value

    return Built
end

local ValidStorePathAtom = TypeGuard.String():Or(TypeGuard.Number())
local ValidStorePath = TypeGuard.Array(ValidStorePathAtom)

return {
    FlatPathDelimiter = FLAT_PATH_DELIMITER;
    RemoveNode = REMOVE_NODE;

    GetPathString = GetPathString;
    BuildFromPath = BuildFromPath;
    InternalMerge = InternalMerge;
    PathTraverse = PathTraverse;

    ValidStorePath = ValidStorePath;
};]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6fc</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX86A6639C9FCB4B35BF5EF7FD7971DEBC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreInterface</string>
					<string name="ScriptGuid">{AF2080C4-EA96-4525-9AC3-92E331345116}</string>
					<ProtectedString name="Source"><![CDATA[local TypeGuard = require(script.Parent.Parent:WaitForChild("TypeGuard"))
local Cleaner = require(script.Parent.Parent:WaitForChild("Cleaner"))
local XSignal = require(script.Parent.Parent:WaitForChild("XSignal"))
    type Signal<T> = XSignal.XSignal<T>

local Shared = require(script.Parent:WaitForChild("Shared"))
    local RemoveNode = Shared.RemoveNode
    local BuildFromPath = Shared.BuildFromPath
    type StorePath = Shared.StorePath
local TableUtil = require(script.Parent.Parent:WaitForChild("TableUtil"))
    local Merge1D = TableUtil.Array.Merge1D

local ReplicatedStore = require(script.Parent:WaitForChild("ReplicatedStore"))
local GeneralStore = require(script.Parent:WaitForChild("GeneralStore"))

local VALIDATE_PARAMS = true
local TYPE_TABLE = "table"

local ValidStorePath = Shared.ValidStorePath
local GetPathString = Shared.GetPathString

local StoreInterface = {}
StoreInterface.__index = StoreInterface

local ConstructorParams = TypeGuard.Params(TypeGuard.Object():OfClass(ReplicatedStore):Or(TypeGuard.Object():OfClass(GeneralStore)):FailMessage("Arg #1 supplied must be a ReplicatedStore or a GeneralStore"), ValidStorePath:Optional())
--- Creates a new StoreInterface object.
function StoreInterface.new(StoreObject: any, Path: StorePath?): typeof(StoreInterface)
    if (VALIDATE_PARAMS) then
        ConstructorParams(StoreObject, Path)
    end

    Path = Path or {}

    local self = {
        _StoreObject = StoreObject;
        _PathString = GetPathString(Path);
        _Path = Path;
    };

    return setmetatable(self, StoreInterface)
end

--- Gets a value in the real store.
function StoreInterface:Get(DefaultValue: any?): any?
    return self._StoreObject:GetUsingPathString(self._PathString, DefaultValue)
end
StoreInterface.get = StoreInterface.Get

--- Sets a value in the real store.
function StoreInterface:Set(...)
    self._StoreObject:SetUsingPathArray(self._Path, ...)
end
StoreInterface.set = StoreInterface.Set

--- Waits for a value in the real store to exist.
function StoreInterface:Await(Timeout: number?, BypassError: boolean?): any?
    return self._StoreObject:AwaitUsingPathString(self._PathString, Timeout, BypassError)
end
StoreInterface.await = StoreInterface.Await

--- Merges a table into the real store. Does NOT start at the path, starts at the root.
function StoreInterface:Merge(Value: any?)
    -- TODO: progressively build up path container internally too maybe?
    if (next(self._Path) == nil) then
        self._StoreObject:Merge(Value)
    else
        self._StoreObject:Merge(BuildFromPath(self._Path, Value == nil and RemoveNode or Value))
    end

    --[[ self._StoreObject:Merge(BuildFromPath(self._Path, Value == nil and RemoveNode or Value)) ]]
end
StoreInterface.merge = StoreInterface.Merge

--- Extends this StoreInterface's path by a new path and gets the value corresponding to that path.
function StoreInterface:XGet(Path): any?
    return self:Extend(Path):Get()
end
StoreInterface.xGet = StoreInterface.XGet

--- Extends this StoreInterface's path by a new path and sets the value corresponding to that path.
function StoreInterface:XSet(Path, ...)
    self:Extend(Path):Set(...)
end
StoreInterface.xSet = StoreInterface.XSet

--- Extends this StoreInterface's path by a new path and waits for the value corresponding to that path to exist.
function StoreInterface:XAwait(Path, Timeout: number?, BypassError: boolean?): any?
    return self:Extend(Path):Await(Timeout, BypassError)
end
StoreInterface.xAwait = StoreInterface.XAwait

--- Extends this StoreInterface's path by a new path and merges a table into the value corresponding on that path.
function StoreInterface:XMerge(Path, ...)
    self:Extend(Path):Merge(...)
end
StoreInterface.xMerge = StoreInterface.XMerge

--- Increments a numerical value in the real store, with an optional default value if it doesn't exist.
--- Note: temporarily deoptimizes replicated store merge batching.
function StoreInterface:Increment(ByAmount: number, DefaultValue: number?, ...): number
    return self._StoreObject:IncrementUsingPathArray(self._Path, ByAmount, DefaultValue, ...)
end
StoreInterface.increment = StoreInterface.Increment

--- Removes a value from an array in the real store.
function StoreInterface:ArrayRemove(...): (any?, number)
    return self._StoreObject:ArrayRemoveUsingPathString(self._PathString, ...)
end
StoreInterface.arrayRemove = StoreInterface.ArrayRemove

--- Inserts a value into an array in the real store.
function StoreInterface:ArrayInsert(...): number?
    return self._StoreObject:ArrayInsertUsingPathString(self._PathString, ...)
end
StoreInterface.arrayInsert = StoreInterface.ArrayInsert

-- TODO: port these to GeneralStore
--[[ function StoreInterface:IsContainer()
    return (type(self:Get()) == TYPE_TABLE)
end; StoreInterface.isContainer = StoreInterface.IsContainer

function StoreInterface:IsArray()
    return (self:IsContainer() and self:Get()[1] ~= nil)
end; StoreInterface.isArray = StoreInterface.IsArray

function StoreInterface:IsEmpty()
    return (self:IsContainer() and next(self:Get()) == nil)
end; StoreInterface.isEmpty = StoreInterface.IsEmpty

function StoreInterface:IsMap()
    return (self:IsContainer() and not self:IsArray() and next(self:Get()) ~= nil)
end; StoreInterface.isMap = StoreInterface.IsMap

function StoreInterface:IsLeaf()
    return (self:Get() ~= nil and not self:IsContainer())
end StoreInterface.isLeaf = StoreInterface.IsLeaf ]]

--- Gets a value changed signal from the real store.
function StoreInterface:GetValueChangedSignal(): typeof(XSignal)
    return self._StoreObject:GetValueChangedSignalUsingPathArray(self._Path)
end
StoreInterface.getValueChangedSignal = StoreInterface.GetValueChangedSignal

--- Creates a new StoreInterface with an extension of the path.
function StoreInterface:Extend(Extra: any): typeof(StoreInterface)
    return StoreInterface.new(self._StoreObject, Merge1D(self._Path, (type(Extra) == TYPE_TABLE and Extra or {Extra})))
end
StoreInterface.extend = StoreInterface.Extend

--- Sets debug logging on/off for the whole store.
function StoreInterface:SetDebugLog(DebugLog: boolean)
    self._StoreObject:SetDebugLog(DebugLog)
end
StoreInterface.setDebugLog = StoreInterface.SetDebugLog

function StoreInterface:Destroy()
end

Cleaner.Wrap(StoreInterface)

return StoreInterface]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7824bb5ee717932e02e531aa0002e6fe</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4BCE79603C8A494AB5904217B481D0E7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ReplicatedStore.spec</string>
					<string name="ScriptGuid">{BA799A7F-99A0-46D3-AA72-6DABFFA09357}</string>
					<ProtectedString name="Source"><![CDATA[return function()
    local MockRemoteEvent = require(script.Parent:WaitForChild("MockRemoteEvent"))
    local ReplicatedStore = require(script.Parent:WaitForChild("ReplicatedStore"))

    -- Obtains client and server test objects, and a fake remote event between them
    local function GetTestObject()
        local ClientRemote = MockRemoteEvent.new()
        local ServerRemote = MockRemoteEvent.new()

        ClientRemote.OnFire = function(...)
            ServerRemote.Bind:Fire(...)
        end

        ServerRemote.OnFire = function(...)
            ClientRemote.Bind:Fire(...)
        end

        local Client = ReplicatedStore.new(ClientRemote, false)
        local Server = ReplicatedStore.new(ServerRemote, true)

        Client._TestMode = true
        Server._TestMode = true

        Server:InitServer()
        Client:InitClient()

        return Client, Server
    end

    -- Checks if two tables are equal
    local function Equivalent(Initial, Other)
        for InitialKey, InitialValue in Initial do
            local OtherValue = Other[InitialKey]

            if (OtherValue == nil) then
                return false
            end

            if (type(InitialValue) == "table") then
                if (not Equivalent(InitialValue, OtherValue)) then
                    return false
                end
            elseif (OtherValue ~= InitialValue) then
                return false
            end
        end

        for OtherKey in Other do
            if (Initial[OtherKey] == nil) then
                return false
            end
        end

        return true
    end

    describe("ReplicatedStore.new", function()
        it("should construct", function()
            expect(function()
                GetTestObject()
            end).never.to.throw()
        end)
    end)

    describe("ReplicatedStore.Set", function()
        it("should sync initial state", function()
            local ClientRemote = MockRemoteEvent.new()
            local ServerRemote = MockRemoteEvent.new()

            ClientRemote.OnFire = function(...)
                ServerRemote.Bind:Fire(...)
            end

            ServerRemote.OnFire = function(...)
                ClientRemote.Bind:Fire(...)
            end

            local Client = ReplicatedStore.new(ClientRemote, false)
            local Server = ReplicatedStore.new(ServerRemote, true)

            Client._TestMode = true
            Server._TestMode = true

            Server:InitServer()

            Server:SetUsingPathArray({"A"}, true)
            Server:SetUsingPathArray({"B", "C"}, 1000)
            Server:SetUsingPathArray({"B", "C"}, 1125)

            Client:InitClient()

            expect(Client:GetUsingPathArray().A).to.be.ok()
            expect(Client:GetUsingPathArray().B).to.be.ok()
            expect(Client:GetUsingPathArray().B.C).to.be.ok()

            expect(Client:GetUsingPathArray().A).to.equal(true)
            expect(Client:GetUsingPathArray().B.C).to.equal(1125)
        end)

        it("should set flat values", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A"}, true)
            Server:SetUsingPathArray({"B"}, true)

            expect(Server:GetUsingPathArray().A).to.equal(true)
            expect(Client:GetUsingPathArray().A).to.equal(true)

            expect(Server:GetUsingPathArray().B).to.equal(true)
            expect(Client:GetUsingPathArray().B).to.equal(true)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should set flat value 'false'", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A"}, false)
            Server:SetUsingPathArray({"B"}, false)

            expect(Server:GetUsingPathArray().A).to.equal(false)
            expect(Client:GetUsingPathArray().A).to.equal(false)

            expect(Server:GetUsingPathArray().B).to.equal(false)
            expect(Client:GetUsingPathArray().B).to.equal(false)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should set deep values", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A", "B", "C"}, 100)

            expect(Server:GetUsingPathArray().A.B.C).to.equal(100)
            expect(Client:GetUsingPathArray().A.B.C).to.equal(100)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should throw on empty path i.e. root overwrite", function()
            local Client, Server = GetTestObject()

            expect(function()
                Server:SetUsingPathArray({}, 100)
            end).to.throw()
        end)

        it("should set flat values in order", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A"}, true)
            Server:SetUsingPathArray({"A"}, 9000)

            Server:SetUsingPathArray({"B"}, true)
            Server:SetUsingPathArray({"B"}, 1000)

            expect(Server:GetUsingPathArray().A).to.equal(9000)
            expect(Client:GetUsingPathArray().A).to.equal(9000)

            expect(Server:GetUsingPathArray().B).to.equal(1000)
            expect(Client:GetUsingPathArray().B).to.equal(1000)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should set deep values in order", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A", "B", "C"}, 100)

            expect(Server:GetUsingPathArray().A.B.C).to.equal(100)
            expect(Client:GetUsingPathArray().A.B.C).to.equal(100)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should send and receive large sample data", function()
            -- TODO: remove mixed keys
            local Client, Server = GetTestObject()
            local Generator = Random.new(os.clock())

            for _ = 1, 100 do
                local Path = {}
                local FinalValue = (Generator:NextNumber() > 0.5 and Generator:NextInteger(1, 10e8) or tostring(Generator:NextInteger(1, 10e8)))

                for Depth = 1, Generator:NextInteger(1, 5) do
                    Path[Depth] = (Generator:NextNumber() > 0.5 and Generator:NextInteger(1, 10e8) or tostring(Generator:NextInteger(1, 10e8)))
                end

                Server:SetUsingPathArray(Path, FinalValue)
            end

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should convert keys to numeric when applicable", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({1, "201", "AHHH"}, true)

            expect(Client:GetUsingPathArray()[1]).to.be.ok()
            expect(Client:GetUsingPathArray()[1][201]).to.be.ok()
            expect(Client:GetUsingPathArray()[1][201].AHHH).to.be.ok()

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)

        it("should not allow mixed keys", function()
            local Client, Server = GetTestObject()

            expect(function()
                Server:SetUsingPathArray({1}, true)
                Server:SetUsingPathArray({"a"}, true)
            end).to.throw()

            expect(function()
                Server:SetUsingPathArray({"a"}, true)
                Server:SetUsingPathArray({1}, true)
            end).to.throw()
        end)

        it("should trigger await events for tables being overwritten by atoms", function()
            local Client, Server = GetTestObject()

            Server:SetUsingPathArray({"One", "Two", "Three"}, true)

            local Fired1 = false
            local Fired2 = false
            local Fired3 = false

            Server:GetValueChangedSignalUsingPathArray({"One", "Two", "Three", "Four"}):Connect(function(Value)
                -- Shouldn't fire for non-existent nodes
                Fired3 = true
            end)

            Server:GetValueChangedSignalUsingPathArray({"One", "Two", "Three"}):Connect(function(Value)
                expect(Value).to.equal(nil)
                Fired1 = true
            end)

            Server:GetValueChangedSignalUsingPathArray({"One"}):Connect(function(Value)
                expect(Value).to.equal(200)
                Fired2 = true
            end)

            expect(Fired1).to.equal(false)
            expect(Fired2).to.equal(false)
            expect(Fired3).to.equal(false)
            Server:SetUsingPathArray({"One"}, 200)
            expect(Fired1).to.equal(true)
            expect(Fired2).to.equal(true)
            expect(Fired3).to.equal(false)
        end)

        it("should delete values when nil is passed", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"HHH", "B"}, true)

            expect(Server:GetUsingPathArray().HHH).to.be.ok()
            expect(Client:GetUsingPathArray().HHH).to.be.ok()
            expect(Server:GetUsingPathArray().HHH.B).to.be.ok()
            expect(Client:GetUsingPathArray().HHH.B).to.be.ok()

            Server:SetUsingPathArray({"HHH", "B"}, nil)

            expect(Server:GetUsingPathArray().HHH.B).never.to.be.ok()
            expect(Client:GetUsingPathArray().HHH.B).never.to.be.ok()

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)
    end)

    describe("ReplicatedStore.Merge", function()
        it("should batch merges correctly with value creation", function()
            local Client, Server = GetTestObject()
            Server.DeferFunction = function(Func)
                task.delay(0.1, Func)
            end

            Server:Merge({
                X = {
                    P = 1;
                };
            })
            Server:Merge({
                X = {
                    Q = 1;
                };
            })
            Server:Merge({
                X = {
                    R = 1;
                };
            })

            expect(Server:GetUsingPathArray().X.P).to.equal(1)
            expect(Server:GetUsingPathArray().X.Q).to.equal(1)
            expect(Server:GetUsingPathArray().X.R).to.equal(1)

            expect(Client:GetUsingPathArray().X).to.equal(nil)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(false)

            task.wait(0.1)

            expect(Server:GetUsingPathArray().X.P).to.equal(1)
            expect(Server:GetUsingPathArray().X.Q).to.equal(1)
            expect(Server:GetUsingPathArray().X.R).to.equal(1)
            expect(Client:GetUsingPathArray().X.P).to.equal(1)
            expect(Client:GetUsingPathArray().X.Q).to.equal(1)
            expect(Client:GetUsingPathArray().X.R).to.equal(1)

            expect(Equivalent(Client:GetUsingPathArray(), Server:GetUsingPathArray())).to.equal(true)
        end)
    end)

    describe("ReplicatedStore.Get", function()
        it("should return the main table with no arguments", function()
            local Client, Server = GetTestObject()
            expect(Client:GetUsingPathArray()).to.equal(Client:GetUsingPathArray())
            expect(Server:GetUsingPathArray()).to.equal(Server:GetUsingPathArray())
        end)

        it("should return nil for paths which do not exist", function()
            local Client, Server = GetTestObject()
            expect(Client:GetUsingPathArray({"A", "B"})).never.to.be.ok()
            expect(Server:GetUsingPathArray({"A", "B"})).never.to.be.ok()
        end)
    end)

    describe("ReplicatedStore.SetUsingPathArray, ReplicatedStore.GetUsingPathArray", function()
        it("should correctly retrieve flat values", function()
            local Client, Server = GetTestObject()
            expect(Client:GetUsingPathArray({"A"})).never.to.be.ok()
            Server:SetUsingPathArray({"A"}, true)
            expect(Client:GetUsingPathArray({"A"})).to.be.ok()
        end)

        it("should correctly retrieve nested values", function()
            local Client, Server = GetTestObject()
            expect(Client:GetUsingPathArray({"A", "B", "C"})).never.to.be.ok()
            Server:SetUsingPathArray({"A", "B", "C"}, true)
            expect(Client:GetUsingPathArray({"A", "B", "C"})).to.be.ok()
        end)
    end)

    describe("ReplicatedStore.Await", function()
        it("should return if value is already present", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A"}, 1)
            expect(Client:AwaitUsingPathArray({"A"})).to.equal(1)
        end)

        it("should return if value is already present on the server", function()
            local Client, Server = GetTestObject()
            Server:SetUsingPathArray({"A"}, 1)
            expect(Server:AwaitUsingPathArray({"A"})).to.equal(1)
        end)

        it("should await a flat value", function()
            local WAIT_TIME = 0.2
            local Client, Server = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                Server:SetUsingPathArray({"A"}, 1)
            end)

            local Time = os.clock()
            expect(Client:AwaitUsingPathArray({"A"})).to.equal(1)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a flat value on the server", function()
            local WAIT_TIME = 0.2
            local Client, Server = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                Server:SetUsingPathArray({"A"}, 1)
            end)

            local Time = os.clock()
            expect(Server:AwaitUsingPathArray({"A"})).to.equal(1)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a deep value", function()
            local WAIT_TIME = 0.2
            local Client, Server = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                Server:SetUsingPathArray({"A", "B", "C"}, 1)
            end)

            local Time = os.clock()
            expect(Client:AwaitUsingPathArray({"A", "B", "C"})).to.equal(1)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a deep value on the server", function()
            local WAIT_TIME = 0.2
            local Client, Server = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                Server:SetUsingPathArray({"A", "B", "C"}, 1)
            end)

            local Time = os.clock()
            expect(Server:AwaitUsingPathArray({"A", "B", "C"})).to.equal(1)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a values in sub-tables", function()
            local WAIT_TIME = 0.2
            local Client, Server = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                Server:SetUsingPathArray({"A", "B"}, {
                    TEST = 1;
                })
                Server:SetUsingPathArray({"C"}, {
                    D = 2;
                })
            end)

            local Time = os.clock()

            task.spawn(function()
                expect(Client:AwaitUsingPathArray({"A", "B", "TEST"})).to.equal(1)
            end)

            expect(Client:AwaitUsingPathArray({"C", "D"})).to.equal(2)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should await a values in sub-tables on server", function()
            local WAIT_TIME = 0.2
            local Client, Server = GetTestObject()

            task.spawn(function()
                task.wait(WAIT_TIME)
                Server:SetUsingPathArray({"A", "B"}, {
                    TEST = 1;
                })
                Server:SetUsingPathArray({"C"}, {
                    D = 2;
                })
            end)

            local Time = os.clock()

            task.spawn(function()
                expect(Server:AwaitUsingPathArray({"A", "B", "TEST"})).to.equal(1)
            end)

            expect(Server:AwaitUsingPathArray({"C", "D"})).to.equal(2)
            expect(os.clock() - Time >= WAIT_TIME).to.equal(true)
        end)

        it("should timeout", function()
            local TIMEOUT = 0.2
            local Client, _Server = GetTestObject()

            local Time = os.clock()

            expect(pcall(function()
                Client:AwaitUsingPathArray({"A"}, TIMEOUT)
            end)).to.equal(false)

            expect(os.clock() - Time >= TIMEOUT).to.equal(true)
        end)
    end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6a7a3a670dadb44e02e77a310002e16d</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX894FAACC7C52453ABB596E92205EB5D9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreInterface.spec</string>
					<string name="ScriptGuid">{69F701AD-EE40-462A-A37D-368F1AF590E1}</string>
					<ProtectedString name="Source"><![CDATA[return function()
    local ReplicatedStore = require(script.Parent:WaitForChild("ReplicatedStore"))
    local MockRemoteEvent = require(script.Parent:WaitForChild("MockRemoteEvent"))
    local StoreInterface = require(script.Parent:WaitForChild("StoreInterface"))

    local function GetTestObject()
        local ClientRemote = MockRemoteEvent.new()
        local ServerRemote = MockRemoteEvent.new()

        ClientRemote.OnFire = function(...)
            ServerRemote.Bind:Fire(...)
        end

        ServerRemote.OnFire = function(...)
            ClientRemote.Bind:Fire(...)
        end

        local Client = ReplicatedStore.new(ClientRemote, false)
        local Server = ReplicatedStore.new(ServerRemote, true)

        Client._TestMode = true
        Server._TestMode = true

        Server:InitServer()
        Client:InitClient()

        local ContainerClient = StoreInterface.new(Client)
        local ContainerServer = StoreInterface.new(Server)

        return ContainerClient, ContainerServer, Client, Server
    end

    local function Equivalent(Initial, Other)
        if (Initial == nil or Other == nil) then
            return false
        end

        for Key, Value in Initial do
            local OtherValue = Other[Key]

            if (OtherValue == nil) then
                return false
            end

            if (type(Value) ~= type(OtherValue)) then
                return false
            end

            if (type(Value) == "table") then
                if (not Equivalent(Value, OtherValue)) then
                    return false
                end
            elseif (Value ~= OtherValue) then
                return false
            end
        end

        return true
    end

    describe("StoreInterface.new", function()
        it("should construct", function()
            expect(function()
                GetTestObject()
            end).never.to.throw()
        end)
    end)

    describe("StoreInterface.Get, StoreInterface.Set, StoreInterface.Extend", function()
        it("should return the blank root alone", function()
            local _, Server, _, ServerReplication = GetTestObject()
            expect(Server:Get()).to.equal(ServerReplication._Store._Store)
        end)

        it("should return a flat item", function()
            local Client, Server, ClientReplication, ServerReplication = GetTestObject()

            local ServerTest = Server:Extend("Test")
            ServerTest:Set(30)
            expect(ServerTest:Get()).to.equal(30)
            expect(ServerReplication:GetUsingPathArray({"Test"})).to.equal(30)

            local ClientTest = Client:Extend("Test")
            expect(ClientTest:Get()).to.equal(30)
            expect(ClientReplication:GetUsingPathArray({"Test"})).to.equal(30)
        end)

        it("should return a deep item", function()
            local Client, Server, ClientReplication, ServerReplication = GetTestObject()

            local ServerTest = Server:Extend("Test")
                local ServerTest2 = ServerTest:Extend("Test2")

            ServerTest2:Set(30)
            expect(ServerTest2:Get()).to.equal(30)
            expect(ServerReplication:GetUsingPathArray({"Test", "Test2"})).to.equal(30)

            local ClientTest = Client:Extend("Test")
                local ClientTest2 = ClientTest:Extend("Test2")

            expect(ClientTest2:Get()).to.equal(30)
            expect(ClientReplication:GetUsingPathArray({"Test", "Test2"})).to.equal(30)
        end)
    end)

    describe("StoreInterface.Await", function()
        it("should immediately return a flat item", function()
            local Client, Server, _, _ = GetTestObject()

            local ServerTest = Server:Extend("Test")
            ServerTest:Set(30)
            expect(ServerTest:Await()).to.equal(30)

            local ClientTest = Client:Extend("Test")
            expect(ClientTest:Await()).to.equal(30)
        end)

        it("should immediately return a deep item", function()
            local Client, Server, _, _ = GetTestObject()

            local Level1Server = Server:Extend("Level1")
                local Level2Server = Level1Server:Extend("Level2")
                Level2Server:Set(1234)

            expect(Level2Server:Await()).to.equal(1234)

            local Level1Client = Client:Extend("Level1")
                local Level2Client = Level1Client:Extend("Level2")
                expect(Level2Client:Await()).to.equal(1234)
        end)

        it("should return a flat item when present", function()
            local Client, Server, _, _ = GetTestObject()

            local ServerTest = Server:Extend("Test")

            task.delay(0.1, function()
                ServerTest:Set(30)
            end)

            expect(ServerTest:Await()).to.equal(30)

            local ClientTest = Client:Extend("Test")
            expect(ClientTest:Await()).to.equal(30)
        end)

        it("should return a deep item when present", function()
            local Client, Server, _, _ = GetTestObject()

            local Level1Server = Server:Extend("Level1")
                local Level2Server = Level1Server:Extend("Level2")

            task.delay(0.1, function()
                Level2Server:Set(1234)
            end)

            expect(Level2Server:Await()).to.equal(1234)

            local Level1Client = Client:Extend("Level1")
                local Level2Client = Level1Client:Extend("Level2")
                expect(Level2Client:Await()).to.equal(1234)
        end)
    end)

    --[[ describe("StoreInterface.IsContainer, StoreInterface.IsArray, StoreInterface.IsMap, StoreInterface.IsLeaf", function()
        it("should not satisfy any of the four types if nil", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            expect(TestServer:IsContainer()).to.equal(false)
            expect(TestServer:IsArray()).to.equal(false)
            expect(TestServer:IsMap()).to.equal(false)
            expect(TestServer:IsLeaf()).to.equal(false)

            local TestClient = Client:Extend("Test")
            expect(TestClient:IsContainer()).to.equal(false)
            expect(TestClient:IsArray()).to.equal(false)
            expect(TestClient:IsMap()).to.equal(false)
            expect(TestClient:IsLeaf()).to.equal(false)
        end)

        it("should detect when an item is a container", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set({})
            expect(TestServer:IsContainer()).to.equal(true)
            expect(TestServer:IsArray()).to.equal(false)
            expect(TestServer:IsMap()).to.equal(false)
            expect(TestServer:IsLeaf()).to.equal(false)

            local TestClient = Client:Extend("Test")
            expect(TestClient:IsContainer()).to.equal(true)
            expect(TestClient:IsArray()).to.equal(false)
            expect(TestClient:IsMap()).to.equal(false)
            expect(TestClient:IsLeaf()).to.equal(false)
        end)

        it("should detect when an item is an array", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set({1, 2, 3})
            expect(TestServer:IsContainer()).to.equal(true)
            expect(TestServer:IsArray()).to.equal(true)
            expect(TestServer:IsMap()).to.equal(false)
            expect(TestServer:IsLeaf()).to.equal(false)

            local TestClient = Client:Extend("Test")
            expect(TestClient:IsContainer()).to.equal(true)
            expect(TestClient:IsArray()).to.equal(true)
            expect(TestClient:IsMap()).to.equal(false)
            expect(TestClient:IsLeaf()).to.equal(false)
        end)

        it("should detect when an item is a map", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set({a = 1, b = 2})
            expect(TestServer:IsContainer()).to.equal(true)
            expect(TestServer:IsArray()).to.equal(false)
            expect(TestServer:IsMap()).to.equal(true)
            expect(TestServer:IsLeaf()).to.equal(false)

            local TestClient = Client:Extend("Test")
            expect(TestClient:IsContainer()).to.equal(true)
            expect(TestClient:IsArray()).to.equal(false)
            expect(TestClient:IsMap()).to.equal(true)
            expect(TestClient:IsLeaf()).to.equal(false)
        end)

        it("should detect when an item is a leaf", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set(1234)
            expect(TestServer:IsContainer()).to.equal(false)
            expect(TestServer:IsArray()).to.equal(false)
            expect(TestServer:IsMap()).to.equal(false)
            expect(TestServer:IsLeaf()).to.equal(true)

            local TestClient = Client:Extend("Test")
            expect(TestClient:IsContainer()).to.equal(false)
            expect(TestClient:IsArray()).to.equal(false)
            expect(TestClient:IsMap()).to.equal(false)
            expect(TestClient:IsLeaf()).to.equal(true)
        end)
    end) ]]

    describe("StoreInterface.Increment", function()
        it("should throw if a number is not passed", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set(0)

            expect(function()
                TestServer:Increment(true)
            end).to.throw()

            expect(function()
                TestServer:Increment({})
            end).to.throw()

            expect(function()
                TestServer:Increment(1)
            end).never.to.throw()
        end)

        it("should throw if existing value is not a number", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set(true)

            expect(function()
                TestServer:Increment(1)
            end).to.throw()
        end)

        it("should accept numeric values if the existing value is a number", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set(0)

            expect(function()
                TestServer:Increment(1)
            end).never.to.throw()
        end)

        it("should increment existing numeric values", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set(0)
            expect(TestServer:Get()).to.equal(0)
            TestServer:Increment(1)
            expect(TestServer:Get()).to.equal(1)
            TestServer:Increment(2)
            expect(TestServer:Get()).to.equal(3)
        end)

        it("should increment by 1 by default", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set(0)
            expect(TestServer:Get()).to.equal(0)
            TestServer:Increment()
            expect(TestServer:Get()).to.equal(1)
            TestServer:Increment()
            expect(TestServer:Get()).to.equal(2)
        end)
    end)

    describe("StoreInterface.GetValueChangedSignal", function()
        it("return the signal", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            local TestClient = Client:Extend("Test")

            local ConnectionServer = TestServer:GetValueChangedSignal():Connect(function(_) end)
            local ConnectionClient = TestClient:GetValueChangedSignal():Connect(function(_) end)

            expect(ConnectionServer).to.be.ok()
            expect(ConnectionClient).to.be.ok()

            ConnectionServer:Disconnect()
            ConnectionClient:Disconnect()
        end)

        it("should fire on value change", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            local TestClient = Client:Extend("Test")

            local ClientValue, ServerValue

            local ConnectionServer = TestServer:GetValueChangedSignal():Connect(function(Value)
                ServerValue = Value
            end)

            local ConnectionClient = TestClient:GetValueChangedSignal():Connect(function(Value)
                ClientValue = Value
            end)

            expect(ClientValue).never.to.be.ok()
            expect(ServerValue).never.to.be.ok()

            TestServer:Set(1234)

            expect(ClientValue).to.equal(1234)
            expect(ServerValue).to.equal(1234)

            ConnectionServer:Disconnect()
            ConnectionClient:Disconnect()
        end)
    end)

    describe("StoreInterface.ArrayInsert", function()
        it("should allow insertion into an empty array", function()
            local _, Server, _, _ = GetTestObject()
            local TestServer = Server:Extend("Test")

            TestServer:Set({})
            TestServer:ArrayInsert(1)
        end)

        it("should reject a non-array", function()
            local _, Server, _, _ = GetTestObject()
            local TestServer = Server:Extend("Test")

            TestServer:Set(1234)

            expect(function()
                TestServer:ArrayInsert(1)
            end).to.throw()

            TestServer:Set("")

            expect(function()
                TestServer:ArrayInsert(1)
            end).to.throw()

            TestServer:Set({
                Test = true
            })

            expect(function()
                TestServer:ArrayInsert(1)
            end).to.throw()

            TestServer:Set(true)

            expect(function()
                TestServer:ArrayInsert(1)
            end).to.throw()
        end)

        it("should insert into an empty array", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            local TestClient = Client:Extend("Test")

            TestServer:Set({})
            TestServer:ArrayInsert(1)

            expect(TestServer:Get()[1]).to.equal(1)
            expect(TestClient:Get()[1]).to.equal(1)
        end)

        it("should insert multiple times into an array", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            local TestClient = Client:Extend("Test")

            TestServer:Set({})
            TestServer:ArrayInsert(1)
            TestServer:ArrayInsert(2)
            TestServer:ArrayInsert(3)

            expect(TestServer:Get()[1]).to.equal(1)
            expect(TestServer:Get()[2]).to.equal(2)
            expect(TestServer:Get()[3]).to.equal(3)
            expect(TestClient:Get()[1]).to.equal(1)
            expect(TestClient:Get()[2]).to.equal(2)
            expect(TestClient:Get()[3]).to.equal(3)
        end)

        it("should shift everything up for mid-array inserts", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer1 = Server:Extend("Test1")
            TestServer1:Set({1})
            TestServer1:ArrayInsert(123, 2)
            TestServer1:ArrayInsert(456, 1)

            expect(TestServer1:Get()[1]).to.equal(456)
            expect(TestServer1:Get()[2]).to.equal(1)
            expect(TestServer1:Get()[3]).to.equal(123)
        end)
    end)

    describe("StoreInterface.ArrayRemove", function()
        it("should allow an empty array", function()
            local _, Server, _, _ = GetTestObject()
            local TestServer = Server:Extend("Test")

            TestServer:Set({})
            TestServer:ArrayRemove()
        end)

        it("should allow an array with 1 item", function()
            local _, Server, _, _ = GetTestObject()
            local TestServer = Server:Extend("Test")

            TestServer:Set({1})
            TestServer:ArrayRemove()
        end)

        it("should reject a non-array", function()
            local _, Server, _, _ = GetTestObject()
            local TestServer = Server:Extend("Test")

            TestServer:Set(1234)

            expect(function()
                TestServer:ArrayRemove()
            end).to.throw()

            TestServer:Set("")

            expect(function()
                TestServer:ArrayRemove()
            end).to.throw()

            TestServer:Set({
                Test = true
            })

            expect(function()
                TestServer:ArrayRemove()
            end).to.throw()

            TestServer:Set(true)

            expect(function()
                TestServer:ArrayRemove()
            end).to.throw()
        end)

        it("should remove from a non-empty array multiple times", function()
            local Client, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            local TestClient = Client:Extend("Test")

            TestServer:Set({1, 2, 3})
            expect(next(TestClient:Get())).never.to.equal(nil)

            TestServer:ArrayRemove()
            expect(TestServer:Get()[1]).to.equal(1)
            expect(TestServer:Get()[2]).to.equal(2)
            expect(TestServer:Get()[3]).to.equal(nil)
            TestServer:ArrayRemove()
            expect(TestServer:Get()[1]).to.equal(1)
            expect(TestServer:Get()[2]).to.equal(nil)
            expect(TestServer:Get()[3]).to.equal(nil)
            TestServer:ArrayRemove()
            expect(TestServer:Get()[1]).to.equal(nil)
            expect(TestServer:Get()[2]).to.equal(nil)
            expect(TestServer:Get()[3]).to.equal(nil)

            expect(next(TestClient:Get())).to.equal(nil)
        end)

        it("should remove from a mid-position and shift down", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set({1, 2, 3})
            TestServer:ArrayRemove(2)

            expect(TestServer:Get()[1]).to.equal(1)
            expect(TestServer:Get()[2]).to.equal(3)
        end)

        it("should return the removed item and index", function()
            local _, Server, _, _ = GetTestObject()

            local TestServer = Server:Extend("Test")
            TestServer:Set({1, 2, 3})
            local Value, Index = TestServer:ArrayRemove(2)
            expect(Value).to.equal(2)
            expect(Index).to.equal(2)

            expect(TestServer:Get()[1]).to.equal(1)
            expect(TestServer:Get()[2]).to.equal(3)
        end)
    end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6a7a3a670dadb44e02e77a310002e16f</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="TweenService" referent="RBX69D6CE193A934907B524FE9B74E62597">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f498</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX7FE78236F732423B83572C39C16D55B8">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f499</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX16CFA4C4BFBE4CE3A1D10F2DF20D78FD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f49a</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBXBB432341C2744FFD9DDFABCFB10AC6E3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f58f</UniqueId>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBX9442596B30C64663BA721FB229ECCACA">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatInputBarConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f590</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX7F2140B09A264E0E949029D021E885A0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f49e</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXAF3A3EA685DE44878B5CBE17CFF714A2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4a0</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX354E76AF5E484D17A0E25C62B17848A0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">0</int64>
			<int64 name="SrcUniverseId">0</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4a3</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBXF27B92A7CA6F485C8C3503A91CEA8C69">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4a4</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX68AD80CCC454431CB0F8B1C696EC9885">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f58d</UniqueId>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX4C1E181592504F9BAA3E5FA5BF7A18F4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f58e</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXA85216668EE84B208E5E9BE79A85F599">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4a5</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX3B984873F2B0459EA01C528FF501DFC4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4a6</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX1297BD637BDB493697A8D906D3583781">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4a8</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX1236032F7C0F4C078A71A2D660C4A9F3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4ac</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXC4DEF9C2BBD24C3BBCF88CBFF46E4348">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4ae</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX4C42CA522FD447128BE89565EC23C379">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4af</UniqueId>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX2319FD6FBBFE45C28CCCA8911EAA886F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4b1</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXCC334A8B68734B72849810C62ED94AE1">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4b3</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBX191BB3D2A63B4D42AB58809FD02BC3BD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0004ee9e</UniqueId>
				<string name="Value">{F14418F6-0AB7-4C2D-A4CA-EC716E459F41}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX465F096C16864188B8BBE03AD08B97A7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4b4</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXDA73CDA8D53445878660B94A93BC6D6B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4b5</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX106CE338D20C44268BCD61950BA37973">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4b6</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX108A7FF0A9144B3FAD23580AF688D203">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4c0</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX0E966D92B18C4128AAD9FF97F9A11062">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4c2</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXB63FE2D65FF04DAB97B51DF382099DA2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4c4</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXF8C9C5F01189471F9B2F568EE10A322E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4c5</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX8FD77F6A4EF049B186F9F40C35C7703D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4c6</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBX1F7BF87095214C64AB4063720D3E02C5">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4c9</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX1966B9A16654432D9A3F0A0763C9899C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4cc</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX7DBDD3913B754038B924EBDA932C37D9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4cd</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerStorage" referent="RBXD64A74FA170346D7B3BDAA2D2A104C49">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4ce</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX90FEDB7E171D47E8B67FF6DD4248512B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4cf</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBXA19BAC60FA534E12A34D5F02591038FB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4d6</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBXCB24B39DDF004597A58D1F0C7C688587">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f4d7</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX386FD8D461A9454DB5BFF353FB617579">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f503</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX60F84E1494A14045A9A09655B078EE9F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0001f506</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBXEB16E5B96F8A43A585E6FCD77312837A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf00026237</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBX3EA360F478494BD1A47C0B4A2A195EE0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0002abe4</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX64B466299E2C47CBBD25CDB96442A95B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0002ac02</UniqueId>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX87B0B23C01134ADEBA2DF93D8F017315">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0002ae38</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX2EF0F3A578784E5DBBEE54031525CB29">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="Enabled">true</bool>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0002af07</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXF4294A0F53DD41A5B5A7FAD588078A64">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">45ac2ab6f9472b6a02db8cdf0004ee12</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>